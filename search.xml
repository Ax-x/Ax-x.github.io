<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CSRF 跨站请求伪造漏洞</title>
    <url>/2022/03/08/CSRF-%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>CSRF跨站请求伪造，由客户端发起，是一种劫持受信任用户向服务器发送非预期请求的攻击方式，与XSS相似，但比XSS更难防范，常与XSS一起配合攻击</p>
<span id="more"></span>
<p>攻击者盗用了用户的身份信息，以用户的名义发送恶意请求，对服务器来说这个请求是用户发起的，却完成了攻击者所期望的一个操作 XSS 利用站点内内的信任用户，盗取cookie CSRF通过伪装成受信任用户请求受信任的网站利用目标用户的合法身份，以目标的名义执行某些非法参数 利用条件：已经登录系统，用户访问URL 已存在的网站中让用户跳转</p>
<h2 id="CSRF漏洞防御方案"><a href="#CSRF漏洞防御方案" class="headerlink" title="CSRF漏洞防御方案"></a>CSRF漏洞防御方案</h2><p>1.当用户发送重要的请求时输入验证码<br>2.设置随机TOKEN —数据包的唯一值<br>3.检测referer来源，请求时判断请求连接是否为当前管理员正在使用的页面（管理员在编辑文章，黑客发来恶意的修改密码链接，因为修改密码页面管理员并没有在操作，所以攻击失败）<br>4.设置验证码<br>5.限制请求方式只能为post</p>
]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>First Blog</title>
    <url>/2022/01/01/First%20Blog/</url>
    <content><![CDATA[<p>Welcome to my blog! I’m glad to make friends with you. If you can browse my website, I will be grateful. In the future, I will upload my records and learning contents here. I hope the boss will take me with me！</p>
]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>RCE漏洞</title>
    <url>/2022/03/08/RCE%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>RCE漏洞是对命令执行/代码执行类漏洞的统称。这类漏洞因为可以通过网络远程执行命令或代码，可以直接获取一定权限，会造成较严重的影响，因此属于较高危的一类漏洞</p>
<span id="more"></span>

<h2 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h2><figure class="highlight"><table><tr><td class="code"><pre><span class="line">由于系统开发时使用了特殊函数，能够将传输进来的数据当作是操作系统命令去执行， 攻击者将注入的语句更改为系统命令作为操作系统命令执行，仅当Web应用程序代码包含操作系统调用并且调用中使用了用户输入时，才可能进行命令攻击。</span><br></pre></td></tr></table></figure>

<h2 id="远程代码执行"><a href="#远程代码执行" class="headerlink" title="远程代码执行"></a>远程代码执行</h2><figure class="highlight"><table><tr><td class="code"><pre><span class="line">代码注入攻击与命令注入攻击不同。因为需求设计，后台有时候需要把用户的输入作为代码的一部分进行执行,也就造成了代码执行漏洞。</span><br></pre></td></tr></table></figure>

<h2 id="漏洞检测"><a href="#漏洞检测" class="headerlink" title="漏洞检测"></a>漏洞检测</h2><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">任何外部输入都可以进行验证：文本字段，列表框，单选按钮，复选框，cookie，HTTP头数据，HTTP <span class="built_in">post</span>数据，隐藏字段，参数名称和参数值</span><br></pre></td></tr></table></figure>

<h2 id="敏感函数"><a href="#敏感函数" class="headerlink" title="敏感函数"></a>敏感函数</h2><h3 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">#命令执行</span></span><br><span class="line">    system()<span class="comment">//执行外部程序，并且显示输出</span></span><br><span class="line">    exec()<span class="comment">//执行一个外部程序</span></span><br><span class="line">    shell_exec()<span class="comment">//通过 shell 环境执行命令，并且将完整的输出以字符串的方式返回</span></span><br><span class="line">    passthru()<span class="comment">//执行外部程序并且显示原始输出</span></span><br><span class="line">    pcntl_exec()<span class="comment">//在当前进程空间执行指定程序</span></span><br><span class="line">    popen()<span class="comment">//打开进程文件指针</span></span><br><span class="line">    proc_open()<span class="comment">//执行一个命令，并且打开用来输入/输出的文件指针</span></span><br><span class="line"><span class="comment">#代码执行</span></span><br><span class="line">    <span class="keyword">eval</span>()<span class="comment">//把字符串作为PHP代码执行</span></span><br><span class="line">    assert()<span class="comment">//检查一个断言是否为 FALSE，可用来执行代码</span></span><br><span class="line">    preg_replace()<span class="comment">//执行一个正则表达式的搜索和替换</span></span><br><span class="line">    call_user_func()<span class="comment">//把第一个参数作为回调函数调用</span></span><br><span class="line">    call_user_func_array()<span class="comment">//调用回调函数，并把一个数组参数作为回调函数的参数</span></span><br><span class="line">    array_map()<span class="comment">//为数组的每个元素应用回调函数</span></span><br></pre></td></tr></table></figure>

<h3 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h3><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">java.lang.<span class="module-access"><span class="module"><span class="identifier">Runtime</span>.</span></span>get<span class="constructor">Runtime(.<span class="params">exec</span>(<span class="params">command</span>)</span>）Java中没有类似php中eval 函数这种直接可以将字符串转化为代码执行的函数，但是有反射机制，并且有各种基于反射机制的表达式引擎，如：OGNL、SpEL、MVEL等，这些都能造成代码执行漏洞。</span><br></pre></td></tr></table></figure>

<h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#命令执行</span></span><br><span class="line">    system()执行系统指令</span><br><span class="line">    popen()popen()方法用于从一个命令打开一个管道</span><br><span class="line">    subprocess.call执行由参数提供的命令</span><br><span class="line">    spawn 执行命令</span><br><span class="line"><span class="comment">#代码执行</span></span><br><span class="line">    <span class="built_in">exec</span>(string)<span class="comment"># Python代码的动态执行</span></span><br><span class="line">    <span class="built_in">eval</span>(string)<span class="comment"># 返回表达式或代码对象的值</span></span><br><span class="line">    execfile(string)<span class="comment"># 从一个文件中读取和执行Python脚本</span></span><br><span class="line">    <span class="built_in">input</span>(string)Python2.x 中 <span class="built_in">input</span>() 相等于 <span class="built_in">eval</span>(raw_input(prompt)) ，用来获取控制台的输入</span><br><span class="line">    <span class="built_in">compile</span>(string)<span class="comment"># 将源字符串编译为可执行对象</span></span><br></pre></td></tr></table></figure>

<h2 id="常见注入（利用）方式"><a href="#常见注入（利用）方式" class="headerlink" title="常见注入（利用）方式"></a>常见注入（利用）方式</h2><figure class="highlight perl"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、<span class="keyword">system</span>(<span class="string">&quot;$arg&quot;</span>);   可控点直接是待执行的程序如果我们能直接控制$arg，那么就能执行执行任意命令了。</span><br><span class="line"><span class="number">2</span>、<span class="keyword">system</span>(<span class="string">&quot;/bin/prog $arg&quot;</span>);<span class="regexp">//</span>可控点是传入程序的整个参数我们能够控制的点是程序的整个参数，我们可以直接用&amp;&amp; || 或 | 等等，利用与、或、管道命令来执行其他命令（可以涉及到很多linux命令行技巧）。</span><br><span class="line"><span class="number">3</span>、<span class="keyword">system</span>(<span class="string">&quot;/bin/prog -p $arg&quot;</span>);<span class="regexp">//</span>可控点是传入程序的某个参数的值（无引号包裹）我们控制的点是一个参数，我们也同样可以利用与、或、管道来执行其他命令，情境与二无异。</span><br><span class="line"><span class="number">4</span>、<span class="keyword">system</span>(<span class="string">&quot;/bin/prog --p=\&quot;$arg\&quot;&quot;</span>);<span class="regexp">//</span>可控点是传入程序的某个参数的值（有双引号包裹）这种情况压力大一点，有双引号包裹。如果引号没有被转义，我们可以先闭合引号，成为第三种情况后按照第三种情况来利用，如果引号被转义（addslashes），我们也不必着急。linux shell 环境下双引号中间的变量也是可以被解析的，我们可以在双引号内利用反引号执行任意命令 id</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL注入</title>
    <url>/2022/01/16/SQL%E6%B3%A8%E5%85%A5/</url>
    <content><![CDATA[<h1 id="sql注入是什么？"><a href="#sql注入是什么？" class="headerlink" title="sql注入是什么？"></a>sql注入是什么？</h1><ul>
<li>web应用对用户输入数据的合法性没有判断或过滤不严，sql语句中的变量是可控的，导致攻击者可以在web应用程序中事先定义好的查询语句的结尾上添加额外的SQL语句，实现非法操作，以此来实现欺骗数据库服务器执行非授权的任意查询，从而进一步得到相应的数据信息。<span id="more"></span></li>
</ul>
<h1 id="sql注入原理"><a href="#sql注入原理" class="headerlink" title="sql注入原理"></a>sql注入原理</h1><ul>
<li>对用户输入，传递的数据没有进行进一步的过滤，对执行的数据库语句没有进行过滤防护而导致，攻击者能够从输入的数据当中插入其他的数据库语句达到获取信息的效果。</li>
</ul>
<h1 id="sql注入危害"><a href="#sql注入危害" class="headerlink" title="sql注入危害"></a>sql注入危害</h1><ul>
<li><p>猜解后台数据库，这是利用最多的方式，盗取网站的敏感信息</p>
</li>
<li><p>绕过认证，列如绕过验证登录网站后台。</p>
</li>
<li><p>注入可以借助数据库的存储过程进行提权等操作</p>
</li>
</ul>
<h1 id="恶意用户利用SQL注入可以做到"><a href="#恶意用户利用SQL注入可以做到" class="headerlink" title="恶意用户利用SQL注入可以做到"></a>恶意用户利用SQL注入可以做到</h1><ul>
<li><p>1、可读取数据库中的库和表</p>
</li>
<li><p>2、可执行系统命令</p>
</li>
<li><p>3、可以修改任意文件</p>
</li>
<li><p>4、可以安装木马后门</p>
</li>
</ul>
<h1 id="sql注入类型"><a href="#sql注入类型" class="headerlink" title="sql注入类型"></a>sql注入类型</h1><h2 id="一、参数类型分类"><a href="#一、参数类型分类" class="headerlink" title="一、参数类型分类"></a>一、参数类型分类</h2><h3 id="数字型注入"><a href="#数字型注入" class="headerlink" title="数字型注入"></a>数字型注入</h3><ul>
<li>输入参数为整型时，如Id、年龄和页码等；</li>
</ul>
<h3 id="字符型注入"><a href="#字符型注入" class="headerlink" title="字符型注入"></a>字符型注入</h3><ul>
<li>输入参数为字符串型时，如姓名、职业、住址等；</li>
</ul>
<p>两者最大的区别：字符型注入一般要使用单双引号进行闭合，而数字型注入则不需要；</p>
<h2 id="二、数据提交的方式来分类"><a href="#二、数据提交的方式来分类" class="headerlink" title="二、数据提交的方式来分类"></a>二、数据提交的方式来分类</h2><h3 id="（1）GET-注入"><a href="#（1）GET-注入" class="headerlink" title="（1）GET 注入"></a>（1）GET 注入</h3><ul>
<li>提交数据的方式是 GET , 注入点的位置在 GET 参数部分。比如有这样的一个链接<a href="http://xxx.com/news.php?id=1">http://xxx.com/news.php?id=1</a> , id 是注入点。</li>
</ul>
<h3 id="（2）POST-注入"><a href="#（2）POST-注入" class="headerlink" title="（2）POST 注入"></a>（2）POST 注入</h3><ul>
<li>使用 POST 方式提交数据，注入点位置在 POST 数据部分，常发生在表单中。</li>
</ul>
<h3 id="（3）Cookie-注入"><a href="#（3）Cookie-注入" class="headerlink" title="（3）Cookie 注入"></a>（3）Cookie 注入</h3><ul>
<li>HTTP 请求的时候会带上客户端的 Cookie, 注入点存在 Cookie 当中的某个字段中。</li>
</ul>
<h3 id="（4）HTTP-头部注入"><a href="#（4）HTTP-头部注入" class="headerlink" title="（4）HTTP 头部注入"></a>（4）HTTP 头部注入</h3><ul>
<li>注入点在 HTTP 请求头部的某个字段中。比如存在 User-Agent 字段中。严格讲的话，Cookie 其实应该也是算头部注入的一种形式。因为在 HTTP 请求的时候，Cookie 是头部的一个字段。</li>
</ul>
<h2 id="三、按照执行效果来分类"><a href="#三、按照执行效果来分类" class="headerlink" title="三、按照执行效果来分类"></a>三、按照执行效果来分类</h2><h3 id="（1）基于布尔的盲注"><a href="#（1）基于布尔的盲注" class="headerlink" title="（1）基于布尔的盲注"></a>（1）基于布尔的盲注</h3><ul>
<li>即可以根据返回页面判断条件真假的注入。</li>
</ul>
<h3 id="（2）基于时间的盲注"><a href="#（2）基于时间的盲注" class="headerlink" title="（2）基于时间的盲注"></a>（2）基于时间的盲注</h3><ul>
<li>即不能根据页面返回内容判断任何信息，用条件语句查看时间延迟语句是否执行（即页面返回时间是否增加）来判断。</li>
</ul>
<h3 id="（3）基于报错注入"><a href="#（3）基于报错注入" class="headerlink" title="（3）基于报错注入"></a>（3）基于报错注入</h3><ul>
<li><p>即页面会返回错误信息，或者把注入的语句的结果直接返回在页面中。</p>
<ul>
<li><p>单引号</p>
</li>
<li><p>双引号</p>
</li>
<li><p>基于数字型注入</p>
</li>
</ul>
</li>
</ul>
<h3 id="（4）联合查询注入"><a href="#（4）联合查询注入" class="headerlink" title="（4）联合查询注入"></a>（4）联合查询注入</h3><ul>
<li>可以使用union的情况下的注入。</li>
</ul>
<h3 id="（5）堆查询注入"><a href="#（5）堆查询注入" class="headerlink" title="（5）堆查询注入"></a>（5）堆查询注入</h3><ul>
<li>可以同时执行多条语句的执行时的注入。</li>
</ul>
<h3 id="（6）宽字节注入"><a href="#（6）宽字节注入" class="headerlink" title="（6）宽字节注入"></a>（6）宽字节注入</h3><ul>
<li>宽字节注入原理即是利用编码转换，将服务器端强制添加的本来用于转义的\符号吃掉，从而能使攻击者输入的引号起到闭合作用，以至于可以进行SQL注入。</li>
</ul>
<p>宽字节介绍</p>
<ul>
<li>GB2312、GBK、GB18030、BIG5、Shift_JIS等这些都是常说的宽字节，实际上只有两字节。宽字节带来的安全问题主要是吃ASCII字符(一字节)的现象，即将两个ascii字符误认为是一个宽字节字符。而我们的网站开发一般使用的是utf-8的编码，个别会使用gbk，而UTF-8是用的ASCII编码，由于ASCII表示的字符只有128个，因此网络世界的规范是使用UNICODE编码，但是用ASCII表示的字符使用UNICODE并不高效。因此出现了中间格式字符集，被称为通用转换格式，及UTF。而字符与字符集的关系是字符是组成字符集的基本单位。对字符赋予一个数值来确定这个字符在该字符集中的位置。一个gbk编码汉字，占用2个字节。一个utf-8编码的汉字，占用3个字节。 gbk 首字节对应0×81-0xFE，尾字节对应0×40-0xFE（除0×7F），所以使用宽字节能够覆盖转移符号对应的编码。</li>
</ul>
<h1 id="各个类型的注入简介"><a href="#各个类型的注入简介" class="headerlink" title="各个类型的注入简介"></a>各个类型的注入简介</h1><ul>
<li><h2 id="最基础的注入-union注入攻击"><a href="#最基础的注入-union注入攻击" class="headerlink" title="最基础的注入-union注入攻击"></a>最基础的注入-union注入攻击</h2><ul>
<li><p>判断是get型还是post型注入；</p>
</li>
<li><p>找到正确的闭合规则；order by 查询字段数；</p>
</li>
<li><p>union select 1,2…..查看显示位是第几位，没有的话就试试把id=1的显示位让出来，让其等于id=-1；第二、三位显示出来了，那么即可在这两个位置写入sql语句；</p>
</li>
<li><p>查询当前数据库,当前mysql用户 union select 1,user(),database()；</p>
</li>
<li><p>查询当前数据库里面的表 union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=”data_name”;</p>
</li>
<li><p>查询到敏感表名user，继续查询表里面的字段 union select 1,2,group_concat(column_name) from information_schema.columns where table_name=”user”;</p>
</li>
<li><p>查询字段，例如“id”、”passwd”的内容 union select 1,id,passwd from user;</p>
</li>
<li><p>拿到用户、密码登入后台。</p>
</li>
</ul>
</li>
<li><h2 id="Boolean注入攻击-布尔盲注"><a href="#Boolean注入攻击-布尔盲注" class="headerlink" title="Boolean注入攻击-布尔盲注"></a>Boolean注入攻击-布尔盲注</h2><ul>
<li><p>查看现象，能报错，但没有报错信息，正确查询也显示不了查询内容就属于布尔盲注，只存在两种状态，对或错；</p>
</li>
<li><p>由页面的两种不同返回的状态来判定我们的闭合规则；</p>
</li>
<li><p>为了方便，我们这里假设返回正确用“yes”，返回错误用“no”来表示这两种状态找到闭合规则后，我们在闭合规则里面  and 1=1 和 and 1=2 测试一下，看看最后返回是不是两种状态；</p>
</li>
<li><p>布尔盲注要用到length()和substr()语句，用两种状态来猜解数据库、表名等的长度和正确字母；</p>
</li>
<li><p>先用 and length(database())&gt;2 来猜数据库的长度，使用的是二分法；</p>
</li>
<li><p>再用 and substr(database(),1,1)=’t’ 来确定第一个字母，可用burp跑，26个字母,哪个字母返回yes则代表第一个字母就是它；</p>
</li>
<li><p>and substr(database(),2,1)=’t’ 代表当前数据库的第二个字母；</p>
</li>
<li><p>最后结合长度，成功的将数据库猜解出来；</p>
</li>
<li><p>后面的操作跟union注入的步骤差不多了，只是sql语句写在 上文的 database() 处。</p>
</li>
</ul>
</li>
<li><h2 id="报错注入攻击"><a href="#报错注入攻击" class="headerlink" title="报错注入攻击"></a>报错注入攻击</h2><ul>
<li><p>只要注入点有sql报错信息，那么就可以使用报错注入；</p>
</li>
<li><p>还是一样，引号报错，然后找到闭合规则，页面正常显示，则可以在闭合规则中开始写入报错注入的sql语句；</p>
</li>
<li><p>updatexml报错获取当前数据库：and updatexml(1,concat(0x7e,(select database()),0x7e),1)</p>
</li>
<li><p>floor报错获取当前数据库：and (select 1 from (select count(*),concat((database()),floor (rand(0)*2))x from information_schema.tables group by x)a)</p>
</li>
<li><p>两种方式都可行，如果第一个不行就试试第二个</p>
</li>
<li><p>接着可以利用select语句替换掉上面database()来继续获取数据库中的表名、字段名，查询语句和union注入攻击的语句相同；</p>
</li>
<li><p>只不过这里不能再使用group_concat了，因为报错注入只显示一条结果，所以需要使用limit语句；</p>
</li>
</ul>
</li>
<li><h2 id="时间注入攻击-延时盲注"><a href="#时间注入攻击-延时盲注" class="headerlink" title="时间注入攻击-延时盲注"></a>时间注入攻击-延时盲注</h2><ul>
<li><p>没有明确的现象，不管是对是错都返回一个状态；</p>
</li>
<li><p>但是如果用sleep(5)方法，能让响应时间延迟为5秒以上，那么就为时间盲注；</p>
</li>
<li><p>我们用sleep(5)函数构造了一个时间延时的状态，因此，我们又有了两种状态，像布尔盲注一样可以根据这两种状态来判定数据库、表名和字段名的长度和正确的每个字母；</p>
</li>
<li><p>同样的找到正确的闭合规则，当然，这个闭合规则得配合着 and sleep(5)语句来构造，哪一个闭合规则执行了sleep(5)，那么就是正确得闭合规则；</p>
</li>
<li><p>时间盲注配合着  if(A,B,C)  语句结合使用，含义是：如果A是 true，则返回B（也就是执行B），否则返回C（执行C）；</p>
</li>
<li><p>那么判断当前数据库名的长度的语句为：if (length(database())&gt;1,sleep(5),1)就是说如果数据库长度大于1，那么响应延时5秒，否则执行select 1(也就是不延时)，由此来推出数据库长度。</p>
</li>
<li><p>判断当前数据库名的第一个和第二个字母的语句：</p>
</li>
<li><p>if(substr(database(),1,1)=’s’,sleep(5),1)</p>
</li>
<li><p>if(substr(database(),2,1)=’s’,sleep(5),1)</p>
</li>
<li><p>只有第一个字母等于26个字母中正确的字母时，才会延时5秒，因此可以通过burp或者sqlmap来跑。</p>
</li>
<li><p>根据数据库名长度以此内推即可得出完整的数据库的库命、表名、字段名和具体内容。</p>
</li>
</ul>
</li>
<li><h2 id="堆叠查询注入攻击"><a href="#堆叠查询注入攻击" class="headerlink" title="堆叠查询注入攻击"></a>堆叠查询注入攻击</h2><ul>
<li><p>可以使用堆叠注入的地方也可以使用布尔盲注与时间盲注；</p>
</li>
<li><p>同样先找出正确的闭合规则，然后也看两种状态来猜解库名、表名等；</p>
</li>
<li><p>类似与下面在分号后面可执行新的语句：</p>
</li>
<li><p>;select if(length(database())&gt;1,sleep(3),1);select if(substr(database(),1,1)=’r’,sleep(3),1)</p>
</li>
<li><p>堆叠的;分号后可以执行新的sql语句，因此在知道网站根目录的情况下可以直接写日志拿shell。</p>
</li>
</ul>
</li>
<li><h2 id="二次注入攻击"><a href="#二次注入攻击" class="headerlink" title="二次注入攻击"></a>二次注入攻击</h2><ul>
<li><p>二次注入一共有两个url，url一用来注入，也就是注入点，插入sql语句的地方，另外一个url用来返回信息；</p>
</li>
<li><p>也就是url一插入了sql语句，url一的响应里面就会返回这条信息对应的id值，然后url二就传入这个新id值，然后访问，响应回来之后将会爆出sql语句查询的结果，正确或者错误的sql信息；</p>
</li>
<li><p>就相当于url是一个用户注册的地方，用户注册后会在数据库里面加入新id存放用户的注册信息，那么这个id可以传给url二来访问，url二就可以显示出用户的注册信息，但如果注册信息含义恶意sql语句，url二就会显示出敏感的数据库信息；</p>
</li>
<li><p>跟union注入攻击差不多，只是回显的信息需要在另外的url中显示出来了；</p>
</li>
<li><p>后面就是union注入攻击的常规操作。</p>
</li>
</ul>
</li>
<li><h2 id="宽字节注入攻击"><a href="#宽字节注入攻击" class="headerlink" title="宽字节注入攻击"></a>宽字节注入攻击</h2><ul>
<li><p>如果遇到单、双引号被转义，变成了反斜杠，导致参数id无法逃逸单引号的包围；</p>
</li>
<li><p>一般情况下，此处就不存在sql注入漏洞的；但是如果数据库的编码为GBK时，就可以使用宽字节注入，因此在不知道是否是GBK编码时，都可以尝试去使用宽字节注入；</p>
</li>
<li><p>宽字节的格式是在地址后先加一个  %df  ，再加单引号，因为反斜杠的编码为%5c，在GBK编码中，%df%5c是繁体字“連”，因此，单引号成功逃逸，爆出sql错误；</p>
</li>
<li><p>因此构造闭合规则时，在单引号前面加上  %df 就行了；</p>
</li>
<li><p>之后在闭合规则中写入同union注入的一些查询语句就行了；</p>
</li>
</ul>
</li>
<li><h2 id="base64注入攻击"><a href="#base64注入攻击" class="headerlink" title="base64注入攻击"></a>base64注入攻击</h2><ul>
<li><p>如果遇到url的参数id的值看起来像base64的，先拿去url解码，然后如果是base64，拿去base64解码，解出来的应该就是id的值（1，2等数字）；</p>
</li>
<li><p>那么如果要对这个url进行sql注入测试，就需要对id后面的所有值进行base64编码；</p>
</li>
<li><p>注入的方式步骤都是跟union注入一样的，只不过后面的所有值（整个payload）都要进行base64编码后传给url的c参数提交，包括闭合规则。</p>
</li>
</ul>
</li>
<li><h2 id="HTTP请求头参数注入-cookie注入攻击"><a href="#HTTP请求头参数注入-cookie注入攻击" class="headerlink" title="HTTP请求头参数注入-cookie注入攻击"></a>HTTP请求头参数注入-cookie注入攻击</h2><ul>
<li><p>抓包对一个url的http请求头的所有参数进行sql注入测试，里面的所有参数都有可能存在注入点，如果响应包出现sql报错，那么测试的这个参数就是注入点；</p>
</li>
<li><p>常见的http头部注入的参数有：【Referer】、【X-Forwarded-For】、【Cookie】、【X-Real-IP】、【Accept-Language】、【Authorization】如果测试到cookie参数的时候，响应有报sql错误，那么就是cookie注入攻击；</p>
</li>
<li><p>和union注入的差别就在于注入点不一样，之后使用union注入的方法即可。</p>
</li>
</ul>
</li>
<li><h2 id="HTTP请求头参数注入-XFF注入攻击"><a href="#HTTP请求头参数注入-XFF注入攻击" class="headerlink" title="HTTP请求头参数注入-XFF注入攻击"></a>HTTP请求头参数注入-XFF注入攻击</h2><ul>
<li><p>XFF注入即HTTP头部的X-Forwarded-for参数存在sql注入；</p>
</li>
<li><p>例如测试此参数的值  X-Forwarded-for:127.0.0.1’  响应有sql报错，那么此处就是注入点；</p>
</li>
<li><p>之后使用union注入的方法完成即可。</p>
</li>
</ul>
</li>
</ul>
<h1 id="SQL注入修复方案"><a href="#SQL注入修复方案" class="headerlink" title="SQL注入修复方案"></a>SQL注入修复方案</h1><ul>
<li><p>解决SQL注入问题的关键是对所有可能来自用户输入的数据进行严格的检查、对数据库配置使用最小权限原则。</p>
</li>
<li><p>1、所有的查询语句都使用数据库提供的参数化查询接口，参数化的语句使用参数而不是将用户输入变量嵌入到SQL语句中。当前几乎所有的数据库系统都提供了参数化SQL语句执行接口，使用此接口可以非常有效的防止SQL注入攻击。</p>
</li>
<li><p>2、对进入数据库的特殊字符（’”\，括号&amp;*;等）进行转义处理，或编码转换。</p>
</li>
<li><p>3、严格限制变量类型，比如整型变量就采用intval()函数过滤，数据库中的存储字段必须对应为int型。</p>
</li>
<li><p>4、数据长度应该严格规定，能在一定程度上防止比较长的SQL注入语句无法正确执行。</p>
</li>
<li><p>5、网站每个数据层的编码统一，建议全部使用UTF-8编码，上下层编码不一致有可能导致一些过滤模型被绕过。</p>
</li>
<li><p>6、严格限制网站用户的数据库的操作权限，给此用户提供仅仅能够满足其工作的权限，从而最大限度的减少注入攻击对数据库的危害。</p>
</li>
<li><p>7、避免网站显示SQL错误信息，比如类型错误、字段不匹配等，防止攻击者利用这些错误信息进行一些判断。</p>
</li>
<li><p>8、在网站发布之前建议使用一些专业的SQL注入检测工具进行检测，及时修补这些SQL注入漏洞。</p>
</li>
<li><p>9、确认PHP配置文件中的magicquotesgpc选项保持开启</p>
</li>
<li><p>10、配置安全狗，阿里云盾，等网络安全公司的产品</p>
</li>
</ul>
]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>SSRF服务器端请求伪造</title>
    <url>/2022/03/08/SSRF%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0/</url>
    <content><![CDATA[<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>SSRF服务器端请求伪造是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。一般情况下，SSRF攻击的目标是从外网无法访问的内部系统。<span id="more"></span>（正是因为 它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内部系统）SSRF 形成的原因大都是由于服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制。比如从指定URL地址获取网页文本内容，加载指定地址的图片，下载等等。 注释：除了http/https等方式可以造成ssrf，类似tcp connect 方式也可以探测内网一些ip 的端口是否开发服务，只不过危害比较小而已。</p>
<h2 id="可实现攻击"><a href="#可实现攻击" class="headerlink" title="可实现攻击"></a>可实现攻击</h2><figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>	可以对服务器所在内网、本地进行端口扫描，获取一些服务的banner信息<span class="comment">;</span></span><br><span class="line"><span class="number">2</span>	攻击运行在内网或本地的应用程序（比如溢出）<span class="comment">;</span></span><br><span class="line"><span class="number">3</span>	对内网web应用进行指纹识别，通过访问默认文件实现<span class="comment">;</span></span><br><span class="line"><span class="number">4</span>	攻击内外网的web应用，主要是使用get参数就可以实现的攻击（比如struts2，sqli等）<span class="comment">;</span></span><br><span class="line"><span class="number">5</span>	利用file协议读取本地文件等。</span><br></pre></td></tr></table></figure>

<h2 id="可能出现的地方"><a href="#可能出现的地方" class="headerlink" title="可能出现的地方"></a>可能出现的地方</h2><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>社交分享功能：获取超链接的标题等内容进行显示</span><br><span class="line"><span class="number">2.</span>转码服务：通过URL地址把原地址的网页内容调优使其适合手机屏幕浏览</span><br><span class="line"><span class="number">3.</span>在线翻译：给网址翻译对应网页的内容</span><br><span class="line"><span class="number">4.</span>图片加载/下载：例如富文本编辑器中的点击下载图片到本地；通过URL地址加载或下载图片</span><br><span class="line"><span class="number">5.</span>图片/文章收藏功能：主要其会取URL地址中title以及文本的内容作为显示以求一个好的用具体验</span><br><span class="line"><span class="number">6.</span>云服务厂商：它会远程执行一些命令来判断网站是否存活等，所以如果可以捕获相应的信息，就可以进行ssrf测试</span><br><span class="line"><span class="number">7.</span>网站采集，网站抓取的地方：一些网站会针对你输入的url进行一些信息采集工作</span><br><span class="line"><span class="number">8.</span>数据库内置功能：数据库的比如mongodb的copyDatabase函数</span><br><span class="line"><span class="number">9.</span>邮件系统：比如接收邮件服务器地址</span><br><span class="line"><span class="number">10.</span>编码处理, 属性信息处理，文件处理：比如ffpmg，ImageMagick，docx，pdf，<span class="type">xml</span>处理器等</span><br><span class="line"><span class="number">11.</span>未公开的api实现以及其他扩展调用URL的功能：可以利用google 语法加上这些关键字去寻找SSRF漏洞 一些的url中的关键字：<span class="keyword">share</span>、wap、url、link、src、source、target、u、<span class="number">3</span>g、display、sourceURl、imageURL、<span class="keyword">domain</span>……</span><br><span class="line"><span class="number">12.</span>从远程服务器请求资源（upload <span class="keyword">from</span> url 如discuz！；<span class="keyword">import</span> &amp; expost rss feed 如web blog；使用了<span class="type">xml</span>引擎对象的地方 如wordpress xmlrpc.php）</span><br></pre></td></tr></table></figure>

<h2 id="漏洞验证"><a href="#漏洞验证" class="headerlink" title="漏洞验证"></a>漏洞验证</h2><figure class="highlight sas"><table><tr><td class="code"><pre><span class="line">1.让服务端去访问相应的网址</span><br><span class="line">2.让服务端去访问自己所处内网的一些指纹文件来判断是否存在相应的cms</span><br><span class="line">3.可以使用<span class="meta">file</span>、dict、gopher[11]、ftp协议进行请求访问相应的文件</span><br><span class="line">4.攻击内网web应用（可以向内部任意主机的任意端口发送精心构造的数据包&#123;payload&#125;）</span><br><span class="line">5.攻击内网应用程序（利用跨协议通信技术）</span><br><span class="line">6.判断内网主机是否存活：方法是访问看是否有端口开放</span><br><span class="line">7.DoS攻击（请求大文件，始终保持连接<span class="meta">keep</span>-alive always）</span><br></pre></td></tr></table></figure>

<h2 id="限制绕过"><a href="#限制绕过" class="headerlink" title="限制绕过"></a>限制绕过</h2><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>.http:<span class="regexp">//</span>baidu.com@www.baidu.com<span class="regexp">/与http:/</span><span class="regexp">/www.baidu.com/</span>请求时是相同的</span><br><span class="line"><span class="number">2</span>.各种IP地址的进制转换</span><br><span class="line"><span class="number">3</span>.URL跳转绕过：http:<span class="regexp">//</span>www.hackersb.cn<span class="regexp">/redirect.php?url=http:/</span><span class="regexp">/192.168.0.1/</span></span><br><span class="line"><span class="number">4</span>.短网址绕过http:<span class="regexp">//</span>t.cn/RwbLKDx </span><br><span class="line"><span class="number">5</span>.xip.io来绕过：http:<span class="regexp">//</span>xxx.<span class="number">192.168</span>.<span class="number">0.1</span>.xip.io/== <span class="number">192.168</span>.<span class="number">0.1</span> (xxx 任意） 指向任意ip的域名：xip.io(<span class="number">37</span>signals开发实现的定制DNS服务)</span><br><span class="line"><span class="number">6</span>.限制了子网段，可以加 :<span class="number">80</span> 端口绕过。http:<span class="regexp">//</span>tieba.baidu.com<span class="regexp">/f/</span>commit<span class="regexp">/share/</span>openShareApi?url=http:<span class="regexp">//</span><span class="number">10.42</span>.<span class="number">7.78</span>:<span class="number">80</span></span><br><span class="line"><span class="number">7</span>.探测内网域名，或者将自己的域名解析到内网ip</span><br><span class="line"><span class="number">8</span>.例如http:<span class="regexp">//</span><span class="number">10.153</span>.<span class="number">138.81</span><span class="regexp">/ts.php, 修复时容易出现的获取host时以/</span>分割来确定host， 但这样可以用http:<span class="regexp">//</span>abc@<span class="number">10.153</span>.<span class="number">138.81</span>/绕过</span><br></pre></td></tr></table></figure>

<h2 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h2><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">1</span>	过滤内网服务器对公网服务器请求的响应。如果Web应用是获取某一类型的文件，在把返回结果展示给用户之前应先验证返回的信息是否符合文件类型标准，比如返回信息应为图片，如果返回信息是HTML，则停止将返回信息返回客户端。</span><br><span class="line"><span class="attribute">2</span>	统一错误提示信息，避免用户可以根据错误信息来判断远端服务器的端口状态。</span><br><span class="line"><span class="attribute">3</span>	在内网服务器的防火墙上限制公网服务器的请求端口为HTTP等协议常用端口，如：<span class="number">80</span>、<span class="number">443</span>、<span class="number">8080</span>、<span class="number">8090</span>。</span><br><span class="line"><span class="attribute">4</span>	若公网服务器的内网IP与内网无业务通信，建议将公网服务器对应的内网IP列入黑名单，避免应用被用来获取内网数据。</span><br><span class="line"><span class="attribute">5</span>	内网服务器禁用不必要的协议，仅允许HTTP和HTTPS请求，防止类似于file:///、gopher://、ftp:// 等协议引起的安全问题。</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>XSS跨站脚本攻击</title>
    <url>/2022/01/17/XSS%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB/</url>
    <content><![CDATA[<h1 id="什么是XSS-XSS原理"><a href="#什么是XSS-XSS原理" class="headerlink" title="什么是XSS/XSS原理"></a>什么是XSS/XSS原理</h1><ul>
<li><p>攻击者嵌入恶意脚本代码到用户会访问到的页面中，用户访问该页面的时候，就引起恶意脚本代码的执行，从而达到恶意攻击用户的目的。攻击者可以使用户在浏览器中执行其预定义的恶意脚本，变量接受数据的时候，数据可以写成js脚本代码，进行回显操作</p>
</li>
<li><p>本质上属于前端漏洞，产生在浏览器和js代码中的漏洞</p>
<span id="more"></span></li>
</ul>
<h1 id="XSS类型"><a href="#XSS类型" class="headerlink" title="XSS类型"></a>XSS类型</h1><ul>
<li><p>反射型XSS(非持续型XSS)</p>
</li>
<li><p>储存型XSS(持续型XSS）</p>
</li>
<li><p>DOM XSS</p>
</li>
</ul>
<h1 id="具体区别"><a href="#具体区别" class="headerlink" title="具体区别"></a>具体区别</h1><ul>
<li><p>反射型：数据提交过去时，会在代码执行之后直接反馈回来发包x=zzx=&gt;x.php=&gt;回包</p>
</li>
<li><p>存储型：数据提交过去时，会在代码执行之后储存到数据库的某个表里，然后反馈回来发包x=zzx=&gt;x.php=&gt;写到数据库某个表=&gt;x.php&gt;回显</p>
</li>
<li><p>DOM型：发包x=zzx=&gt;本地浏览器静态前端代码=&gt;x.php</p>
</li>
<li><p>反射型和储存型属于后端语言进行数据处理，而DOM型是用js代码进行处理 </p>
</li>
</ul>
<h1 id="三者原理"><a href="#三者原理" class="headerlink" title="三者原理"></a>三者原理</h1><ul>
<li><p>反射型XSS：应用或API没有对用户输入数据进行验证或没进行转义然后作为HTML的输出的一部分，能够使得攻击者在受害者的浏览器上执行任意HTML和JavaScript。</p>
</li>
<li><p>存储型XSS：应用或API存储未格式化的用户输入，且该输入之后会被其他用户或管理员浏览到。</p>
</li>
<li><p>DOM XSS：动态包含攻击者可控制数据到页面中的JavaScript框架， 单页应用，API易受DOM XSS。</p>
</li>
<li><p>涉及函数类：常见的输出类函数</p>
</li>
</ul>
<h1 id="如何检测"><a href="#如何检测" class="headerlink" title="如何检测"></a>如何检测</h1><ul>
<li><p>方法一： 查看代码，查找关键的变量,   客户端将数据传送给Web 服务端一般通过三种方式 Querystring, Form表单，以及cookie.  例如在ASP的程序中，通过Request对象获取客户端的变量。 假如变量没有经过htmlEncode处理， 那么这个变量就存在一个XSS漏洞</p>
</li>
<li><p>方法二：xss跨站漏洞测试语句， 在网页中的Textbox或者其他能输入数据的地方，输入测试语句， 看能不能弹出对话框，能弹出的话说明存在XSS漏洞， 在URL中查看有那些变量通过URL把值传给Web服务器， 把这些变量的值退换成测试语句。  然后看是否能执行</p>
</li>
<li><p>方法三:  自动化测试XSS漏洞</p>
</li>
</ul>
<h1 id="可能存在XSS漏洞点"><a href="#可能存在XSS漏洞点" class="headerlink" title="可能存在XSS漏洞点"></a>可能存在XSS漏洞点</h1><ul>
<li>用户能够输入提交数据的地方，文本框，url，请求头等等</li>
</ul>
<h1 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h1><ul>
<li><p>如劫持用户会话，插入恶意内容、重定向用户、使用恶意软件劫持用户浏览器、繁殖XSS蠕虫，甚至破坏网站、修改路由器配置信息等。</p>
</li>
<li><p>XSS实质上就是JS脚本，任何JS脚本能实现的功能，XSS也能实现能做到的Cookie劫持、构造GET和POST请求、XSS钓鱼、识别用户浏览器、识别用户安装的软件等</p>
</li>
</ul>
<h1 id="防范修复"><a href="#防范修复" class="headerlink" title="防范修复"></a>防范修复</h1><ul>
<li><p>前端采用大型框架Angular,Vue,React等等。</p>
</li>
<li><p>用session代替cookie。</p>
</li>
<li><p>对于用户输入的数据要严格过滤写入数据库的数据，一定要保证合理过滤。</p>
</li>
<li><p>对于所有输出的地方，一定要做好过滤工作，比如采用模版渲染等等。</p>
</li>
<li><p>使用Token</p>
</li>
<li><p>使用HttpOnly</p>
</li>
</ul>
<h1 id="什么是HttpOnly？"><a href="#什么是HttpOnly？" class="headerlink" title="什么是HttpOnly？"></a>什么是HttpOnly？</h1><ul>
<li>如果在cookie中设置了HTTPonly属性，那么通过js脚本将无法读取到cookie信息，这样能有效防止XSS攻击。</li>
</ul>
<h1 id="绕过httponly"><a href="#绕过httponly" class="headerlink" title="绕过httponly"></a>绕过httponly</h1><ul>
<li><p>浏览器未保存账号密码：需要XSS产生登录地址，利用表单劫持</p>
</li>
<li><p>浏览器保存了账号密码：产生后台的XSS，储存型XSS，如留言等，利用浏览器读取账号密码</p>
</li>
</ul>
<h1 id="如何绕过"><a href="#如何绕过" class="headerlink" title="如何绕过"></a>如何绕过</h1><ul>
<li><p>修改编码格式</p>
</li>
<li><p>加密解密算法</p>
</li>
<li><p>结合其他漏洞绕过</p>
</li>
<li><p>大小写onerror函数</p>
</li>
<li><p>配合平台，例如<a href="http://xssfuzzer.com/">xssfuzzer.com</a>生成语句</p>
</li>
<li><p>工具：Xwaf,XSStrike</p>
</li>
</ul>
]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>python&amp;&amp;shell--批量跑主机脚本</title>
    <url>/2022/01/21/python-shell-%E6%89%B9%E9%87%8F%E8%B7%91%E4%B8%BB%E6%9C%BA%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>上周去现场，大佬说年前要跑主机脚本，就是服务器有点多，问有没有办法一键下发，然后执行脚本去跑，跑完之后回收数据，我听这需求，这不是有手就行？然后就应了下来，说我试试，我本以为就是简单的写个py脚本的事情，确认好需求之后就直接开整，刚开始我写的是使用ssh服务去批量搞。</p>
<span id="more"></span>

<h1 id="二、python实现"><a href="#二、python实现" class="headerlink" title="二、python实现"></a>二、python实现</h1><p>先确定下流程，大概的流程就是这四个：</p>
<ol>
<li>连接服务器</li>
<li>上传脚本</li>
<li>执行脚本</li>
<li>回收数据</li>
</ol>
<p>最重要的是先连接上去，不然想得再好都没用，连接的话我用是py的paramiko，功能挺强大的，Paramiko是用py写的一个模块，远程连接到Linux服务器，查看上面的日志状态，批量配置远程服务器，文件上传，文件下载等都可以，除此之外我还用到了pandas，毕竟要批量的话，要去读取表格数据，从表格里面去获取每一台主机的信息，而在paramiko的连接这块有几个坑，首先是连接上去，连接上去有很多种方式，首先分为两大类，一类是SSH，一类是FTP，然后每一类都有两种连接方式，一种是基于密码，一种是基于密钥。先说下SSH连接上去的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ssh = paramiko.SSHClient()</span><br><span class="line">ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())</span><br><span class="line">ssh.connect(<span class="string">&quot;IP&quot;</span>,<span class="number">22</span>,<span class="string">&quot;user&quot;</span>, <span class="string">&quot;password&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>这个的话是没办法上传下载文件的，如果我们要上传文件上去，并且回收数据的话，用这种是没办法实现的，当然也可能是我太菜了，如果有大铁子能实现，麻烦带带小弟。所以这边我使用的是Transport，这种方式连接上去之后能够实现很多功能，可以说是一个小型的putty了。</p>
<p>关键代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> paramiko</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="comment">#获取表格数据</span></span><br><span class="line">df = pd.read_excel(<span class="string">&#x27;server_information.xlsx&#x27;</span>)</span><br><span class="line">data=df.values</span><br><span class="line"><span class="comment">#获取单列长度，之后可以作为循环次数的依据</span></span><br><span class="line">L = <span class="built_in">len</span>(df)</span><br><span class="line"><span class="comment">#------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">#这里做了个分割，是因为下面这块我把for去掉了，上面的表格是需要循环的时候用的，下面针对单个服务器进行说明</span></span><br><span class="line">IP = data[i][<span class="number">0</span>]</span><br><span class="line">port = data[i][<span class="number">1</span>]</span><br><span class="line">name=data[i][<span class="number">2</span>]</span><br><span class="line">password=data[i][<span class="number">3</span>]</span><br><span class="line"><span class="comment"># 实例化一个transport对象</span></span><br><span class="line">trans = paramiko.Transport((IP, port))</span><br><span class="line"><span class="comment"># 建立连接</span></span><br><span class="line">trans.connect(username=name, password=password)</span><br><span class="line"><span class="comment"># 将sshclient的对象的transport指定为以上的trans</span></span><br><span class="line">ssh = paramiko.SSHClient()</span><br><span class="line">ssh._transport = trans</span><br><span class="line">sftp = paramiko.SFTPClient.from_transport(trans)</span><br><span class="line"><span class="comment">#下面是执行了获取IP的命令，因为回收的数据命名格式有根据本机IP来，所以这里先获取下IP</span></span><br><span class="line"><span class="comment"># stdout 为正确输出，stderr为错误输出，同时是有1个变量有值</span></span><br><span class="line">stdin, stdout, stderr = ssh.exec_command(<span class="string">&#x27;ip a|grep inet|grep brd&#x27;</span>)</span><br><span class="line"><span class="comment"># inet 10.0.20.12/22 brd 10.0.23.255 scope global eth0</span></span><br><span class="line"><span class="comment"># 打印执行结果</span></span><br><span class="line">i_IP = stdout.read().decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">Intranet_IP_str= i_IP.split()</span><br><span class="line">Intranet_IP = Intranet_IP_str[<span class="number">1</span>].split(<span class="string">&#x27;/&#x27;</span>)</span><br><span class="line"><span class="comment"># 10.0.20.12 22</span></span><br></pre></td></tr></table></figure>

<p>这两种连接方式我用的都是账号密码连接登录，用密钥的话也可以，具体的可以去百度下用法，其实都差不多。连接上去之后，你以为就搞定了，确实是能上传下载文件的，但是还是有坑，这里离谱的一点就是，连接上去之后你没办法去到别的文件夹下面，也就是说，你始终在根目录下面。</p>
<p><img src="https://ax-x.github.io/2022/01/21/python-shell-%E6%89%B9%E9%87%8F%E8%B7%91%E4%B8%BB%E6%9C%BA%E8%84%9A%E6%9C%AC/image-20220109152332407-16417130136852.png" alt="image-20220109152332407"></p>
<p>后面我去找了好久，看了下exec_command的说明才知道，原来每次执行完之后，他都会跳回到原目录下面，也就是说，虽然你执行了cd命令，但是他cd过去之后由于这个函数的原因，他会自己回到原来的目录下面，这就难搞了，我怎么去到我想要的那个文件夹下面去执行文件啊，本来试了下，根据路径去执行文件，但是试了几次发现不行，它只支持执行本目录的文件。</p>
<p>找了一段时间之后，发现可以cd到别的文件夹下面，但是需要去写别的东西，然后为了偷懒，我开始尝试一次执行多条命令，毕竟两条命令搞不定，我就一条命令完成，但是拼接也不是我们用的那种&amp;&amp;了，这个函数有个独特的地方就是，它自带了一个执行多条命令的功能，在一条命令后面使用“;”就可以把命令隔开，看成是两条命令了，例如</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">stdin, stdout, stderr = ssh.exec_command(<span class="string">&#x27;cd tmp;ls&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><img src="https://ax-x.github.io/2022/01/21/python-shell-%E6%89%B9%E9%87%8F%E8%B7%91%E4%B8%BB%E6%9C%BA%E8%84%9A%E6%9C%AC/image-20220109152452438-16417130933893.png" alt="image-20220109152452438"></p>
<p>它就会先cd到tmp这个目录下面，然后执行ls命令，到这无法上传下载文件，无法跳转目录两个坑基本上就填上了，这里贴下完整的数据，表格的格式是IP，端口，用户名，密码。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> paramiko</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">df = pd.read_excel(<span class="string">&#x27;server_information.xlsx&#x27;</span>)</span><br><span class="line">data=df.values</span><br><span class="line">L = <span class="built_in">len</span>(df)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;检测到当前主机数：&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(L)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,L):</span><br><span class="line">    IP = data[i][<span class="number">0</span>]</span><br><span class="line">    port = data[i][<span class="number">1</span>]</span><br><span class="line">    name=data[i][<span class="number">2</span>]</span><br><span class="line">    password=data[i][<span class="number">3</span>]</span><br><span class="line">    <span class="comment"># 实例化一个transport对象</span></span><br><span class="line">    trans = paramiko.Transport((IP, port))</span><br><span class="line">    <span class="comment"># 建立连接</span></span><br><span class="line">    trans.connect(username=name, password=password)</span><br><span class="line">    <span class="comment"># 将sshclient的对象的transport指定为以上的trans</span></span><br><span class="line">    ssh = paramiko.SSHClient()</span><br><span class="line">    ssh._transport = trans</span><br><span class="line">    sftp = paramiko.SFTPClient.from_transport(trans)</span><br><span class="line">    stdin, stdout, stderr = ssh.exec_command(<span class="string">&#x27;ip a|grep inet|grep brd&#x27;</span>)</span><br><span class="line">    <span class="comment"># inet 10.0.20.12/22 brd 10.0.23.255 scope global eth0</span></span><br><span class="line">    i_IP = stdout.read().decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    Intranet_IP_str= i_IP.split()</span><br><span class="line">    Intranet_IP = Intranet_IP_str[<span class="number">1</span>].split(<span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">    <span class="comment"># 10.0.20.12 22</span></span><br><span class="line">    <span class="comment">#localpath—本地文件地址，remotepath——服务器存放地址</span></span><br><span class="line">    sftp.put(localpath=<span class="string">&#x27;/home/a.sh&#x27;</span>,</span><br><span class="line">             remotepath=<span class="string">&#x27;/tmp/a.sh&#x27;</span>)</span><br><span class="line">    stdin, stdout, stderr = ssh.exec_command(<span class="string">&#x27;cd tmp;./a.sh&#x27;</span>)</span><br><span class="line">    Host_information = stdout.read().decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    time.sleep(<span class="number">10</span>)</span><br><span class="line">    sftp.get(localpath=Intranet_IP[<span class="number">0</span>]+<span class="string">&#x27;.xml&#x27;</span>,</span><br><span class="line">             remotepath=<span class="string">&#x27;/tmp/&#x27;</span>+Intranet_IP[<span class="number">0</span>]+<span class="string">&#x27;.xml&#x27;</span>)</span><br><span class="line">    <span class="comment">#sftp.get—下载文件，sftp.put—上传文件</span></span><br><span class="line">    <span class="built_in">print</span>(IP+<span class="string">&quot;:已完成&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><img src="https://ax-x.github.io/2022/01/21/python-shell-%E6%89%B9%E9%87%8F%E8%B7%91%E4%B8%BB%E6%9C%BA%E8%84%9A%E6%9C%AC/image-20220115172343072-164223862468715.png" alt="image-20220115172343072"></p>
<p>当我开开心心提交过去给客户的时候，不出意外要有意外了，客户说想要shell脚本，啊这，也行！shell而已，这回先把客户那边开放的端口，服务啥的给问清楚，具体需要我做到什么，先了解清楚了先，然后一番讨价还价下来，客户说他那边有个平台能批量上传和运行文件了，叫我实现下回收就行了，那这还不好办。</p>
<h1 id="三、shell脚本实现"><a href="#三、shell脚本实现" class="headerlink" title="三、shell脚本实现"></a>三、shell脚本实现</h1><p>回到脚本这来，已知客户需要的是shell脚本，那怎么办呢，其实shell也有支持连接其他服务器的功能，而且方式还很多，写的话也不难写，话不多说，开整。首先我想的还是用ftp服务，毕竟这个能满足所有需求，然后我就搞了个ftp的。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash">用户名</span></span><br><span class="line">user=</span><br><span class="line"><span class="meta">#</span><span class="bash">密码</span></span><br><span class="line">password=</span><br><span class="line"><span class="meta">#</span><span class="bash">本地存在这个文件的目录</span></span><br><span class="line">local_url=/tmp</span><br><span class="line"><span class="meta">#</span><span class="bash">上传的目的目录</span></span><br><span class="line">server_url=/home</span><br><span class="line"><span class="meta">#</span><span class="bash">服务器IP</span></span><br><span class="line">ip=</span><br><span class="line"><span class="meta">#</span><span class="bash">端口</span></span><br><span class="line">port=22</span><br><span class="line">cd $&#123;local_url&#125;;</span><br><span class="line"><span class="meta">#</span><span class="bash">定位在50分钟内生成的xml文件，这个可以根据自己的需求来改需要回收的数据类型</span></span><br><span class="line">files=`find $&#123;local_url&#125; -mmin -50 -name &#x27;*.xml&#x27;`</span><br><span class="line">for file in $&#123;files&#125;</span><br><span class="line">do</span><br><span class="line">	echo $&#123;file&#125;</span><br><span class="line"><span class="meta">	#</span><span class="bash">建立ftp连接</span></span><br><span class="line">	lftp -u $&#123;user&#125;,$&#123;password&#125; sftp://$&#123;ip&#125;:$&#123;port&#125; &lt;&lt;EOF</span><br><span class="line">cd $&#123;server_url&#125;/</span><br><span class="line">lcd $&#123;local_url&#125;</span><br><span class="line">put $&#123;file&#125;</span><br><span class="line">by</span><br><span class="line">EOF</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>到这里，我以为就搞定了，开开心心发过去，看了看点，三踮几啦，饮茶先啦，点了杯奶茶。不出意外要出意外了，客户说他那边没lftp这个服务，问我能不能用SCP服务，他们之前用的SCP服务，到手的奶茶突然不香了，也行！不就是SCP嘛，开整！也就是改下服务的事情。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash">用户名</span></span><br><span class="line">user=</span><br><span class="line"><span class="meta">#</span><span class="bash">本地存在这个文件的目录</span></span><br><span class="line">local_url=/tmp</span><br><span class="line"><span class="meta">#</span><span class="bash">上传的目的目录</span></span><br><span class="line">server_url=/home</span><br><span class="line"><span class="meta">#</span><span class="bash">服务器IP</span></span><br><span class="line">ip=</span><br><span class="line"><span class="meta">#</span><span class="bash">端口</span></span><br><span class="line">port=22</span><br><span class="line"></span><br><span class="line">cd $&#123;local_url&#125;</span><br><span class="line">files=`find $&#123;local_url&#125; -mmin -50 -name &#x27;*.xml&#x27;`</span><br><span class="line">for file in $&#123;files&#125;</span><br><span class="line">do</span><br><span class="line">	echo $&#123;file&#125;</span><br><span class="line">	scp -P $&#123;port&#125; $&#123;file&#125; $&#123;user&#125;@$&#123;ip&#125;:$&#123;server_url&#125; &lt;&lt;EOF</span><br><span class="line">by</span><br><span class="line">EOF</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>这个的功能实现了，但是跟FTP不一样的是，FTP能够在命令中把密码加进去，而SCP需要自己输入密码。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lftp -u $&#123;user&#125;,$&#123;password&#125; sftp://$&#123;ip&#125;:$&#123;port&#125; &lt;&lt;EOF</span><br><span class="line"><span class="meta">#</span><span class="bash">账号密码在命令上</span></span><br><span class="line">scp -P $&#123;port&#125; $&#123;file&#125; $&#123;user&#125;@$&#123;ip&#125;:$&#123;server_url&#125; &lt;&lt;EOF</span><br><span class="line"><span class="meta">#</span><span class="bash">账号密码需要自己输入</span></span><br></pre></td></tr></table></figure>

<p>客户看到又有问题了，啊这，能不能让他自己输入密码啊，我这不支持输入密码。也行，用expect写个监测关键字就行了，我没想到就是因为我这句也行，让我头秃了两天。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/usr/bin/expect</span></span><br><span class="line"><span class="meta">#</span><span class="bash">ip=`ifconfig -a|grep inet|grep -v 127.0.0.1|grep -v inet6|awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span>|tr -d <span class="string">&quot;addr:&quot;</span>`</span></span><br><span class="line">spawn scp -P 22 /home/ax/a.xml 用户名@服务器IP:/tmp</span><br><span class="line">set timeout 20</span><br><span class="line"><span class="meta">#</span><span class="bash">监测下面的命令行中有没有password这个关键字</span></span><br><span class="line">expect &quot;password&quot;</span><br><span class="line">exec sleep 1</span><br><span class="line"><span class="meta">#</span><span class="bash">监测到了就发送密码</span></span><br><span class="line">send &quot;密码\r&quot;</span><br><span class="line">interact</span><br></pre></td></tr></table></figure>

<p>这个只是实现了一部分的功能，上面我说到，跑完主机之后的数据文件是带本机IP的，所以我们需要找到我们的本机IP，而关键点就在这，如果我要使用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ip=`ifconfig -a|grep inet|grep -v 127.0.0.1|grep -v inet6|awk &#x27;&#123;print $2&#125;&#x27;|tr -d &quot;addr:&quot;`</span><br></pre></td></tr></table></figure>

<p>这句命令来找IP的话，我需要用到bash解释器里面的东西，而我用expect是需要用到/usr/bin/expect这个解释器，而这两个是没办法直接引用到上面的，也就是一个shell脚本无法直接使用两个解释器。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/usr/bin/expect</span></span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br></pre></td></tr></table></figure>

<p>找了两天的解决办法，什么方式都尝试了一遍，文件包含，命令行传参啥的都尝试了，都没办法，我甚至午休躺在椅子上面睡觉还梦到有别的解决办法，然后惊醒，本来已经打算跟客户说让他用ftp那个的时候，我偶然看到一个代码块，里面有个词引起了我的注意，内嵌类型！！！！！！当时就感觉有戏，好像我找的方式就是他，让仔细查了下内嵌类型是个啥，果然！！！！我只需要把我需要用到解释器的部分代码内嵌到我另一个解释器的代码里面，就可以了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">local_ip=`ifconfig -a|grep inet|grep -v 127.0.0.1|grep -v inet6|awk &#x27;&#123;print $2&#125;&#x27;|tr -d &quot;addr:&quot;`</span><br><span class="line"><span class="meta">#</span><span class="bash">用户名</span></span><br><span class="line">user=</span><br><span class="line"><span class="meta">#</span><span class="bash">密码</span></span><br><span class="line">password=</span><br><span class="line"><span class="meta">#</span><span class="bash">本地存在这个文件的目录，格式例如/home/ax/</span></span><br><span class="line">local_url=</span><br><span class="line"><span class="meta">#</span><span class="bash">上传的目的目录,格式：/tmp</span></span><br><span class="line">server_url=</span><br><span class="line"><span class="meta">#</span><span class="bash">端口</span></span><br><span class="line">port=22</span><br><span class="line"><span class="meta">#</span><span class="bash">服务器IP</span></span><br><span class="line">server_ip=</span><br><span class="line"><span class="meta">#</span><span class="bash">这里一定要加&lt;&lt;<span class="string">EOF,才能将另一个解释器的代码内嵌到这里来</span></span></span><br><span class="line">/usr/bin/expect &lt;&lt;EOF</span><br><span class="line">spawn scp -P $&#123;port&#125; $&#123;local_url&#125;$&#123;local_ip&#125;_a.xml $&#123;user&#125;@$&#123;server_ip&#125;:$&#123;server_url&#125;</span><br><span class="line">set timeout 20</span><br><span class="line">expect &quot;password&quot;</span><br><span class="line">exec sleep 2</span><br><span class="line">send &quot;$&#123;password&#125;\r&quot;</span><br><span class="line">interact</span><br><span class="line">expect eof</span><br><span class="line">EOF</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string">结尾的时候要把EOF</span>给结束掉，也就是将上面的代码包进来</span></span><br></pre></td></tr></table></figure>

<p>这样直接把过滤文件的方式已经自动输入密码给完成了，其实如果想要实现那些自动上传脚本，执行这些也是能完成的，只要解决了两个解释器命令能够在同一个脚本里面执行，其他都很好解决，设计好逻辑思路就可以了，但是这个是属于被白嫖的服务，能少点需求就少点需求。</p>
]]></content>
      <categories>
        <category>安全开发</category>
      </categories>
      <tags>
        <tag>安全工具</tag>
      </tags>
  </entry>
  <entry>
    <title>关于开深信服VPN无法抓包</title>
    <url>/2022/02/17/%E5%85%B3%E4%BA%8E%E5%BC%80%E6%B7%B1%E4%BF%A1%E6%9C%8DVPN%E6%97%A0%E6%B3%95%E6%8A%93%E5%8C%85/</url>
    <content><![CDATA[<p>前些日子大佬叫去搞渗透，得走深信服的VPN，连上之后发现BP抓不了包了，关闭 BurpSuite 单独用浏览器就可以正常访问，还以为是我电脑问题，后面发现下了VPN之后能正常抓包了。</p>
<span id="more"></span>
<p><img src="https://ax-x.github.io/2022/02/17/%E5%85%B3%E4%BA%8E%E5%BC%80%E6%B7%B1%E4%BF%A1%E6%9C%8DVPN%E6%97%A0%E6%B3%95%E6%8A%93%E5%8C%85/image-20220217100454882.png" alt="image-20220217100454882"></p>
<p>一开始以为是走的VPN，多个代理抓不到，然后试着用BP搞个上层代理，结果还是不行，后门觉着应该是深信服VPN不允许抓包的问题，把流量先在自己电脑跑一圈，用一层中转即可，找了个EW，开了个 sock5 服务器进行本地转发，然后再进行抓包就可以了</p>
<p><img src="https://ax-x.github.io/2022/02/17/%E5%85%B3%E4%BA%8E%E5%BC%80%E6%B7%B1%E4%BF%A1%E6%9C%8DVPN%E6%97%A0%E6%B3%95%E6%8A%93%E5%8C%85/image-20220217101004315.png" alt="image-20220217101004315"></p>
<p>BP设置</p>
<p><img src="https://ax-x.github.io/2022/02/17/%E5%85%B3%E4%BA%8E%E5%BC%80%E6%B7%B1%E4%BF%A1%E6%9C%8DVPN%E6%97%A0%E6%B3%95%E6%8A%93%E5%8C%85/image-20220217101028945.png" alt="image-20220217101028945"></p>
<p><img src="https://ax-x.github.io/2022/02/17/%E5%85%B3%E4%BA%8E%E5%BC%80%E6%B7%B1%E4%BF%A1%E6%9C%8DVPN%E6%97%A0%E6%B3%95%E6%8A%93%E5%8C%85/image-20220217101050106.png" alt="image-20220217101050106"></p>
]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>常见端口攻击方式</title>
    <url>/2022/03/08/%E5%B8%B8%E8%A7%81%E7%AB%AF%E5%8F%A3%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="远程管理端口"><a href="#远程管理端口" class="headerlink" title="远程管理端口"></a>远程管理端口</h2><span id="more"></span>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">22  端口（ssh）</span><br><span class="line">    安全攻击：弱口令、暴力猜解、用户名枚举</span><br><span class="line">    利用方式：1、通过用户名枚举可以判断某个用户名是否存在于目标主机中，2、利用弱口令/暴力破解，获取目标主机权限。</span><br><span class="line">    </span><br><span class="line">23  端口（telnet）</span><br><span class="line">    安全漏洞：弱口令、明文传输</span><br><span class="line">    利用方式：1、通过弱口令或暴力破解，获取目标主机权限。2、嗅探抓取telnet明文账户密码。</span><br><span class="line">    </span><br><span class="line">3389 端口（RDP）</span><br><span class="line">     安全漏洞：暴力破解</span><br><span class="line">     利用方式：通过弱口令或暴力破解，获取目标主机权限。</span><br><span class="line"></span><br><span class="line">5632 端口（Pcanywhere）</span><br><span class="line">     安全漏洞：弱口令、暴力破解</span><br><span class="line">     利用方式：通过弱口令或暴力破解，获取目标主机权限</span><br><span class="line"></span><br><span class="line">5900 端口（VNC）</span><br><span class="line">     安全漏洞：弱口令、暴力破解</span><br><span class="line">     利用方式：通过弱口令或暴力破解，获取目标主机权限。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="WEB中间件-服务端口"><a href="#WEB中间件-服务端口" class="headerlink" title="WEB中间件/服务端口"></a>WEB中间件/服务端口</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1090/1099 端口（RMI）</span><br><span class="line">    安全漏洞：JAVA RMI 反序列化远程命令执行漏洞</span><br><span class="line">    利用方式：使用nmap检测端口信息。</span><br><span class="line">    端口信息：1099/1090    Java-rmi    Java RMI Registry</span><br><span class="line">    检测工具：attackRMI.jar</span><br><span class="line"></span><br><span class="line">7001 端口（Weblogic）</span><br><span class="line">    安全漏洞：弱口令、SSRF、反序列化漏洞</span><br><span class="line">    利用方式：1、控制台弱口令上传war木马2、SSRF内网探测3、反序列化远程代码执行等</span><br><span class="line"></span><br><span class="line">8000 端口（jdwp）</span><br><span class="line">    安全漏洞：JDWP 远程命令执行漏洞</span><br><span class="line">    端口信息：8000  jdwp     </span><br><span class="line">    java Debug Wire Protocol检测工具：https://github.com/IOActive/jdwp-shellifier</span><br><span class="line"></span><br><span class="line">8080 端口（Tomcat）</span><br><span class="line">    安全漏洞：弱口令、示例目录</span><br><span class="line">    利用方式：通过弱口令登录控制台，上传war包。</span><br><span class="line"></span><br><span class="line">8080 端口（Jboss）</span><br><span class="line">    安全漏洞：未授权访问、反序列化。</span><br><span class="line">    利用方式：1、未授权访问控制台，远程部署木马2、反序列化导致远程命令执行等。</span><br><span class="line">    检测工具：https://github.com/joaomatosf/jexboss</span><br><span class="line"></span><br><span class="line">8080 端口（Resin）</span><br><span class="line">    安全漏洞：目录遍历、远程文件读取</span><br><span class="line">    利用方式：通过目录遍历/远程文件读取获取敏感信息，为进一步攻击提供必要的信息。</span><br><span class="line">    任意文件读取POC：</span><br><span class="line">    payload1 = &quot;/resin-doc/resource/tutorial/jndi-appconfig/test?inputFile=/etc/passwd&quot;</span><br><span class="line">    payload2 = &quot;/resin-doc/examples/jndi-appconfig/test?inputFile=../../../../../../../../../../etc/passwd&quot;</span><br><span class="line">    payload3 = &quot;/ ..\\\\web-inf&quot;</span><br><span class="line"></span><br><span class="line">8080 端口（Jetty）</span><br><span class="line">    安全漏洞：远程共享缓冲区泄漏</span><br><span class="line">    利用方式：攻击者可以通过精心构造headers值来触发异常并偏移到共享缓冲区，其中包含了之前其他用户提交的请求，服务器会根据攻击者的payload返回特定位置的数据。</span><br><span class="line">    检测工具：https://github.com/GDSSecurity/Jetleak-Testing-Script</span><br><span class="line"></span><br><span class="line">8080 /4848 端口（GlassFish）</span><br><span class="line">    安全漏洞：弱口令、任意文件读取</span><br><span class="line">    利用方式：1、弱口令admin/admin，直接部署shell    2、任意文件读取获取服务器敏感配置信息</span><br><span class="line"></span><br><span class="line">8080 端口（Jenkins）</span><br><span class="line">    安全漏洞：未授权访问 、远程代码执行</span><br><span class="line">    利用方式：访问如下url，可以执行脚本命令，反弹shell，写入webshell等。</span><br><span class="line">    http://&lt;target&gt;:8080/manage</span><br><span class="line">    http://&lt;target&gt;:8080/script</span><br><span class="line"></span><br><span class="line">8161 端口（ActiveMQ）</span><br><span class="line">    安全漏洞：弱口令、任意文件写入、反序列化</span><br><span class="line">    利用方式：默认密码admin/admin登陆控制台、写入webshell、上传ssh key等方式。</span><br><span class="line"></span><br><span class="line">9043 端口（webSphere）</span><br><span class="line">    安全漏洞：控制台弱口令、远程代码执行</span><br><span class="line">    后台地址：https://:9043/ibm/console/logon.jsp</span><br><span class="line"></span><br><span class="line">50000 端口 （SAP）</span><br><span class="line">    安全漏洞：远程代码执行</span><br><span class="line">    利用方式：攻击者通过构造url请求，实现远程代码执行。POC:http://&lt;target&gt;:50000/ctc/servlet/com.sap.ctc.util.ConfigServlet?param=com.sap.ctc.util.FileSystemConfig;EXECUTE_CMD;CMDLINE=cmd.exe /c ipconfig /all</span><br><span class="line"></span><br><span class="line">50070 端口（hadoop）</span><br><span class="line">    安全漏洞：未授权访问</span><br><span class="line">    利用方式：攻击者可以通过命令行操作多个目录下的数据，如进行删除操作。</span><br><span class="line">    curl -i -X DELETE “http://ip:50070/webhdfs/v1/tmp?op=DELETE&amp;recursive=true“</span><br><span class="line">    curl -i -X PUT “http://ip:50070/webhdfs/v1/NODATA4U_SECUREYOURSHIT?op=MKDIRS“</span><br></pre></td></tr></table></figure>

<h2 id="数据库端口"><a href="#数据库端口" class="headerlink" title="数据库端口"></a>数据库端口</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">389 端口（ldap）</span><br><span class="line">    安全漏洞：未授权访问 、弱口令</span><br><span class="line">    利用方式：通过LdapBrowser工具直接连入。</span><br><span class="line"></span><br><span class="line">1433 端口（Mssql）</span><br><span class="line">    安全漏洞：弱口令、暴力破解</span><br><span class="line">    利用方式：差异备份getshell、SA账户提权等</span><br><span class="line"></span><br><span class="line">1521 端口（Oracle）</span><br><span class="line">    安全漏洞：弱口令、暴力破解</span><br><span class="line">    利用方式：通过弱口令/暴力破解进行入侵。</span><br><span class="line"></span><br><span class="line">3306 端口（MySQL）</span><br><span class="line">    安全漏洞：弱口令、暴力破解</span><br><span class="line">    利用方式：利用日志写入webshell、udf提权、mof提权等。</span><br><span class="line"></span><br><span class="line">5432 端口（ PostgreSQL）</span><br><span class="line">    安全漏洞：弱口令、高权限命令执行</span><br><span class="line">    利用方式：攻击者通过弱口令获取账号信息，连入postgres中，可执行系统命令。。</span><br><span class="line">    PoC参考：    DROP TABLE IF EXISTS cmd_exec;    CREATE TABLE cmd_exec(cmd_output text);    COPY cmd_exec FROM PROGRAM &#x27;id&#x27;;    SELECT * FROM cmd_exec;</span><br><span class="line"></span><br><span class="line">5984 端口（CouchDB）</span><br><span class="line">    安全漏洞：垂直权限绕过、任意命令执行</span><br><span class="line">    利用方式：通过构造数据创建管理员用户，使用管理员用户登录，构造恶意请求触发任意命令执行。</span><br><span class="line">    后台访问：http://&lt;target&gt;:5984/_utils</span><br><span class="line"></span><br><span class="line">6379 端口（Redis）</span><br><span class="line">    安全漏洞：未授权访问</span><br><span class="line">    利用方式：绝对路径写webshell 、利用计划任务执行命令反弹shell、公私钥认证获取root权限、主从复制RCE等。</span><br><span class="line"></span><br><span class="line">9200 端口（elasticsearch）</span><br><span class="line">    安全漏洞：未授权访问、命令执行</span><br><span class="line">    检测方式：</span><br><span class="line">        1、直接访问如下url，获取相关敏感信息。  http://&lt;target&gt;:9200/_nodes  查看节点数据  http://&lt;target&gt;:9200/_river  查看数据库敏感信息</span><br><span class="line">        2、通过构造特定的数据包，执行任意命令。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">11211 端口（MemCache）</span><br><span class="line">    安全漏洞：未授权访问</span><br><span class="line">    检测方式：无需用户名密码，可以直接连接memcache 服务的11211端口。nc -vv &lt;target&gt; 11211</span><br><span class="line"></span><br><span class="line">27017 端口（Mongodb）</span><br><span class="line">    安全漏洞：未授权访问、弱口令</span><br><span class="line">    利用方式：未授权访问/弱口令，远程连入数据库，导致敏感信息泄露。</span><br></pre></td></tr></table></figure>

<h2 id="常见协议"><a href="#常见协议" class="headerlink" title="常见协议"></a>常见协议</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">21 端口（FTP)</span><br><span class="line">    安全漏洞：1、配置不当    2、明文传输    3、第三方软件提权</span><br><span class="line">    利用方式：1、匿名登录或弱口令2、嗅探ftp用户名和密码3、</span><br><span class="line">    Serv-U权限较大的账号可导致系统命令执行。</span><br><span class="line">    FTP提权命令：  # 增加系统用户   Quote site exec net user 4567 4567 /add  # 提升到管理员权限   Quote site exec net localgroup administrators 4567 /add</span><br><span class="line"></span><br><span class="line">25 端口（SMTP）</span><br><span class="line">    攻击方式：1、匿名发送邮件 2、弱口令 3、SMTP用户枚举</span><br><span class="line">    利用方式：1、SMTP服务器配置不当，攻击者可以使用任意用户发送邮件。2、SMTP弱口令扫描，获取用户账号密码，发送邮件钓鱼。3、通过SMTP用户枚举获取用户名：   nmap -p 25 -- smtp-enum-users.nse &lt;target&gt;</span><br><span class="line"></span><br><span class="line">53 端口（DNS）</span><br><span class="line">    安全攻击：1、DNS域传送漏洞、DNS欺骗、DNS缓存投毒</span><br><span class="line">    检测方式：1、DNS域传送漏洞，Windows下检测使用nslookup命令，Linux下检测使用dig命令，通过执行命令可以清楚的看到域名解析情况。2、DNS欺骗就是攻击者冒充域名服务器的一种欺骗行为。3、DNS缓存投毒是攻击者欺骗DNS服务器相信伪造的DNS响应的真实性。</span><br><span class="line"></span><br><span class="line">161 端口（SNMP）</span><br><span class="line">    安全漏洞：默认团体名/弱口令访问</span><br><span class="line">    利用方式：通过nmap自带的审计脚本进行检测，可能导致敏感信息泄露。。1、弱口令检测：nmap –sU –p161 –script=snmp-brute &lt;target&gt;2、获取系统信息：nmap –sU –p161 –script=snmp-sysdescr &lt;target&gt;3、获取用户信息：nmap -sU -p161 --script=snmp-win32-user &lt;target&gt;4、获取网络端口状态：nmap -sU -p161 --script=snmp-netstat &lt;target&gt;</span><br><span class="line"></span><br><span class="line">443 端口（SSL）</span><br><span class="line">    安全漏洞：OpenSSL 心脏出血</span><br><span class="line">    利用方式：攻击者可以远程读取存在漏洞版本的openssl服务器内存中长大64K的数据。</span><br><span class="line">    扫描脚本：nmap -sV --script=ssl-heartbleed &lt;target&gt;</span><br><span class="line"></span><br><span class="line">445 端口（SMB）</span><br><span class="line">    安全漏洞：信息泄露、远程代码执行</span><br><span class="line">    利用方式：可利用共享获取敏感信息、缓冲区溢出导致远程代码执行，如ms17010。</span><br><span class="line"></span><br><span class="line">873 端口（Rsync）</span><br><span class="line">    安全漏洞：匿名访问、弱口令</span><br><span class="line">    利用方式：攻击者可以执行下载/上传等操作，也可以尝试上传webshell。</span><br><span class="line">    1、下载：#rsync -avz a.b.c.d::path/file path/filiname  </span><br><span class="line">    2、上传：#rsync -avz path/filename a.b.c.d::path/file</span><br><span class="line"></span><br><span class="line">2181 端口（Zookeeper）</span><br><span class="line">    安全漏洞：未授权访问</span><br><span class="line">    检测方式：攻击者可通过执行envi命令获得系统大量的敏感信息，包括系统名称、Java环境。 echo envi | nc ip port</span><br><span class="line"></span><br><span class="line">2375 端口（Docker）</span><br><span class="line">    安全漏洞：未授权方式</span><br><span class="line">    检测方式：通过docker daemon api 执行docker命令。#列出容器信息，效果与docker ps -a 一致。 curl http://&lt;target&gt;:2375/containers/json docker -H tcp://&lt;target&gt;:2375 start &lt;Container Id&gt;  docker服务如果是以root用户启动的话，可以利用chroot将服务器的根目录挂在到容器里面，实现docker容器逃逸</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>常规绕WAF思路</title>
    <url>/2022/03/08/%E5%B8%B8%E8%A7%84%E7%BB%95WAF%E6%80%9D%E8%B7%AF/</url>
    <content><![CDATA[<h2 id="1、错误的HTTP请求头"><a href="#1、错误的HTTP请求头" class="headerlink" title="1、错误的HTTP请求头"></a>1、错误的HTTP请求头</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">类似文件上传时的绕过，通过畸形的HTTP协议头绕过WAF检测。比如绕过某些老版本WAF可以加入请求头：<span class="attribute">Content</span>-Encoding:deflate就可以绕过WAF（此方法在文件上传绕过WAF中也适用）</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="2、通用的关键字绕过"><a href="#2、通用的关键字绕过" class="headerlink" title="2、通用的关键字绕过"></a>2、通用的关键字绕过</h2><figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line">将关键字转换成Unicode或者<span class="built_in">HEX</span>编码的方式，JAVA程序会自动进行解码，所以在一定程度上能够绕过WAF</span><br></pre></td></tr></table></figure>

<h2 id="3、使用未公开的漏洞利用链"><a href="#3、使用未公开的漏洞利用链" class="headerlink" title="3、使用未公开的漏洞利用链"></a>3、使用未公开的漏洞利用链</h2><figure class="highlight"><table><tr><td class="code"><pre><span class="line">部分WAF会将公开的漏洞利用链中的关键字设置为黑名单，所以重新找一条利用链吧，自己的才是最香的</span><br></pre></td></tr></table></figure>

<h2 id="4、数据溢出-防匹配（xxx…）"><a href="#4、数据溢出-防匹配（xxx…）" class="headerlink" title="4、数据溢出-防匹配（xxx…）"></a>4、数据溢出-防匹配（xxx…）</h2><figure class="highlight"><table><tr><td class="code"><pre><span class="line">借助常见的溢出漏洞，在数据特别多的情况下例如：构造垃圾数据，让防护的检测负载不过来在某个地方停止，从而达到绕过的目的例如在数据包内（文件名等可修改的区域）处构造大量垃圾数据，但是有可能会导致服务器崩溃，从而无法接下去进行操作</span><br></pre></td></tr></table></figure>

<h2 id="5、符号变异-防匹配（’”-）"><a href="#5、符号变异-防匹配（’”-）" class="headerlink" title="5、符号变异-防匹配（’”;）"></a>5、符号变异-防匹配（’”;）</h2><figure class="highlight brainfuck"><table><tr><td class="code"><pre><span class="line"><span class="comment">利用匹配的原则，猜测waf是根据在单引号或者双引号里面的数据去匹配文件名信息的，那么可以利用这个规则，将引号替换掉，尝试绕过，有可能它只检测单引号或者只检测双引号，也可尝试去掉一个引号，有开始就有结束，当去掉一个之后就可能被检测出来，或者没检测出来，或者什么都没发生这样，也可尝试将引号全部去除，而分号是利用分号后面还有数据的形式，在后面添加垃圾数据去尝试绕过</span><span class="string">,</span><span class="comment">或者构造文件名或者在引号后面写文件名，而引号内部不去写数据，或者单纯写一个a这样的数据尝试绕过</span></span><br></pre></td></tr></table></figure>

<h2 id="6、重复数据-防匹配（参数多次）"><a href="#6、重复数据-防匹配（参数多次）" class="headerlink" title="6、重复数据-防匹配（参数多次）"></a>6、重复数据-防匹配（参数多次）</h2><figure class="highlight sas"><table><tr><td class="code"><pre><span class="line">例如：构造多个<span class="meta">filename</span>，然后查看waf最后是以哪个为主，然后构造多个<span class="meta">filename</span>，借助检测机制是递归循环，还是单次检测，类似于构造垃圾数据那样也可尝试将Content-Disposition这些的数据插入到<span class="meta">filename</span>里面去，然后后面构造php文件（利用白名单）</span><br></pre></td></tr></table></figure>

<h2 id="7、数据截断-防匹配（-00-换行）"><a href="#7、数据截断-防匹配（-00-换行）" class="headerlink" title="7、数据截断-防匹配（%00;/;换行）"></a>7、数据截断-防匹配（%00;/;换行）</h2>]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法</title>
    <url>/2022/03/25/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<ol>
<li>直接插入排序，将一个记录插入到已排序好的有序表中，从而得到一个新，记录数增1的有序表。即：先将序列的第1个记录看成是一个<strong>有序的子序列</strong>，然后从第2个记录逐个进行插入，直至<strong>整个序列</strong>有序为止。<span id="more"></span></li>
<li>希尔排序，先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序</li>
<li>简单选择排序，在要排序的一组数中，选出最小（或者最大）的一个数与第1个位置的数交换；然后在剩下的数当中再找最小（或者最大）的与第2个位置的数交换，依次类推，直到第n-1个元素（倒数第二个数）和第n个元素（最后一个数）比较为止。</li>
<li>堆排序，由堆的定义可以看出，<strong>堆顶元素</strong>（即第一个元素）必为最小项（小顶堆）。<br>若以一维数组存储一个堆，则堆对应一棵完全二叉树，且所有非叶结点的值均不大于(或不小于)其子女的值，根结点（堆顶元素）的值是最小(或最大)的</li>
<li>冒泡排序，在要排序的一组数中，对当前还未排好序的范围内的全部数，自上而下对相邻的两个数依次进行比较和调整，让较大的数往下沉，较小的往上冒。即：每当两相邻的数比较后发现它们的排序与排序要求相反时，就将它们互换。</li>
<li>快速排序</li>
<li>1）选择一个基准元素,通常选择第一个元素或者最后一个元素,</li>
<li>2）通过一趟排序将待排序的记录分割成独立的两部分，其中一部分记录的元素值均比基准元素值小。另一部分记录的 元素值比基准值大。</li>
<li>3）此时基准元素在其排好序后的正确位置</li>
<li>4）然后分别对这两部分记录用同样的方法继续进行排序，直到整个序列有序。</li>
<li>归并排序</li>
<li>归并（Merge）排序法是将两个（或两个以上）有序表合并成一个新的有序表，即把待排序序列分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列。</li>
<li>基数排序</li>
<li>是将阵列分到有限数量的桶子里。每个桶子再个别排序（有可能再使用别的排序算法或是以递回方式继续使用桶排序进行排序）。桶排序是鸽巢排序的一种归纳结果。当要被排序的阵列内的数值是均匀分配的时候，桶排序使用线性时间（Θ（n））。但桶排序并不是 比较排序，他不受到 O(n log n) 下限的影响。</li>
</ol>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>文件上传漏洞个人总结</title>
    <url>/2022/03/08/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="什么是文件上传"><a href="#什么是文件上传" class="headerlink" title="什么是文件上传"></a>什么是文件上传</h2><p>文件上传漏洞是指上传文件的时，如果未对上传的文件进行严格的验证和过滤，就容易造成文件上传漏洞，上传脚本等。用户可以上传了一个可执行的脚本文件，并通过此脚本文件获得了执行服务器端命令的能力。 常见场景是web服务器允许用户上传图片或者普通文本文件保存，而用户绕过上传机制上传恶意代码并执行从而控制服务器。这种漏洞是getshell最快最直接的方法之一，上传文件操作本身是没有问题的，问题在于文件上传到服务器后，服务器怎么处理和解释文件，有文件上传不一定有文件上传漏洞，要看代码情况。</p>
<span id="more"></span>
<h2 id="文件上传危害"><a href="#文件上传危害" class="headerlink" title="文件上传危害"></a>文件上传危害</h2><figure class="highlight"><table><tr><td class="code"><pre><span class="line">自定义上传什么东西，通过文件上传上传网站后门，拿到网站权限，高危漏洞</span><br></pre></td></tr></table></figure>

<h2 id="如何查找"><a href="#如何查找" class="headerlink" title="如何查找"></a>如何查找</h2><figure class="highlight"><table><tr><td class="code"><pre><span class="line">黑盒查找：代码，网站情况是不知道的需要自己判断，需要用扫描器去扫描敏感文件，扫描常见的上传地址，通过网站给出的上传应用或者后台去找。</span><br><span class="line">白盒查找：拿到源码，cms等等判断</span><br><span class="line">通过抓包修改数据进行判断</span><br></pre></td></tr></table></figure>

<h2 id="文件上传常见验证方式"><a href="#文件上传常见验证方式" class="headerlink" title="文件上传常见验证方式"></a>文件上传常见验证方式</h2><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">后缀名：类型，文件头等</span><br><span class="line">文件头，MIME信息，image/gif，后缀</span><br><span class="line"><span class="section">黑名单:明确不让上传的格式后缀（黑名单缺陷：定义后缀名不完整的情况，可以通过其他格式绕过达到同样的效果，具体情况具体看待）asp php jsp aspx cgi war</span></span><br><span class="line">黑名单缺陷：php5，phtml（例如PHP：如果对方支持这个类型的格式的话是可以运行的）</span><br><span class="line"><span class="section">白名单:明确可以上传的格式后缀（白名单相对黑名单要安全点）Jpg png zip rar gif</span></span><br><span class="line"><span class="section">文件类型:MIME信息image/gif</span></span><br></pre></td></tr></table></figure>

<h2 id="常见绕过方式"><a href="#常见绕过方式" class="headerlink" title="常见绕过方式"></a>常见绕过方式</h2><figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line">JS验证绕过</span><br><span class="line">特殊解析后缀（php3，php5，phtml），.htaccess（apache）</span><br><span class="line">大小写</span><br><span class="line">点绕过</span><br><span class="line">空格绕过</span><br><span class="line">::<span class="variable">$$</span>DATA</span><br><span class="line">双后缀名绕过</span><br><span class="line">MIME绕过</span><br><span class="line">截断</span><br><span class="line">文件头检测</span><br><span class="line">二次渲染</span><br><span class="line">条件竞争</span><br><span class="line">突破getimagesize</span><br><span class="line">突破exif_imagetype</span><br></pre></td></tr></table></figure>

<h2 id="上传参数名解析-明确哪些东西能修改？"><a href="#上传参数名解析-明确哪些东西能修改？" class="headerlink" title="上传参数名解析:明确哪些东西能修改？"></a>上传参数名解析:明确哪些东西能修改？</h2><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Content-Disposition-</span>:一般可更改</span><br><span class="line"><span class="attribute">name</span>:表单参数值，不能更改</span><br><span class="line"><span class="attribute">filename</span>:文件名，可以更改</span><br><span class="line"><span class="attribute">Content-type</span>:文件</span><br><span class="line">MIME，视情况更改</span><br></pre></td></tr></table></figure>

<h2 id="文件上传安全修复方案"><a href="#文件上传安全修复方案" class="headerlink" title="文件上传安全修复方案"></a>文件上传安全修复方案</h2><figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">后端验证：采用服务端验证模式</span><br><span class="line">后缀检测：基于黑名单，白名单过滤</span><br><span class="line">MIME检测：基于上传自带类型检测</span><br><span class="line">内容检测：文件头，完整性检测,后缀等等</span><br><span class="line">自带函数过滤：参考 uploadlabs函数</span><br><span class="line">自定义函数过滤：<span class="keyword">function</span> <span class="title">check_file</span>()</span><br><span class="line">WAF防护产品：安全狗，宝塔，云盾，安全公司类似产品等</span><br></pre></td></tr></table></figure>

<h2 id="解析漏洞"><a href="#解析漏洞" class="headerlink" title="解析漏洞"></a>解析漏洞</h2><h3 id="IIS6-0解析漏洞"><a href="#IIS6-0解析漏洞" class="headerlink" title="IIS6.0解析漏洞"></a>IIS6.0解析漏洞</h3><figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line">建立\*.asa,\*.asp文件夹时，文件夹下的任意文件都会被当成asp文件来执行</span><br><span class="line">\*.asp;1.jpg同样会被当成asp脚本执行</span><br></pre></td></tr></table></figure>

<h3 id="IIS-7-0-7-5"><a href="#IIS-7-0-7-5" class="headerlink" title="IIS 7.0/7.5"></a>IIS 7.0/7.5</h3><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">默认Fast-CGI开启，直接在url中图片地址后面输入<span class="string">/1.php</span>，会把正常图片当成php解析</span><br></pre></td></tr></table></figure>

<h3 id="Apache解析漏洞"><a href="#Apache解析漏洞" class="headerlink" title="Apache解析漏洞"></a>Apache解析漏洞</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">当文件拓展名Apache没有配置解析器解析时，就会向前遍历，直到遇到配置的解析器解析的域名</span><br></pre></td></tr></table></figure>

<h3 id="nginx解析漏洞"><a href="#nginx解析漏洞" class="headerlink" title="nginx解析漏洞"></a>nginx解析漏洞</h3><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">上传<span class="string">/.php</span>时就能作为php文件解析</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>文件下载漏洞个人总结</title>
    <url>/2022/03/08/%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E6%BC%8F%E6%B4%9E%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>文件下载功能没有对下载的文件类型、目录做合理严谨的过滤， 利用路径回溯符…/跳出程序本身的限制目录实现来下载任意文件，导致用户可以下载服务器的任意文件。</p>
<span id="more"></span>
<h2 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h2><figure class="highlight"><table><tr><td class="code"><pre><span class="line">存在读文件的函数</span><br><span class="line">读取文件的路径用户可控且未校验或校验不严</span><br><span class="line">输出了文件内容</span><br></pre></td></tr></table></figure>

<h2 id="漏洞危害"><a href="#漏洞危害" class="headerlink" title="漏洞危害"></a>漏洞危害</h2><figure class="highlight"><table><tr><td class="code"><pre><span class="line">可以下载服务器的任意文件，web业务的代码，服务器和系统的具体配置信息，也可以下载数据库的配置信息，以及对内网的信息探测等等。</span><br><span class="line">可用得到的代码进一步代码审计，得到更多可利用漏洞</span><br><span class="line">任意文件下载漏洞的利用主要是为了信息收集，我们通过对服务器配置文件的下载，获取到大量的配置信息、源码，从而根据获取的信息来进一步挖掘服务器漏洞从而入侵。</span><br></pre></td></tr></table></figure>

<h2 id="如何发现"><a href="#如何发现" class="headerlink" title="如何发现"></a>如何发现</h2><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">网站URL中存在下载参数，并且未进行过滤…<span class="regexp">/…/</span>…/字符，且输出了文件内容</span><br><span class="line">从链接上看</span><br><span class="line">从参数上看</span><br><span class="line">具体情况具体分析</span><br></pre></td></tr></table></figure>

<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><figure class="highlight clean"><table><tr><td class="code"><pre><span class="line">获得站点源码（黑盒 -&gt; 白盒）</span><br><span class="line">获得站点与中间件配置文件</span><br><span class="line">获得应用于系统配置文件（ssh、mysql）</span><br></pre></td></tr></table></figure>

<h2 id="利用原理"><a href="#利用原理" class="headerlink" title="利用原理"></a>利用原理</h2><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">（信息收集信息&gt;猜路径 &gt;&gt;下载配置文件/代码文件 &gt;&gt; 利用服务器软件漏洞&gt; <span class="built_in">shell</span>&gt; 提权）</span><br><span class="line">任意文件下载漏洞的利用主要是为了信息收集，我们通过对服务器配置文件的下载，获取到大量的配置信息、源码，从而根据获取的信息来进一步挖掘服务器漏洞从而入侵。</span><br><span class="line">下载常规的配置文件，例如: ssh,weblogic,<span class="keyword">ftp</span>,mysql等相关配置下载各种.<span class="built_in">log</span>文件，从中寻找一些后台地址，文件上传点之类的地方，如果运气好的话会获得一些前辈们的后门。</span><br><span class="line">下载web业务文件进行白盒审计，利用漏洞进一步攻入服务器</span><br></pre></td></tr></table></figure>

<h2 id="常规文件位置"><a href="#常规文件位置" class="headerlink" title="常规文件位置"></a>常规文件位置</h2><p><strong>WEB应用</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">PHP</span></span><br><span class="line">1、获取inc/config·php获得数据库连接字符串中的口令信息。</span><br><span class="line"><span class="meta">#</span><span class="bash">asp</span></span><br><span class="line">1、获取inc/conn.asp文件，获得数据库连接字符串，得到数据库口令。若是ACCESS数据库，可以得到数据库</span><br><span class="line">路径，在下载数据库内容。</span><br><span class="line"><span class="meta">#</span><span class="bash">aspx</span></span><br><span class="line">1、获取网站根目录web，config文件，获得数据库连接字符串中的口令信息。</span><br><span class="line">2、获取bin/*.dll文件，获取网站源码（不完整代码）。使用.NET refl ector工具打开编译后的dll文件。</span><br><span class="line"><span class="meta">#</span><span class="bash">JSP</span></span><br><span class="line">1、获取conf/tomcat-user.xml文件，获得tomcat管理界面的口令信息，上传war包GetShel1，</span><br><span class="line">2、获取WEB-INF/Web.xml文件，获得数据库连接字符串中的口令信息。</span><br></pre></td></tr></table></figure>

<p><strong>应用，系统配置文件</strong></p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">一、Windows</span><br><span class="line">C:\boot.ini<span class="regexp">//</span>查看系统版本C:\Windows\System32\inetsrv\MetaBase.xml<span class="regexp">//</span>IIS配置文件</span><br><span class="line">C:\Windows\repair\sam<span class="regexp">//</span>存储系统初次安装的密码</span><br><span class="line">C:\Program Files\mysql\my.ini<span class="regexp">//</span>Mysql配置</span><br><span class="line">C:\Program Files\mysql\data\mysql\user.MYD <span class="regexp">//</span>Mysql root</span><br><span class="line">C:\Windows\php.ini<span class="regexp">//</span>php配置信息</span><br><span class="line">C:\Windows\my.ini<span class="regexp">//</span>Mysql配置信息</span><br><span class="line">C:\Windows\win.ini<span class="regexp">//</span>Windows系统的一个基本系统配置文件</span><br><span class="line">二、Linux</span><br><span class="line"><span class="regexp">/root/</span>.ssh/authorized_keys</span><br><span class="line"><span class="regexp">/root/</span>.ssh/id_rsa</span><br><span class="line"><span class="regexp">/root/</span>.ssh/id_ras.keystore</span><br><span class="line"><span class="regexp">/root/</span>.ssh<span class="regexp">/known_hosts/</span><span class="regexp">/记录每个访问计算机用户的公钥/</span>etc/passwd</span><br><span class="line"><span class="regexp">/etc/</span>shadow</span><br><span class="line"><span class="regexp">/etc/my</span>.cnf<span class="regexp">//my</span>sql配置文件</span><br><span class="line"><span class="regexp">/etc/</span>httpd<span class="regexp">/conf/</span>httpd.conf<span class="regexp">//</span>apachel配置文件</span><br><span class="line"><span class="regexp">/root/</span>.bash_history<span class="regexp">//</span>用户历史命令记录文件</span><br><span class="line"><span class="regexp">/root/</span>.mysql._history<span class="regexp">//my</span>sql历史命令记录文件</span><br></pre></td></tr></table></figure>

<h2 id="任意文件下载漏洞防御"><a href="#任意文件下载漏洞防御" class="headerlink" title="任意文件下载漏洞防御"></a>任意文件下载漏洞防御</h2><figure class="highlight less"><table><tr><td class="code"><pre><span class="line">下载路径不可控，而是程序自动生成后保存在数据库中，根据<span class="selector-tag">ID</span>进行下载</span><br><span class="line">对参数做严格的过滤，不能进行目录遍历（穿越）</span><br><span class="line">对下载路径进行过滤，如下载前对传入的参数进行过滤，并且对下载文件类型进行检查，是否是允许下载的类型</span><br><span class="line">过滤.(点)，使用户在<span class="selector-tag">url</span>中不能回溯上级目录</span><br><span class="line">正则严格判断用户输入参数的格式</span><br><span class="line">限定文件访问范围如<span class="selector-tag">PHP</span>里的（<span class="selector-tag">php</span><span class="selector-class">.ini</span>配置<span class="selector-tag">open_basedir</span>）</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次windows应急响应</title>
    <url>/2022/04/24/%E8%AE%B0%E4%B8%80%E6%AC%A1windows%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/</url>
    <content><![CDATA[<h1 id="1、背景"><a href="#1、背景" class="headerlink" title="1、背景"></a>1、背景</h1><p>大好假期，人在家中躺，应急天上来，上了机子之后过程还算是比较顺利的，环境是Tomcat，大致思路就是，排查可疑用户和文件，看日志，连接情况，进程，定时任务，注册表这些。</p>
<span id="more"></span>
<h1 id="2、排查可疑用户和文件"><a href="#2、排查可疑用户和文件" class="headerlink" title="2、排查可疑用户和文件"></a>2、排查可疑用户和文件</h1><p>先排查下有没有隐藏的用户</p>
<p><img src="https://ax-x.github.io/2022/04/24/%E8%AE%B0%E4%B8%80%E6%AC%A1windows%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/image-20220404011544732.png" alt="image-20220404011544732"></p>
<p>用了net user和net user localgroup administrators都没办法看到，但是还是有可能存在隐藏用户，隐藏用户有三种方式：</p>
<table>
<thead>
<tr>
<th>方式</th>
<th>特定</th>
</tr>
</thead>
<tbody><tr>
<td>命令添加</td>
<td>net user没办法查看隐藏用户<br>RDP登录过的，都会生成对应的用户目录<br>系统登录界面可以选择登录用户</td>
</tr>
<tr>
<td>克隆账号</td>
<td>net user无法查看隐藏用户<br>RDP登录不会生成相应的用户目录<br>系统登录界面选择登录用户，无法查看</td>
</tr>
<tr>
<td>Guest账号利用</td>
<td>正常都能够查看出来，但是一般会被忽略，隐蔽性相对来说会高点</td>
</tr>
</tbody></table>
<p>建议开个PCHunter看下，一般都能查出来，看出来这边是存在一个test$的隐藏用户，用net user XXX$验证下</p>
<p><img src="https://ax-x.github.io/2022/04/24/%E8%AE%B0%E4%B8%80%E6%AC%A1windows%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/image-20220404021642321.png" alt="image-20220404021642321"></p>
<p><img src="https://ax-x.github.io/2022/04/24/%E8%AE%B0%E4%B8%80%E6%AC%A1windows%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/image-20220404022054841.png" alt="image-20220404022054841"></p>
<p>接着看下有没有可疑的文件在，先排查web的目录，后面再去看看系统有没有被放了CS马啥的，因为是部署的tomcat，一般站点文件都会部署在tomcat\webapps下面，先按照修改时间排序下，发现了两个不像好人的文件，打开代码一看，一个是webshell，一个是代理</p>
<p><img src="https://ax-x.github.io/2022/04/24/%E8%AE%B0%E4%B8%80%E6%AC%A1windows%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/image-20220404023530823.png" alt="image-20220404023530823"></p>
<p>这次是运气好，直接用时间排序查出来的文件，在找webshell和代理的时候，根据日志的访问记录和文件修改时间去查找效果会更好一点，日志能看到攻击者一直在访问那个文件，这样在定位webshell的时候会更加有目标一点，或者使用D盾扫描，也能扫描出webshell。</p>
<p><img src="https://ax-x.github.io/2022/04/24/%E8%AE%B0%E4%B8%80%E6%AC%A1windows%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/image-20220404125014083.png" alt="image-20220404125014083"></p>
<h1 id="3、定位机器失陷时间"><a href="#3、定位机器失陷时间" class="headerlink" title="3、定位机器失陷时间"></a>3、定位机器失陷时间</h1><p>有挺多种方法去定位的，看系统安全日志或者中间件的日志等等，这边我先去看的tomcat的日志，tomcat的日志分五种：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1. 应用日志</span><br><span class="line">该日志主要是记录应用事件的，针对应用级别的排错比较有用，比如应用性能比较慢。</span><br><span class="line">2. 服务器日志</span><br><span class="line">服务器日志和console日志是相同的，不同之处在于，服务器日志是保存在文件中的，可以随时查看。</span><br><span class="line">3. 控制台日志</span><br><span class="line">该日志记录了tomcat的启动和加载器的顺序的详细信息，该日志文件叫做catalina.out。在排查服务器启动、应用的部署错时比较有用。 配置日志是在catalina.sh中配置的。</span><br><span class="line">4. 访问日志</span><br><span class="line">该日志也非常重要，在分析很多应用的流量，带宽需求，及负载时非常有用。该日志是在server.xml中配置的。</span><br><span class="line">5. Host manager</span><br><span class="line">使用Tomcat Manager执行的活动日志，比如不同的任务执行，应用的状态，应用的部署，和tomcat的生命周期，这些配置是在logging.properties.</span><br></pre></td></tr></table></figure>

<p>如果是因为站点有漏洞被传了马上去，可以看下localhost_access_log这个日志，这个是访问tomcat的日志，请求时间和资源，状态码都有记录，在日志量大的情况下可以自己去定义下，筛选文件和状态码，先把200的状态码筛选出来，然后再根据上面定位到的webshell去搜索日志信息。所以我第一时间先去找webshell，就是方便现在去定位大概攻击成功的时间和文件。</p>
<p><img src="https://ax-x.github.io/2022/04/24/%E8%AE%B0%E4%B8%80%E6%AC%A1windows%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/image-20220404131319354.png" alt="image-20220404131319354"></p>
<h1 id="4、计划任务-amp-注册表"><a href="#4、计划任务-amp-注册表" class="headerlink" title="4、计划任务&amp;注册表"></a>4、计划任务&amp;注册表</h1><p>计划任务的查看有很多种方式</p>
<table>
<thead>
<tr>
<th>方式</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>at（适用于win2003-win2008）</td>
<td>包含大量系统计划任务，不容易排查</td>
</tr>
<tr>
<td>schtasks.exe（win2008及其以后系统）</td>
<td>包含大量系统计划任务，不容易排查</td>
</tr>
<tr>
<td>控制面板-&gt;计划任务</td>
<td>包含大量系统计划任务，不容易排查</td>
</tr>
</tbody></table>
<p>单独看一个地方的话，会参杂大量的计划任务，干扰检查，最好就是多个搭配起来，配合计划任务的文件去检查，通过查看目录修改日期-&gt;文件修改日期，根据这两个信息，去计划任务程序里面定位，然后再查看具体内容，这就是为什么要去定位攻击成功的时间了，能有效帮助我们去排查计划任务的创建时间。</p>
<p><img src="https://ax-x.github.io/2022/04/24/%E8%AE%B0%E4%B8%80%E6%AC%A1windows%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/image-20220404135302797.png" alt="image-20220404135302797"></p>
<p>打开代码看下，在最下面发现的启动的文件路径</p>
<p><img src="https://ax-x.github.io/2022/04/24/%E8%AE%B0%E4%B8%80%E6%AC%A1windows%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/image-20220404135655403.png" alt="image-20220404135655403"></p>
<p>打开这个EXE，查看代码，在最下面看到了IP，是个阿里云的服务器，丢云沙箱一看，是个CS马。</p>
<p><img src="https://ax-x.github.io/2022/04/24/%E8%AE%B0%E4%B8%80%E6%AC%A1windows%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/image-20220404141147090.png" alt="image-20220404141147090"></p>
<p>当然我这种是比较笨的方式，这种可以直接丢云沙箱上面看下结果或者配合CurrPorts去分析，打开这个exe之后观察变化，或者看CurrPorts的log文件，也能够分析出这个IP，只是习惯先编辑一下，看看里面拿到内容，一般拉到最后面都能看到一些东西，找到CS马之后，去看windows自启动的注册表定位起来也会方便点，重点查看windows的自启动配置的注册表。</p>
<p><img src="https://ax-x.github.io/2022/04/24/%E8%AE%B0%E4%B8%80%E6%AC%A1windows%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/image-20220404142723461.png" alt="image-20220404142723461"></p>
<h1 id="5、总结"><a href="#5、总结" class="headerlink" title="5、总结"></a>5、总结</h1><p>这次的检查算是比较简单的，没有特别难找的东西，有一些是直接找出来的，没有啥特别的技巧，多排查几个机子，就有种直觉，感觉有点问题。最后猜测下攻击链：</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">爆破Tomcat后台</span><br><span class="line">部署webshell、HTTP隧道代理</span><br><span class="line">上<span class="keyword">CS</span>木马进行权限维持</span><br><span class="line">创建后门管理员权限账号（<span class="keyword">test</span>$）</span><br><span class="line">利用 mimikatz 抓取管理员用户的密码</span><br><span class="line">用管理员账号登录服务器</span><br><span class="line">清除操作痕迹（清空安全日志）</span><br><span class="line">利用计划任务、自启动等进行权限维持</span><br></pre></td></tr></table></figure>

<p>在检查的时候，如果遇到很多数据干扰的话可以配合其他方式或者是时间，文件名，状态码去筛选，可以过滤掉绝大多数的垃圾数据再配合一些工具，D盾，PCHunter之类的能让检查顺利很多。</p>
]]></content>
      <categories>
        <category>应急响应</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>文件包含漏洞个人总结</title>
    <url>/2022/03/08/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="什么是文件包含"><a href="#什么是文件包含" class="headerlink" title="什么是文件包含"></a>什么是文件包含</h2><p>程序开发人员一般希望代码更灵活，所以将被包含的文件设置为变量，用来进行动态调用，但正是由于这种灵活性，从而导致客户端可以调用一个恶意文件，造成文件包含漏洞。为了控制代码的灵活，程序要把要使用的函数写到一个文件中，其他需要其中的的函数执行，只需要通过该文件名包含进来，而且没有进行验证。</p>
<span id="more"></span>

<h2 id="文件包含分类"><a href="#文件包含分类" class="headerlink" title="文件包含分类"></a>文件包含分类</h2><p><strong>本地包含</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">当被包含的文件在服务器本地时，且能够读取或执行包含本地文件的漏洞，称为本地文件包含漏洞</span><br></pre></td></tr></table></figure>

<p><strong>远程包含</strong></p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">远程文件包含和本地文件包含造成漏洞的原因是一样的，当开发配置可以读取远程文件时，例如php.ini 中的配置选项allow_url_fopen和allow_url_include为<span class="keyword">ON</span>的话，则包含的文件可以是第三方服务器中的文件，这样就形成了远程文件包含漏洞。</span><br><span class="line">代码限制：代码里面限制只能包含本地文件的话就不会有远程包含，如果没限制的话，并且在设置上允许包含远程文件的话，就会引起远程包含</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">通过文件以脚本去执行</span><br><span class="line">文件包含常用函数</span><br><span class="line"><span class="function"><span class="title">include</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">require</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">fopen</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">include_once</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">require_once</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">readfile</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<h2 id="如何检测"><a href="#如何检测" class="headerlink" title="如何检测"></a>如何检测</h2><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">漏扫工具</span><br><span class="line">公开漏洞</span><br><span class="line">手工看参数以及功能点</span><br><span class="line"><span class="number">1</span>、通过观察参数特征猜测是否使用文件包含，文件包含参数后面为具体文件名如：http:<span class="regexp">//</span>example.com/index.php?page=include.php</span><br><span class="line">http:<span class="regexp">//</span>example.com/index.php?page=include</span><br><span class="line"><span class="number">2</span>、通过..<span class="regexp">/目录跳转符尝试读取系统文件、服务器日志文件或者配置文件。如读取Linux的/</span>etc<span class="regexp">/passwd文件: http:/</span><span class="regexp">/example.com/i</span>ndex.php?page=..<span class="regexp">/../</span>..<span class="regexp">/../</span>etc/passwd</span><br><span class="line"><span class="number">3</span>、通过php:<span class="regexp">//</span>filter<span class="regexp">/convert.base64-encode/</span>resource=index.php读取代码文件。</span><br><span class="line"><span class="number">4</span>、通过包含远程服务器上的PHP代码文件执行代码。</span><br><span class="line"><span class="number">5</span>、如果站点存在一个文件上传功能，只允许图片类型文件，并且存在文件包含漏洞，则可以把PHP代码写入图片文件中，再通过文件包含漏洞包含之，进而执行PHP代码。</span><br><span class="line"><span class="number">6</span>、如果文件的后缀可考虑使用截断进行包含：</span><br><span class="line">  <span class="number">1</span>)%<span class="number">00</span>截断（PHP小于<span class="number">5.3</span>.<span class="number">4</span>，magic_quotes_gpc=off）</span><br><span class="line">  <span class="number">2</span>)路径长度截断：</span><br><span class="line">  <span class="regexp">/etc/</span>passwd<span class="regexp">/./</span>.<span class="regexp">/./</span>.<span class="regexp">/./</span>.[n*/.]（Linux文件名需要长于<span class="number">4096</span>，Windows 需要长于<span class="number">256</span>）</span><br></pre></td></tr></table></figure>

<h2 id="如何利用"><a href="#如何利用" class="headerlink" title="如何利用"></a>如何利用</h2><figure class="highlight"><table><tr><td class="code"><pre><span class="line">1.读取目标机上敏感文件</span><br><span class="line">2.远程文件包含可运行的PHP木马</span><br><span class="line">3、配合文件上传漏洞获取webshll</span><br></pre></td></tr></table></figure>

<h2 id="修复"><a href="#修复" class="headerlink" title="修复"></a>修复</h2><figure class="highlight"><table><tr><td class="code"><pre><span class="line">固定文件后缀</span><br><span class="line">固定使用的文件</span><br><span class="line">安装WAF</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>逻辑越权</title>
    <url>/2022/01/16/%E9%80%BB%E8%BE%91%E8%B6%8A%E6%9D%83/</url>
    <content><![CDATA[<h1 id="逻辑漏洞"><a href="#逻辑漏洞" class="headerlink" title="逻辑漏洞"></a><strong>逻辑漏洞</strong></h1><ul>
<li> 攻击者利用业务的设计缺陷，获取敏感信息或破坏业务的完整性， 其本质就是程序逻辑输入管控不严，没有对用户数据进行严格把控，导致程序不能够正常处理或处理错误，一般出现在登录注册、密码找回、信息查看、交易支付金额等。<span id="more"></span></li>
</ul>
<h1 id="逻辑漏洞类型"><a href="#逻辑漏洞类型" class="headerlink" title="逻辑漏洞类型"></a>逻辑漏洞类型</h1><h2 id="越权"><a href="#越权" class="headerlink" title="越权"></a>越权</h2><h3 id="水平越权"><a href="#水平越权" class="headerlink" title="水平越权"></a>水平越权</h3><ul>
<li>漏洞介绍：即普通用户/管理员能访问其他普通用户/管理员才能够访问的系统信息或者系统功能</li>
<li>形成原因：在进行方法调用时候未进行请求用户和目标信息拥有者是否匹配一致，直接用userid/email之类的容易遍历的参数进行数据库查询</li>
<li>漏洞点：在普通用户/管理员登录后的能访问的链接或者功能中都可能存在</li>
<li>漏洞修复：在权限管理中，平行越权的权限管理颗粒度最小修复思路需要在方法中进行相关的获取请求request再利用getAttribute(“userid”)获取其userid直接使用该userid作为参数进行数据增删查改，避免userid参数传输</li>
</ul>
<h3 id="垂直越权"><a href="#垂直越权" class="headerlink" title="垂直越权"></a>垂直越权</h3><ul>
<li><p>漏洞介绍：即普通用户能够访问管理员甚至超级管理员才能够访问的系统信息或者系统功能</p>
</li>
<li><p>形成原因：程序再方法调用时候，缺少角色等级校验</p>
</li>
<li><p>漏洞点：在任何用户登录后才能访问的链接或者功能中都可能存在对每一个传输的参数都要了解参数的目的，尝试将用户名改为admin尝试绕过</p>
</li>
<li><p>漏洞修复：需要校验用户是否有权限访问这个方法修复思路：获取请求request再利用getAuttribute(“roleid”)获取其角色等级检查角色等级是否合法，错误则直接返回错误跳转，返回页面必须仍然从Attribute中获取userid再进一步查询相关信息值得注意的是切勿将错误跳转写到Javascript里面，还返回目标URL页面的相关信息。</p>
</li>
</ul>
<h2 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h2><h3 id="本地加密传输"><a href="#本地加密传输" class="headerlink" title="本地加密传输"></a>本地加密传输</h3><h3 id="cookie脆弱"><a href="#cookie脆弱" class="headerlink" title="cookie脆弱"></a>cookie脆弱</h3><ul>
<li><p>漏洞介绍：通过伪造cookie信息能够伪造其他用户进行登录。</p>
</li>
<li><p>漏洞原理：开发者为了方便将身份信息/登录信息明文或者只是简单编码、哈希之后存放在cookies中，网站通过获取得到的cookies进行授权或者身份验证</p>
</li>
<li><p>漏洞点：cookie中有明显或者只是简单编码、哈希的字段时候 修改lsLogin值为1可以判定为用户已经登录 修改cookie为asp163=UserName=admin</p>
</li>
<li><p>漏洞修复： Cookie不应该存储可理解的身份信息和登录信息 按照规定，cookie对身份信息和登录信息的存储只能通过存储足够长度的随机字符串进行，避免篡改</p>
</li>
</ul>
<h3 id="Session劫持"><a href="#Session劫持" class="headerlink" title="Session劫持"></a>Session劫持</h3><ul>
<li><p>漏洞介绍：会话固定攻击是利用服务器的session不变机制，借他人之手获得认证和授权，然后冒充他人</p>
</li>
<li><p>漏洞原理：在请求登录过程时候，URL带有一个session，登录成功之后会将登录成功的信息绑定到这个session中，攻击者可以发送带有session的URL给相关工作人员诱导其登录，相当于获取了其身份信息</p>
</li>
<li><p>漏洞点：在GET方法请求登录时候带有session值</p>
</li>
<li><p>修复思路：只要避免在URL中带入session信息即可比较有效的防御另外也要注意POST请求中带有sessionid进行session固定攻击，虽然可利用性比较低，但是建议修复</p>
</li>
</ul>
<h3 id="密文对比认证"><a href="#密文对比认证" class="headerlink" title="密文对比认证"></a>密文对比认证</h3><h3 id="暴力破解"><a href="#暴力破解" class="headerlink" title="暴力破解"></a>暴力破解</h3><ul>
<li><p>漏洞介绍：攻击者可以通过该漏洞获取用户名和对应弱口令密码，并进行登录操作漏洞原理：由于没有设置登录失败次数限制，导致攻击者可以通过口令字典进行特定用户的密码爆破或通过用户名字典进行特定弱口令的用户枚举</p>
</li>
<li><p>漏洞点：系统登录点</p>
</li>
<li><p>漏洞修复： 对于固定用户名爆破密码可以针对用户名进行错误次数计算，高于一定阈值账号锁定一段时间，或者添加验证码但是不能永久锁定，可能被用来进行账户恶意锁定对于固定密码枚举用户名、 需要计算IP对URL的请求情况，某个IP短时间大量请求登录应该加入黑名单 进行传输数据加密有一定的防护效果</p>
</li>
</ul>
<h2 id="业务"><a href="#业务" class="headerlink" title="业务"></a>业务</h2><h3 id="订单ID"><a href="#订单ID" class="headerlink" title="订单ID"></a>订单ID</h3><h3 id="用户ID"><a href="#用户ID" class="headerlink" title="用户ID"></a>用户ID</h3><ul>
<li>在支付当中会出现当前用户的ID，比如：username=XXXXX，如果没有加以验证，其支付也是一次性支付没有要求输入密码什么的机制，那么就可以修改这个用户ID为其它用户ID，达到用其他用户的账号进行支付你的商品。</li>
</ul>
<h3 id="订单号码"><a href="#订单号码" class="headerlink" title="订单号码"></a>订单号码</h3><h3 id="商品ID"><a href="#商品ID" class="headerlink" title="商品ID"></a>商品ID</h3><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><h3 id="暴力破解-1"><a href="#暴力破解-1" class="headerlink" title="暴力破解"></a>暴力破解</h3><ul>
<li><p>漏洞介绍：攻击者可以通过该漏洞获取用户名和对应弱口令密码，并进行登录操作</p>
</li>
<li><p>漏洞原理：由于没有设置登录失败次数限制，导致攻击者可以通过口令字典进行特定用户的密码爆破或通过用户名字典进行特定弱口令的用户枚举 </p>
</li>
<li><p>漏洞点：系统登录点</p>
</li>
<li><p>漏洞修复： 对于固定用户名爆破密码可以针对用户名进行错误次数计算，高于一定阈值账号锁定一段时间，或者添加验证码但是不能永久锁定，可能被用来进行账户恶意锁定对于固定密码枚举用户名、 需要计算IP对URL的请求情况，某个IP短时间大量请求登录应该加入黑名单 进行传输数据加密有一定的防护效果</p>
</li>
</ul>
<h3 id="绕过验证"><a href="#绕过验证" class="headerlink" title="绕过验证"></a>绕过验证</h3><ul>
<li><p>漏洞介绍：攻击者通过篡改分步逻辑中的步骤数字，达到绕过支付、校验等效果</p>
</li>
<li><p>漏洞原理：程序逻辑分布进行，但是对步骤、验证信息、支付信息没有做好严格校验，导致修改步骤就直接绕过验证或者支付</p>
</li>
<li><p>漏洞点：任何分布逻辑且带步骤数字，或者利用JS进行步骤控制的功能中</p>
</li>
<li><p>漏洞修复：在请求最后一步时候需要带入前面的验证信息，服务端再进行一次校验信息的验证，验证正确方能继续执行数据操作也可以及通过getAttributr(“userid”)获取userid进行userid和验证结果绑定，最后一步不带入验证信息，但是仍然要获取userid进行校验再最后一步通过验证之后或者服务器收到支付信息后再生成相应的数据交给用户</p>
</li>
</ul>
<h3 id="自动识别"><a href="#自动识别" class="headerlink" title="自动识别"></a>自动识别</h3><h3 id="图形验证码绕过"><a href="#图形验证码绕过" class="headerlink" title="图形验证码绕过"></a>图形验证码绕过</h3><ul>
<li><p>漏洞介绍：攻击者通过突破图形验证码的验证，可以实现如登录爆破、验证码绕过等攻击</p>
</li>
<li><p>漏洞原理：图形验证码在错误后未失效返回验证码信息分步验证验证码</p>
</li>
<li><p>漏洞点：任何存在图形验证码的功能中</p>
</li>
<li><p>漏洞修复一旦验证码使用过了，必须要进行删除，重新生成验证码，可以梵高attribute中验证码需要设置超时，时间一到立即删除旧验证码，用户需要获取新的验证码验证码只需要返回图片，切勿将生成验证码的字符串也一并返回验证码不应该进行分布校验，应该连同请求数据一起发送到目标服务器进行校验，服务器校验通过则返回合法数据，否则返回错误</p>
</li>
</ul>
<h2 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h2><h3 id="支付篡改"><a href="#支付篡改" class="headerlink" title="支付篡改"></a>支付篡改</h3><ul>
<li>在支付当中，购买商品一般分为三步骤：订购、确认信息、付款。那么这个修改价格具体是修改哪一步时的价格呢？可以在这三个步骤当中的随便一个步骤进行修改价格测试，如果前面两步有验证机制，那么可在最后一步付款时进行抓包尝试修改金额，如果没有在最后一步做好检验，那么问题就会存在，其修改的金额值你可以尝试小数目或者尝试负数。</li>
</ul>
<h3 id="数量篡改"><a href="#数量篡改" class="headerlink" title="数量篡改"></a>数量篡改</h3><ul>
<li>在支付的过程中，数量也同时决定着价格，比如：1个数量商品对应的是100，2个数据就是200，那么当你修改这个值数量值为负数时，那么其金额也会变为负数，最后就会导致支付问题的产生。</li>
</ul>
<h3 id="请求重放"><a href="#请求重放" class="headerlink" title="请求重放"></a>请求重放</h3><ul>
<li><p>漏洞介绍：通过数据包重放，可以造成短信轰炸、邮件轰炸、重复提交订单等</p>
</li>
<li><p>漏洞原理：后台未进行相关操作的技术导致数据包重放</p>
</li>
<li><p>漏洞点：短信验证码、邮件校验、提交订单等功能。</p>
</li>
<li><p>修复方案：修复思路（针对短信、邮件）构造一个Hashmap&lt;String，short&gt;，存放邮箱或电话号码及对应次数只要某个邮箱或者电话号码次数够了，就不能继续发送了或者计算两次发送的时间间隔，时间过短就不继续发送了通用修复方案需要建立token机制或验证码机制，一次有效</p>
</li>
</ul>
<h3 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h3><h2 id="找回机制"><a href="#找回机制" class="headerlink" title="找回机制"></a>找回机制</h2><h3 id="客户端回显"><a href="#客户端回显" class="headerlink" title="客户端回显"></a>客户端回显</h3><h3 id="Response状态值"><a href="#Response状态值" class="headerlink" title="Response状态值"></a>Response状态值</h3><h3 id="Session覆盖"><a href="#Session覆盖" class="headerlink" title="Session覆盖"></a>Session覆盖</h3><h3 id="弱Token缺陷"><a href="#弱Token缺陷" class="headerlink" title="弱Token缺陷"></a>弱Token缺陷</h3><ul>
<li>token可爆破</li>
</ul>
<h3 id="找回流程绕过"><a href="#找回流程绕过" class="headerlink" title="找回流程绕过"></a>找回流程绕过</h3><ul>
<li>通过两个不同账号的找回，获得验证码之后部分的数据包，而另一个账号找回密码时跳过验证码的部分直接进入成功验证之后的部分，等</li>
</ul>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><h3 id="调用遍历"><a href="#调用遍历" class="headerlink" title="调用遍历"></a>调用遍历</h3><h3 id="参数篡改"><a href="#参数篡改" class="headerlink" title="参数篡改"></a>参数篡改</h3><ul>
<li><p>漏洞介绍：攻击者通过进行数值篡改进行攻击，从而获利</p>
</li>
<li><p>漏洞原理：没有对传输数据添加相关的校验参数后台未对参数值进行校验并直接使用数据包中的参数</p>
</li>
<li><p>漏洞点：抽奖、购买、转账、返现等功能</p>
</li>
<li><p>漏洞修复：对于软件来说，需要保护好内存数据，防止内存数据篡改计算传输数据的哈希，并将哈希附加在传输数据中作为校验值，避免被篡改先校验数值，防止大整数和负数；接着利用传输的商品ID从数据库中获取商品单价重新进行价格计算；最后生成订单（订单号应为随机值）</p>
</li>
</ul>
<h3 id="未授权访问"><a href="#未授权访问" class="headerlink" title="未授权访问"></a>未授权访问</h3><ul>
<li><p>漏洞介绍：即游客能够访问普通用户甚至超级管理员才能访问的系统信息或者系统功能</p>
</li>
<li><p>形成原因：主要是系统设计期间没有进行全局用户身份校验；或者校验存在缺陷</p>
</li>
<li><p>漏洞点：在任何用户登录后才能访问的链接或者功能中都可能存在</p>
</li>
<li><p>漏洞修复：J2EE中存在filter，可以获取用户的cookie等信息修复思路：建立LoginList，值是当前在线用户的id对所有需要登录访问到URL，获取请求request再利用 getAttribute(“userid”) 获取其userid检查userid是否存在于LoginList中，不存在则直接返回错误跳转值得注意的是切勿将错误跳转写到Javascript里面，还返回目标URL页面的相关信息</p>
</li>
</ul>
<h3 id="Webservice测试"><a href="#Webservice测试" class="headerlink" title="Webservice测试"></a>Webservice测试</h3><h3 id="callback自定义"><a href="#callback自定义" class="headerlink" title="callback自定义"></a>callback自定义</h3><h2 id="回退"><a href="#回退" class="headerlink" title="回退"></a>回退</h2><ul>
<li><h3 id="回退重放"><a href="#回退重放" class="headerlink" title="回退重放"></a>回退重放</h3></li>
</ul>
<h2 id="条件竞争"><a href="#条件竞争" class="headerlink" title="条件竞争"></a>条件竞争</h2><ul>
<li><p>漏洞介绍：可以通过同时重放大量数据包进行漏洞利用，通常用于突破限量、限额的问题都有奇效</p>
</li>
<li><p>漏洞原理：由于目标函数中，判断与数据修复两个步骤之间，或者两个数据修改步骤之间存在时间差，且函数未进行同步锁定，则可以造成漏洞</p>
</li>
<li><p>漏洞点：程序中存在限制，可以猜测到后台有判断与修改操作的方法</p>
</li>
<li><p>漏洞修复：修复思路：使用synchronized关键字，可以限制同一时间内访问方法的只有单一线程并不是每个条件竞争都必须修复</p>
</li>
</ul>
]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>外网渗透信息收集</title>
    <url>/2022/02/10/%E5%A4%96%E7%BD%91%E6%B8%97%E9%80%8F%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/</url>
    <content><![CDATA[<h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><p><strong>什么是信息搜集？</strong></p>
<p>信息搜集也称踩点，信息搜集毋庸置疑就是尽可能的搜集目标的信息，包括端口信息、DNS信息、员工邮箱等等看似并不起眼的一些信息都算是信息搜集，这些看似微乎其微的信息，对于渗透测试而言就关乎到成功与否了。</p>
<span id="more"></span>

<p><strong>信息搜集的重要性</strong></p>
<p>信息搜集是渗透测试的最重要的阶段，占据整个渗透测试的60%，可见信息搜集的重要性。根据收集的有用信息，可以大大提高我们渗透测试的成功率。</p>
<p><strong>信息搜集的分类</strong></p>
<table>
<thead>
<tr>
<th>主动式信息搜集（可获取到的信息较多，但易被目标发现）</th>
</tr>
</thead>
<tbody><tr>
<td>通过直接发起与被测目标网络之间的互动来获取相关信息，如通过Nmap扫描目标系统。</td>
</tr>
<tr>
<td>被动式信息搜集（搜集到的信息较少，但不易被发现）</td>
</tr>
<tr>
<td>通过第三方服务来获取目标网络相关信息。如通过搜索引擎方式来搜集信息。</td>
</tr>
</tbody></table>
<h1 id="二、搜索引擎"><a href="#二、搜索引擎" class="headerlink" title="二、搜索引擎"></a>二、搜索引擎</h1><table>
<thead>
<tr>
<th>Google hacking</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>fofa</td>
<td><a href="https://fofa.so/">https://fofa.so/</a></td>
</tr>
<tr>
<td>shodan—用来搜索网络空间中在线设备</td>
<td><a href="https://www.shodan.io/">https://www.shodan.io/</a></td>
</tr>
<tr>
<td>zoomeye—针对网络空间的搜索引擎，收录了互联网空间中的设备、网站及其使用的服务或组件等信息</td>
<td><a href="https://www.zoomeye.org/">https://www.zoomeye.org/</a></td>
</tr>
</tbody></table>
<p><strong>Google hacking——常用搜索语法：</strong></p>
<table>
<thead>
<tr>
<th>intitle:KEYWORD</th>
<th>搜索网页标题中含有关键词的网页</th>
</tr>
</thead>
<tbody><tr>
<td>intext:KEYWORD</td>
<td>搜索站点正文中含有关键词的网页</td>
</tr>
<tr>
<td>inurl:KEYWORD</td>
<td>搜索URL中包含有指定字符串的网址</td>
</tr>
<tr>
<td>inurl:php?id=</td>
<td>搜索PHP网页</td>
</tr>
<tr>
<td>site:DOMAIN</td>
<td>在指定站点内查找相关的内容</td>
</tr>
<tr>
<td>filetype:FILE</td>
<td>搜索指定类型的文件</td>
</tr>
</tbody></table>
<p><strong>我们可以同时附加多个条件进行筛选，比如 inurl:admin intitle:农具<br>两个筛选条件之间用空格隔开</strong></p>
<p><strong>fofa|shodan|zoomeye——搜索语法</strong></p>
<table>
<thead>
<tr>
<th>app:nginx</th>
<th>组件名</th>
</tr>
</thead>
<tbody><tr>
<td>ver:1.0</td>
<td>版本</td>
</tr>
<tr>
<td>os:windows</td>
<td>操作系统</td>
</tr>
<tr>
<td>country:”China”</td>
<td>国家</td>
</tr>
<tr>
<td>city:”guangzhou”</td>
<td>城市</td>
</tr>
<tr>
<td>port:80</td>
<td>端口</td>
</tr>
<tr>
<td>hostname:google</td>
<td>主机名</td>
</tr>
<tr>
<td>site:thief.one</td>
<td>网站域名</td>
</tr>
<tr>
<td>desc:nmask</td>
<td>描述</td>
</tr>
<tr>
<td>keywords:nmask’blog</td>
<td>关键词</td>
</tr>
<tr>
<td>service:ftp</td>
<td>服务类型</td>
</tr>
<tr>
<td>ip:8.8.8.8</td>
<td>ip地址</td>
</tr>
<tr>
<td>cidr:8.8.8.8/24</td>
<td>ip地址段</td>
</tr>
</tbody></table>
<p>通过以上不同种类的搜索引擎我们可以获得相当多的有用的信息，甚至平时搜索东西我们也可以通过zoomeye来找到自己想要的东西</p>
<h1 id="三、企业信息"><a href="#三、企业信息" class="headerlink" title="三、企业信息"></a>三、企业信息</h1><table>
<thead>
<tr>
<th>天眼查</th>
<th align="center">能根据用户的不同需求，实现了企业背景、企业发展、司法风险、经营风险、经营状况、知识产权方面等多种数据维度的检索，例如：企业信用信息公示系统，工业和信息化部ICP/IP地址/域名信息备案管理系统等以上几个可以用来深入了解渗透目标网站所属企业的相关信息</th>
<th><a href="https://www.tianyancha.com/">https://www.tianyancha.com/</a></th>
</tr>
</thead>
<tbody><tr>
<td>爱企查</td>
<td align="center"><em>爱企查</em>是百度推出的企业信用查询工具,提供一站式的企业信息实时查询,企业相关的工商信息查询,股东查询,主要成员查询,变更记录查询,网站备案查询,对外投资查询,分支机构查询,年报查询,风险警示查询等</td>
<td><a href="https://aiqicha.baidu.com/">https://aiqicha.baidu.com/</a></td>
</tr>
<tr>
<td>企查查</td>
<td align="center"><em>企查查</em>信息来自国家企业信用信息公示系统,提供企业信息查询,工商查询,企业信用评价查询,企业纠纷查询,企业现金流查询,企业股权查询,企业负债查询,企业资产查询,企业财报查询,公司查询等相关信息</td>
<td><a href="https://www.qcc.com/">https://www.qcc.com/</a></td>
</tr>
<tr>
<td>kali下的whois</td>
<td align="center"></td>
<td></td>
</tr>
<tr>
<td>ICP备案查询网</td>
<td align="center"></td>
<td></td>
</tr>
</tbody></table>
<h1 id="四、域名信息收集"><a href="#四、域名信息收集" class="headerlink" title="四、域名信息收集"></a>四、域名信息收集</h1><p>当我们确定了要渗透的目标，也就是知道了其域名，接下来我们需要收集域名对应的 ip，域名的whois信息、子域名等等一系列与域名相关的信息。</p>
<p>判断域名对应的IP：首先，我们要判断该域名是否存在CDN的情况，我们可以去在线CDN查询网站：<a href="http://ping.chinaz.com/">http://ping.chinaz.com/</a> 。如果查询出的ip数量大于一个的话，则说明该ip地址不是真实的服务器地址。以我的经验来看，如果是2个或者3个，并且这几个地址是同一地区的不同运营商的话，则很有可能这几个地址是服务器的出口地址，该服务器在内网中，通过不同运营商NAT映射供互联网访问，同时采用几个不同的运营商可以负载均衡和热备份。如果是多个ip地址，并且这些ip地址分布在不同地区的话，则基本上可以断定就是采用了CDN了。那么如何绕过CDN查找网站真实的ip地址呢？传送门——&gt; 绕过CDN查找网站真实ip</p>
<p>域名的whois信息：</p>
<p>通常，我们进行whois查询是去： 站长之家whois查询 。然后查出来信息之后，可以根据查询出来的邮箱、注册人、公司、电话等进行反查。</p>
<p>子域名、DNS记录查询：传送门——&gt; 子域名查询、DNS记录查询</p>
<p>公司敏感信息网上搜集<br>当确定了公司后，我们可以去互联网上查询与该公司有关的任何信息。比如，公司的邮箱格式，公司的员工姓名，以及与该公司有关的任何信息。并且，我们还可以去Github、码云等代码托管平台上查找与此有关的敏感信息，有些粗心的程序员在将代码上传至代码托管平台后，并没有对代码进行脱敏处理。导致上传的代码中有包含如数据库连接信息、邮箱密码、还有可能有泄露的源代码等。传送门——&gt; Github搜索语法</p>
<h1 id="五、whois信息"><a href="#五、whois信息" class="headerlink" title="五、whois信息"></a>五、whois信息</h1><p>whois是用来查询域名注册所有者等信息的传输协议。简单说，whois就是一个用来查询域名是否已经被注册，以及注册域名的详细信息的数据库（如域名所有人、域名注册商）。通过whois来实现对域名信息的查询。早期的whois查询多以命令行接口存在，但是现在出现了一些网页接口简化的线上查询工具，可以一次向不同的数据库查询。网页接口的查询工具仍然依赖whois协议向服务器发送查询请求，命令行接口的工具仍然被系统管理员广泛使用。whois通常使用TCP协议43端口。每个域名/IP的whois信息由对应的管理机构保存。<br>whois信息可以获取关键注册人的信息，包括注册商、联系人、联系邮箱、联系电话、创建时间等,可以进行邮箱反查域名，爆破邮箱，社工，域名劫持，寻找旁站等等。<br><strong>常用的工具有：</strong>站长工具，爱站，微步在线</p>
<h1 id="六、-Nslookup"><a href="#六、-Nslookup" class="headerlink" title="六、 Nslookup"></a>六、 Nslookup</h1><p>1.设置类型为ns</p>
<p>2.下面的例子查询baidu.com使用的DNS服务器名称:</p>
<p>3.下面的例子展示如何查询baidu.com的邮件交换记录：</p>
<p>4.查看网站cname值。</p>
<p>5.查看邮件服务器记录（-qt=MX）</p>
<p>6.同样nslookup也可以验证是否存在域传送漏洞，步骤如下：</p>
<p>nslookup进入交互式模式<br>Server 设置使用的DNS服务器<br>ls命令列出某个域中的所有域名</p>
<h1 id="七、子域名收集"><a href="#七、子域名收集" class="headerlink" title="七、子域名收集"></a>七、子域名收集</h1><p>子域名收集可以发现更多渗透测试范围内的域名/子域名，以增加漏洞发现机率；探测到更多隐藏或遗忘的应用服务，这些应用往往可导致一些严重漏洞。<br>常用的工具有：子域名挖掘机Layer、subDomainsBrute、Dnsenum、Dnsmap …</p>
<p>这里推荐一个在线收集子域名的网站 <a href="https://phpinfo.me/domain/">https://phpinfo.me/domain/</a> 但是可能会出现遇到泛解析防御机制的情况</p>
<h1 id="八、真实IP获取"><a href="#八、真实IP获取" class="headerlink" title="八、真实IP获取"></a>八、真实IP获取</h1><p>现在大多数的网站都开启了CDN加速，导致我们获取到的IP地址不一定是真实的IP地址。</p>
<p><strong>什么是CDN呢？</strong></p>
<p>CDN的全称是Content Delivery Network，即内容分发网络。其基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。通过在网络各处放置节点服务器所构成的在现有的互联网基础之上的一层智能虚拟网络，CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。其目的是使用户可就近取得所需内容，解决 Internet网络拥挤的状况，提高用户访问网站的响应速度。<br>如果想获取真实IP，我们可以使用以下几种方法<br>1.多地Ping法：由CDN的原理，不同的地方去Ping服务器，如果IP不一样，则目标网站肯定使用了CDN。这里推荐一个网站可以多个地点ping服务器，<a href="https://asm.ca.com/en/ping.php">https://asm.ca.com/en/ping.php</a></p>
<p>2.二级域名法：目标站点一般不会把所有的二级域名放cdn上。通过在线工具如站长帮手，收集子域名，确定了没使用CDN的二级域名后。本地将目标域名绑定到同IP（修改host文件），如果能访问就说明目标站与此二级域名在同一个服务器上；如果两者不在同一服务器也可能在同C段，扫描C段所有开80端口的IP，然后挨个尝试。</p>
<p>3.nslookup法：找国外的比较偏僻的DNS解析服务器进行DNS查询，因为大部分CDN提供商只针对国内市场，而对国外市场几乎是不做CDN，所以有很大的几率会直接解析到真实IP。</p>
<p>4.Ping法：直接ping example.com而不是<a href="http://www.example.com,因为现有很多cdn厂商基本只要求把www.example.com/">www.example.com，因为现有很多CDN厂商基本只要求把www.example.com</a> cname到CDN主服务器上去，那么直接ping example.com有可能直接获得真实IP。</p>
<p>5.在线资源：</p>
<ol>
<li><a href="https://wepcc.com/">全球Ping在线测试</a></li>
<li><a href="http://ping.chinaz.com/">站长工具-ping测试</a></li>
<li><a href="https://asm.ca.com/en/ping.php">CA</a></li>
<li><a href="https://dnsdumpster.com/">DNSDumpster</a></li>
<li><a href="https://ipchaxun.com/">IP查询</a></li>
<li><a href="https://viewdns.info/iphistory/">IPhistory</a></li>
<li><a href="https://securitytrails.com/">securitytrails</a></li>
<li><a href="https://sitereport.netcraft.com/">netcraft</a></li>
<li><a href="https://www.17ce.com/">17CE</a></li>
<li><strong>kali下的nslookup、dig</strong></li>
</ol>
<h1 id="九、指纹识别"><a href="#九、指纹识别" class="headerlink" title="九、指纹识别"></a>九、指纹识别</h1><p>通过识别目标网站所使用的操作系统、CMS、服务器与中间件信息，可以帮助我们进一步了解渗透测试环境，可以利用已知的一些CMS漏洞或中间件漏洞来进行攻击。在渗透测试中，对目标服务器进行指纹识别是相当有必要的，因为只有识别出相应的Web容器或者CMS，才能查找与其相关的漏洞，然后才能进行相应的渗透操作。CMS又称整站系统。常见的CMS有：WordPress、Dedecms、Discuz、PhpWeb、PhpWind、Dvbbs、PhpCMS、ECShop、、SiteWeaver、AspCMS、帝国、Z-Blog等。</p>
<p>常见的网站指纹识别工具有：whatweb等。</p>
<p>在线指纹识别网站：</p>
<p>BugScaner：<a href="http://whatweb.bugscaner.com/look/">http://whatweb.bugscaner.com/look/</a><br>云悉指纹：<a href="http://www.yunsee.cn/finger.html">http://www.yunsee.cn/finger.html</a><br>WhatWeb：<a href="https://whatweb.net/">https://whatweb.net/</a><br>整站分析</p>
<p>可以在以下地方获取信息：<br>1.指定路径下指定名称的js文件或代码。</p>
<p>2.指定路径下指定名称的css文件或代码。</p>
<p>5.display:none中的版权信息。</p>
<p>6.页面底部版权信息，关键字© Powered by等。</p>
<p>7.readme.txt、License.txt、help.txt等文件。</p>
<p>8.指定路径下指定图片文件，如一些小的图标文件，后台登录页面中的图标文件<br>等，一般管理员不会修改它们。</p>
<p>9.注释掉的html代码中&lt;!–</p>
<p>10.http头的X-Powered-By中的值，有的应用程序框架会在此值输出。</p>
<p>11.cookie中的关键字</p>
<p>12.robots.txt文件中的关键字，robots.txt 中禁止的路径很可能说明站点就有这些路径 而且robots.txt 多是可访问的</p>
<p>13.404页面</p>
<p>14.302返回时的旗标</p>
<h1 id="十、服务器类型-Linux-Windows"><a href="#十、服务器类型-Linux-Windows" class="headerlink" title="十、服务器类型(Linux/Windows)"></a>十、服务器类型(Linux/Windows)</h1><p>服务器信息包括服务器用的操作系统：Linux 还是 Windows 。现在企业网站服务器的操作系统有百分之九十以上用的是Linux操作系统。知道了服务器的操作系统之后，还需要知道操作系统使用的具体版本。因为很多低版本的操作系统都存在已知的漏洞。</p>
<p>判断是Linux还是Windows最简单就是通过ping来探测，Windows的TTL值都是一般是128，Linux则是64。所以大于100的肯定是Windows，而几十的肯定是Linux。但是，通过TTL值来判断服务器类型也不是百分之百准确的，有些windows服务器的TTL值也是几十，而且有的服务器禁止ping。</p>
<p>而判断目标网站服务器的具体的版本的话，可以采用 <a href="https://so.csdn.net/so/search?q=nmap&spm=1001.2101.3001.7020">nmap</a> 进行扫描， -O 和 -A 参数都能扫描出来</p>
<p>通过大小写判断</p>
<p>访问网站：<br><a href="http://www.xxx.com/index.html">http://www.xxx.com/index.html</a><br><a href="http://www.xxx.com/inDex.html">http://www.xxx.com/inDex.html</a><br>Windows操作系统不区分大小写，Linux系统大小写敏感，用此方法能够判断是Windows还是Linux系统。</p>
<p>工具 ：云悉指纹、Whatweb、httprint、Bugscanner、浏览器插件 wappalyzer</p>
<p>有的时候HTTP返回报文的server也可能泄露相关信息</p>
<h1 id="十一、网站容器（Apache-Nginx-Tomcat-IIS）"><a href="#十一、网站容器（Apache-Nginx-Tomcat-IIS）" class="headerlink" title="十一、网站容器（Apache/Nginx/Tomcat/IIS）"></a>十一、网站容器（Apache/Nginx/Tomcat/IIS）</h1><p>知道了这些信息之后，我们就需要知道网站用的web服务器是什么类型的：Apache、Nginx、Tomcat 还是 IIS。知道了web服务器是哪种类型后，我们还要探测web服务器具体的版本。比如Ngnix版本&lt;0.83会有解析漏洞 ，IIS6.0会有文件名解析漏洞、IIS7.0会有畸形解析漏洞等。不同的web服务器版本，存在着不同漏洞。</p>
<h1 id="十二、脚本类型-php-jsp-asp-aspx"><a href="#十二、脚本类型-php-jsp-asp-aspx" class="headerlink" title="十二、脚本类型(php/jsp/asp/aspx)"></a>十二、脚本类型(php/jsp/asp/aspx)</h1><p>我们需要知道网站用的脚本类型：php 、Jsp 、Asp 、Aspx 。</p>
<p>1：可以根据网站URL来判断</p>
<p>2：site:xxx filetype:php</p>
<p>3：可以根据Firefox的插件来判断</p>
<h1 id="十三、数据库类型-Mysql-Oracle-Accees-Mqlserver"><a href="#十三、数据库类型-Mysql-Oracle-Accees-Mqlserver" class="headerlink" title="十三、数据库类型(Mysql/Oracle/Accees/Mqlserver)"></a>十三、数据库类型(Mysql/Oracle/Accees/Mqlserver)</h1><p>我们需要知道网站用的是哪种类型的数据库：Mysql、Oracle、SqlServer 还是 Access 。虽然这几种数据库的语法大体上相同，但是还是有区别的。所以我们还是要知道目标网站用的是哪种数据库，并且数据库是哪个版本的。</p>
<p>几种数据库的区别：</p>
<ol>
<li>Access 全名是Microsoft Office Access，是由微软发布的关联式数据库管理系统。小型数据库，当数据库达到100M左右的时候性能就会下降。数据库后缀名： .mdb 一般是asp的网页文件用access数据库</li>
<li>SQL Server是由Microsoft开发和推广的关系数据库管理系统（DBMS），是一个比较大型的数据库。端口号为1433。数据库后缀名 .mdf</li>
<li>MySQL 是一个关系型数据库管理系统，由瑞典MySQL AB 公司开发，目前属于 Oracle 旗下产品。MySQL是最流行的关系型数据库管理系统，在 WEB 应用方面MySQL是最好的应用软件之一，MySQL数据库大部分是php的页面。默认端口是3306</li>
<li>Oracle又名Oracle RDBMS，或简称Oracle。是甲骨文公司的一款关系数据库管理系统。常用于比较大的网站。默认端口是1521</li>
</ol>
<p>access是不要钱的，access支持千以内的访问量，access是小型数据库</p>
<p>mysql也是开源的，mysql 是中小型数据库</p>
<p>sql server 是收费的一般也就几千，sql server支持几千到上万的访问，sql server是中型数据库</p>
<p>Oracle的费用则数万，Oracle则支持海量的访 问，Oracle是大型数据库</p>
<p>常见搭配：</p>
<p>ASP 和 ASPX：ACCESS、SQL Server<br>PHP：MySQL、PostgreSQL<br>JSP：Oracle、MySQL<br>主机扫描(Nessus)<br>对目标主机进行扫描，而不仅仅是对网站进行扫描，扫描目标主机开放了哪些端口，扫描端口运行的服务，目标主机上有哪些漏洞。</p>
<p>主机扫描的工具也有很多，比如：Nessus</p>
<h1 id="十四、端口扫描"><a href="#十四、端口扫描" class="headerlink" title="十四、端口扫描"></a>十四、端口扫描</h1><p>扫描端口可以使用Nmap，masscan进行扫描探测，尽可能多的搜集开启的端口好已经对应的服务版本，得到确切的服务版本后可以搜索有没有对应版本的漏洞。<br>常见的端口信息及渗透方法：</p>
<table>
<thead>
<tr>
<th>端口</th>
<th>服务</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>tcp 20,21</td>
<td>FTP</td>
<td>允许匿名的上传下载,爆破,嗅探,win提权,远程执行(proftpd 1.3.5),各类后门(proftpd,vsftp 2.3.4)</td>
</tr>
<tr>
<td>tcp 22</td>
<td>SSH</td>
<td>可根据已搜集到的信息尝试爆破,v1版本可中间人,ssh隧道及内网代理转发,文件传输等等</td>
</tr>
<tr>
<td>tcp 23</td>
<td>Telnet</td>
<td>爆破,嗅探,一般常用于路由,交换登陆,可尝试弱口令</td>
</tr>
<tr>
<td>tcp 25</td>
<td>SMTP</td>
<td>邮件伪造,vrfy/expn查询邮件用户信息,可使用smtp-user-enum工具来自动跑</td>
</tr>
<tr>
<td>tcp/udp 53</td>
<td>DNS</td>
<td>允许区域传送,dns劫持,缓存投毒,欺骗以及各种基于dns隧道的远控</td>
</tr>
<tr>
<td>tcp/udp 69</td>
<td>TFTP</td>
<td>尝试下载目标及其的各类重要配置文件</td>
</tr>
<tr>
<td>tcp 80-89,443,8440-8450,8080-8089</td>
<td>各种常用的Web服务端口</td>
<td>可尝试经典的topn,vpn,owa,webmail,目标oa,各类Java控制台,各类服务器Web管理面板,各类Web中间件漏洞利用,各类Web框架漏洞利用等等……</td>
</tr>
<tr>
<td>tcp 110</td>
<td>POP3</td>
<td>可尝试爆破,嗅探</td>
</tr>
<tr>
<td>tcp 111,2049</td>
<td>NFS</td>
<td>权限配置不当</td>
</tr>
<tr>
<td>tcp 137,139,445</td>
<td>Samba</td>
<td>可尝试爆破以及smb自身的各种远程执行类漏洞利用,如,ms08-067,ms17-010,嗅探等……</td>
</tr>
<tr>
<td>tcp 143</td>
<td>IMAP</td>
<td>可尝试爆破</td>
</tr>
<tr>
<td>udp 161</td>
<td>SNMP</td>
<td>爆破默认团队字符串,搜集目标内网信息</td>
</tr>
<tr>
<td>tcp 389</td>
<td>LDAP</td>
<td>ldap注入,允许匿名访问,弱口令</td>
</tr>
<tr>
<td>tcp 512,513,514</td>
<td>Linux rexec</td>
<td>可爆破,rlogin登陆</td>
</tr>
<tr>
<td>tcp 873</td>
<td>Rsync</td>
<td>匿名访问,文件上传</td>
</tr>
<tr>
<td>tcp 1194</td>
<td>OpenVPN</td>
<td>想办法钓VPN账号,进内网</td>
</tr>
<tr>
<td>tcp 1352</td>
<td>Lotus</td>
<td>弱口令,信息泄漏,爆破</td>
</tr>
<tr>
<td>tcp 1433</td>
<td>SQL Server</td>
<td>注入,提权,sa弱口令,爆破</td>
</tr>
<tr>
<td>tcp 1521</td>
<td>Oracle</td>
<td>tns爆破,注入,弹shell…</td>
</tr>
<tr>
<td>tcp 1500</td>
<td>ISPmanager</td>
<td>弱口令</td>
</tr>
<tr>
<td>tcp 1723</td>
<td>PPTP</td>
<td>爆破,想办法钓VPN账号,进内网</td>
</tr>
<tr>
<td>tcp 2082,2083</td>
<td>cPanel</td>
<td>弱口令</td>
</tr>
<tr>
<td>tcp 2181</td>
<td>ZooKeeper</td>
<td>未授权访问</td>
</tr>
<tr>
<td>tcp 2601,2604</td>
<td>Zebra</td>
<td>默认密码zerbra</td>
</tr>
<tr>
<td>tcp 3128</td>
<td>Squid</td>
<td>弱口令</td>
</tr>
<tr>
<td>tcp 3312,3311</td>
<td>kangle</td>
<td>弱口令</td>
</tr>
<tr>
<td>tcp 3306</td>
<td>MySQL</td>
<td>注入,提权,爆破</td>
</tr>
<tr>
<td>tcp 3389</td>
<td>Windows rdp</td>
<td>shift后门[需要03以下的系统],爆破,ms12-020</td>
</tr>
<tr>
<td>tcp 3690</td>
<td>SVN</td>
<td>svn泄露,未授权访问</td>
</tr>
<tr>
<td>tcp 4848</td>
<td>GlassFish</td>
<td>弱口令</td>
</tr>
<tr>
<td>tcp 5000</td>
<td>Sybase/DB2</td>
<td>爆破,注入</td>
</tr>
<tr>
<td>tcp 5432</td>
<td>PostgreSQL</td>
<td>爆破,注入,弱口令</td>
</tr>
<tr>
<td>tcp 5900,5901,5902</td>
<td>VNC</td>
<td>弱口令爆破</td>
</tr>
<tr>
<td>tcp 5984</td>
<td>CouchDB</td>
<td>未授权导致的任意指令执行</td>
</tr>
<tr>
<td>tcp 6379</td>
<td>Redis</td>
<td>可尝试未授权访问,弱口令爆破</td>
</tr>
<tr>
<td>tcp 7001,7002</td>
<td>WebLogic</td>
<td>Java反序列化,弱口令</td>
</tr>
<tr>
<td>tcp 7778</td>
<td>Kloxo</td>
<td>主机面板登录</td>
</tr>
<tr>
<td>tcp 8000</td>
<td>Ajenti</td>
<td>弱口令</td>
</tr>
<tr>
<td>tcp 8443</td>
<td>Plesk</td>
<td>弱口令</td>
</tr>
<tr>
<td>tcp 8069</td>
<td>Zabbix</td>
<td>远程执行,SQL注入</td>
</tr>
<tr>
<td>tcp 8080-8089</td>
<td>Jenkins,JBoss</td>
<td>反序列化,控制台弱口令</td>
</tr>
<tr>
<td>tcp 9080-9081,9090</td>
<td>WebSphere</td>
<td>Java反序列化/弱口令</td>
</tr>
<tr>
<td>tcp 9200,9300</td>
<td>ElasticSearch</td>
<td>远程执行</td>
</tr>
<tr>
<td>tcp 11211</td>
<td>Memcached</td>
<td>未授权访问</td>
</tr>
<tr>
<td>tcp 27017,27018</td>
<td>MongoDB</td>
<td>爆破,未授权访问</td>
</tr>
<tr>
<td>tcp 50070,50030</td>
<td>Hadoop</td>
<td>默认端口未授权访问</td>
</tr>
</tbody></table>
<h1 id="十五、Nmap"><a href="#十五、Nmap" class="headerlink" title="十五、Nmap"></a>十五、Nmap</h1><p>Nmap是一个网络连接端口扫描软件，用来扫描网上电脑开放的网络连接端口。确定哪些服务运行在哪些连接端口，并且推断计算机运行哪个操作系统。它是网络管理员必用的软件之一，以及用以评估网络系统安全。<br>功能:<br>1、 主机发现<br>2、 端口扫描<br>3、 版本侦测<br>4、 OS侦测</p>
<h1 id="十六、旁站C段查询"><a href="#十六、旁站C段查询" class="headerlink" title="十六、旁站C段查询"></a>十六、旁站C段查询</h1><p>旁站指的是同一服务器上的其他网站，很多时候，有些网站可能不是那么容易入侵。那么，可以查看该网站所在的服务器上是否还有其他网站。如果有其他网站的话，可以先拿下其他网站的webshell，然后再提权拿到服务器的权限，最后就自然可以拿下该网站了！</p>
<p>对于红蓝对抗和护网，C段扫描比较有意义。对于单独网站的渗透测试，C段扫描意义不大。C段指的是同一内网段内的其他服务器，每个IP有ABCD四个段，举个例子，192.168.0.1，A段就是192，B段是168，C段是0，D段是1，而C段嗅探的意思就是拿下它同一C段中的其中一台服务器，也就是说是D段1-255中的一台服务器，然后利用工具嗅探拿下该服务器。</p>
<p>旁站和C段在线查询地址：</p>
<p><a href="http://www.webscan.cc/">http://www.webscan.cc/</a></p>
<p>旁站：是和目标网站在同一台服务器上的其它的网站。</p>
<p>旁注：通过入侵安全性较差的旁站，之后可以通过提权跨目录等手段拿到目标服务器的权限。</p>
<p>工具：K8_C段旁注工具、WebRobot、御剑、明小子 …</p>
<p>C段：每个IP有ABCD四个段，也就是说是D段1-255中的一台服务器，然后利用工具嗅探拿下该服务。比如192.168.3.0-255的设备都处于同一个c段。</p>
<p>C段入侵：目标ip为192.168.1.128，可以入侵192.168.1.*的任意一台机器，然后利用一些黑客工具嗅探获取在网络上传输的各种信息。</p>
<p>工具：Cain、Sniffit 、Snoop、Tcpdump、Dsniff …</p>
<h1 id="十七、其他信息"><a href="#十七、其他信息" class="headerlink" title="十七、其他信息"></a>十七、其他信息</h1><p>Web敏感文件<br>robots.txt、crossdomin.xml、sitemap.xml、源码泄漏文件 …</p>
<p>WAF信息<br>WAF识别大多基于Headers头信息，还可以使用Wafw00f，Sqlmap的waf脚本，Nmap的http-waf-detect和http-waf-fingerprint脚本等等。</p>
<p>相关漏洞<br>漏洞查询站点：exploitdb、hackerone、CNVD、0day5、乌云漏洞库镜像站 …</p>
<p>扫描网站目录结构，看看是否可以遍历目录，或者敏感文件泄漏</p>
<p>后台目录：弱口令，万能密码，爆破<br>安装包：获取数据库信息，甚至是网站源码<br>上传目录：截断、上传图片马等<br>mysql管理接口：弱口令、爆破，万能密码，然后脱裤，甚至是拿到shell<br>安装页面 ：可以二次安装进而绕过<br>phpinfo：会把你配置的各种信息暴露出来<br>富文本编辑器<br>iis短文件利用：条件比较苛刻 windows、apache等</p>
<p>robots.txt 文件是专门针对搜索引擎机器人robot 编写的一个纯文本文件。我们可以在这个文件中指定网站中不想被robot访问的目录。这样，我们网站的部分或全部内容就可以不被搜索引擎收录了，或者让搜索引擎只收录指定的内容。因此我们可<br>以利用robots.txt让Google的机器人访问不了我们网站上的重要文件，GoogleHack的威胁也就不存在了。<br>假如编写的robots.txt文件内容如下：</p>
<p>User-agent: *<br>Disallow: /data/<br>Disallow: /db/<br>Disallow: /admin/<br>Disallow: /manager/<br>Allow:/images/<br>其中“Disallow”参数后面的是禁止robot收录部分的路径，例如我们要让robot禁止收录网站目录下的“data”文件夹，只需要在Disallow参数后面加上 /data/ 即可。如果想增加其他目录，只需按此格式继续添加。文件编写完成后将其上传到网站的根目录，就可以让网站远离Google Hack了。</p>
<p>探测目标网站后台目录的工具有： wwwscan 、御剑 、 dirbuster、cansina 等</p>
]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>安全小白怎么从零开始拥有自己的武器库</title>
    <url>/2022/01/20/%E5%AE%89%E5%85%A8%E5%B0%8F%E7%99%BD%E6%80%8E%E4%B9%88%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%8B%A5%E6%9C%89%E8%87%AA%E5%B7%B1%E7%9A%84%E6%AD%A6%E5%99%A8%E5%BA%93/</url>
    <content><![CDATA[<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>前些日子跟个大佬搞攻防，看着大佬超神我超鬼，不得不佩服大佬，看着大佬用的很多工具都没见过，问了下这些工具是啥，大佬掏出了他的大宝贝给我看，嚯，好家伙，一整个文件夹都是自己开发的工具还有一些魔改的工具，属实羡慕，看着大佬那些工具，陷入沉思，是不是我也可以有自己的武器库🤨总不能当伸手党吧，而且还能熟悉语言，增强自己在代码审计那块的。刚好之前搞过一段时间的开发，对于开发一些工具啥的还是有自己的想法的，说干就干，这个系列是写安全小白怎么从零开始拥有自己的一个工具库的文章，在开发方面我也是菜鸟，所以可能有些工具的开发思路跟那些流行的工具思路可能不一样，有哪写得不好的地方，希望大佬们能带带我。</p>
<span id="more"></span>

<h1 id="二、前期准备"><a href="#二、前期准备" class="headerlink" title="二、前期准备"></a>二、前期准备</h1><h2 id="2-1语言选择"><a href="#2-1语言选择" class="headerlink" title="2.1语言选择"></a>2.1语言选择</h2><p>开发工具嘛，肯定要会一两个语言，相信各位大佬肯定掌握了不止三四种的语言，小弟没啥能力，只掌握了C，java，python，php，go这几种，用来开发工具的话比较常见的就是java，python，go了，我比较熟悉那个java和python，而且一些常见的工具也是用的java和python来开发的，这两种语言的区别就不介绍了，大家都懂的，选择哪种主要看个人的需求，如果想省点事的话可以用python，里面的库用到才知道香，但是python虚拟机没有java强，毕竟java虚拟机是java的核心，而且python是全动态性的，可以在运行时自己修改自己的代码，java只能通过变通方法实现。python的变量是动态的，而java的变量是静态的，需要事先声明，所以java ide的代码提示功能优于python ide。</p>
<p>用java开发工具的话主要是习惯了用java开发有界面的工具，而python的话主要是因为库强大，可以少写很多东西，省很多时间，当然不是说python没办法搞界面，python是推出了一些框架用于开发界面的，其中最常用的就是一个是Django，Django是一个较为高级的Python Web框架，以快速开发和实用简洁的设计闻名，关于语言的选择还是看个人习惯吧，没有谁好谁坏的说法。</p>
<h2 id="2-2编译器"><a href="#2-2编译器" class="headerlink" title="2.2编译器"></a>2.2编译器</h2><p>java用的编译器是IDEA和eclipse，python用的是PyCharm，这几个都是很不错的编译器，就是有些只能试用或者找破解，下完编译器，先建个项目，这边拿eclipse做下示范，进来先建个项目，这边选的是1.8.0的，然后把名字命名一下，搞一个com.AX.Database_listening，然后直接finish。</p>
<p><img src="https://ax-x.github.io/2022/01/20/%E5%AE%89%E5%85%A8%E5%B0%8F%E7%99%BD%E6%80%8E%E4%B9%88%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%8B%A5%E6%9C%89%E8%87%AA%E5%B7%B1%E7%9A%84%E6%AD%A6%E5%99%A8%E5%BA%93/image-20211220102525498.png" alt="image-20211220102525498"></p>
<p>搞完建好了，先看下目录结构SRC是我们之后写代码的地方，然后JRE这块是我们导入的包，事先有导入别的包，所以创建完之后会直接存在。</p>
<p><img src="https://ax-x.github.io/2022/01/20/%E5%AE%89%E5%85%A8%E5%B0%8F%E7%99%BD%E6%80%8E%E4%B9%88%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%8B%A5%E6%9C%89%E8%87%AA%E5%B7%B1%E7%9A%84%E6%AD%A6%E5%99%A8%E5%BA%93/image-20211220112758035.png" alt="image-20211220112758035"></p>
<p>一般我们在开发的时候都会用到别人写好的东西，而有些是需要你导入的，我们下载完别人的jar之后，在自己项目下面创建一个lib，把我们下载好的jar拉进去，然后右键项目，点击Properties，然后选择Java Build Path</p>
<p><img src="https://ax-x.github.io/2022/01/20/%E5%AE%89%E5%85%A8%E5%B0%8F%E7%99%BD%E6%80%8E%E4%B9%88%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%8B%A5%E6%9C%89%E8%87%AA%E5%B7%B1%E7%9A%84%E6%AD%A6%E5%99%A8%E5%BA%93/image-20211220103338819.png" alt="image-20211220103338819"></p>
<p>找到你刚刚拉进来的jar，选中添加，然后保存，整个流程就结束了，这样我们在写其他功能的时候就会方便很多了。</p>
<p><img src="https://ax-x.github.io/2022/01/20/%E5%AE%89%E5%85%A8%E5%B0%8F%E7%99%BD%E6%80%8E%E4%B9%88%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%8B%A5%E6%9C%89%E8%87%AA%E5%B7%B1%E7%9A%84%E6%AD%A6%E5%99%A8%E5%BA%93/image-20211220112652185.png" alt="image-20211220112652185"></p>
<p>然后可以开始写你自己代码了。</p>
<h2 id="2-3语言能力"><a href="#2-3语言能力" class="headerlink" title="2.3语言能力"></a>2.3语言能力</h2><p>语言和编译器选完了，就该有人问了，我这语言得掌握到啥程度才能开发自己的工具，嚯，要问这话我也不知道该怎么回，毕竟我自己学的也不是很深，就JAVA来说，如果你接受过系统的学习的话，基本上都会在学完基础语法之后进入到线程，异常，文件访问，接口，继承等等这些知识，后面可能会学到例如网络通信协议的东西让你写一些通信的小demo，当然要会到什么程度才能开发自己的工具的话，看你个人的需求，我觉得基本上只要你会基础语法，知道函数，类，子类，父类，重写，继承啥的就可以自己去开发一些工具了。</p>
<p>如果你的工具只是针对于本地的东西的话，你只需了解你想要实现的原理，后面根据这个原理去设计你的开发架构，那你压根不需要用到什么网络通信协议啥的，但是如果你需要对接网络上的一些资源的话，那么通信协议还是得会的，当然，这些对百度工程师是例外的，把你想要实现的去百度上搜索，基本上都会有解答，百度能实现百分之99的困难。</p>
<h2 id="2-4开发思路"><a href="#2-4开发思路" class="headerlink" title="2.4开发思路"></a>2.4开发思路</h2><p>不管是开发啥，你对成果一定要有个大概的框架，不一定要先想好界面，但是功能，要实现怎样的功能，这些功能能实现什么样的效果，以及如何去实现这些功能。大部分工具开发的流程都是一致的，基本上都是三部分：</p>
<ol>
<li>数据获取：怎么获取你想要的数据，例如怎么和网站进行通信，怎么连接数据库，怎么获取数据库的数据等等</li>
<li>数据处理：拿到数据之后，如何对数据进行处理，获取到你想要的那部分数据，一般我们在数据获取的的时候，是没办法直接获取到你想要的那部分数据的，基本上都是一锅端回来，然后根据显示出来的数据情况进行筛选，过滤，还有一种情况就是你获取到的数据需要进一步的处理，例如你获取回来的数据需要再进行一轮的数据分析，或者与你现有的特征进行比对等等这些情况，所以在数据获取和数据处理这两个方面是开发工具的时候最难的地方。</li>
<li>数据显示：如果前面数据获取和数据处理都完成了，那么就来到了最简单的地方，怎么呈现你的结果，是命令行还是界面，这个取决于个人喜好。</li>
</ol>
<p>所以，根据这三个部分基本上能满足你开发大部分的工具，而且你在开发这些工具的时候思路会很清晰，始终清楚自己在哪一部分，在哪一部分就干哪一部分的事情，找那块的解决方法，网上会有很多教程，其实工具就类似是拼图，你这找一下怎么实现，那找一下怎么实现，然后拼接起来，就成了工具，一句话，CCV，一把梭哈，冲就完事了。这里附下小弟我搞小工具的时候常规的思维导图。</p>
<p><img src="https://ax-x.github.io/2022/01/20/%E5%AE%89%E5%85%A8%E5%B0%8F%E7%99%BD%E6%80%8E%E4%B9%88%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%8B%A5%E6%9C%89%E8%87%AA%E5%B7%B1%E7%9A%84%E6%AD%A6%E5%99%A8%E5%BA%93/image-20211127004010265.png" alt="image-20211127004010265"></p>
<h1 id="三、开发过程"><a href="#三、开发过程" class="headerlink" title="三、开发过程"></a>三、开发过程</h1><p>这里如果空讲的话会有点空泛，我用我之前搞的一个小工具来做例子吧，直接说我自己开发这个工具的时候的一个开发思路会比较好一点，这是个子域名的一个探测工具，主要功能的话就是根据你输入的域名进行子域名的探测，然后根据页面的状态剔除那些无法访问的，把可以访问的留下来保存数据，这个是我后面用来采集页面样本然后做页面分类的，所以还有其他功能，这里我主要讲下如何探测子域名状态值的设计思路和开发过程。</p>
<h2 id="3-1开发架构"><a href="#3-1开发架构" class="headerlink" title="3.1开发架构"></a>3.1开发架构</h2><p>架构的话根据三个流程来准备，然后搞个思维导图（虽然也没啥必要，但是可以让后面自己的思路清晰，不会跑偏）</p>
<ol>
<li>数据获取：怎么通过域名连接到网站，然后获取到网站的状态值</li>
<li>数据处理：获取完数据之后怎么处理数据，将数据整理成我想要的格式，例如，域名，IP，开放端口，网站状态这样，把有用的数据单独拿出来</li>
<li>数据显示：数据处理完之后通过界面显示出收集的结果，然后把数据导出来，通过固定格式保存，方便之后的操作。</li>
</ol>
<p>贴下思维导图，这里只写了探测网站状态值那部分，其他的功能都差不多的，每个人的思路会有所不同，所以这块没啥大问题。</p>
<p><img src="https://ax-x.github.io/2022/01/20/%E5%AE%89%E5%85%A8%E5%B0%8F%E7%99%BD%E6%80%8E%E4%B9%88%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%8B%A5%E6%9C%89%E8%87%AA%E5%B7%B1%E7%9A%84%E6%AD%A6%E5%99%A8%E5%BA%93/image-20211128180018515.png" alt="image-20211128180018515"></p>
<h2 id="3-2实现目标"><a href="#3-2实现目标" class="headerlink" title="3.2实现目标"></a>3.2实现目标</h2><h3 id="3-2-1获取网站状态值"><a href="#3-2-1获取网站状态值" class="headerlink" title="3.2.1获取网站状态值"></a>3.2.1获取网站状态值</h3><p>如何获取网站状态值在上面的思维导图上面已经写了，通过java的uConnection.getResponseCode()可以获取状态码。进而判断该网站是否存在，具体代码怎么用以及返回的值，类型可以自己百度一下，我这里贴一下关键代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">URL u = <span class="keyword">new</span> URL(<span class="string">&quot;http://www.baidu.com&quot;</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;  </span><br><span class="line">	HttpURLConnection uConnection = (HttpURLConnection)u.openConnection();  </span><br><span class="line">	<span class="keyword">try</span> &#123;  </span><br><span class="line">		uConnection.connect();</span><br><span class="line">		System.out.println(uConnection.getResponseCode());  </span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">			e.printStackTrace();  </span><br><span class="line">		&#125;                    </span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;  </span><br><span class="line">			e.printStackTrace();  </span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>上面就是一个简单的通过url去连接网站，获取它返回的状态值，然后输出状态值，因为这里是连接的<a href="http://www.baidu.com,所以返回的是200,这个你们可以直接拿去运行看看内容,这个就是简单的一个实现过程,然后后面的可以把自己的字典导进去,获取你字典的数据,拼接到.baidu.com前面,再弄个多线程让他一直探测下去获取返回的值就行了./">www.baidu.com，所以返回的是200，这个你们可以直接拿去运行看看内容，这个就是简单的一个实现过程，然后后面的可以把自己的字典导进去，获取你字典的数据，拼接到.baidu.com前面，再弄个多线程让他一直探测下去获取返回的值就行了。</a></p>
<h3 id="3-2-2筛选自己想要的数据"><a href="#3-2-2筛选自己想要的数据" class="headerlink" title="3.2.2筛选自己想要的数据"></a>3.2.2筛选自己想要的数据</h3><p>上面我们已经拿到了网站的状态值，那么我们可以根据返回的状态值去对数据进行判断是不是该存起来，一个if就能解决的事情了，如果你想根据状态值来分类的话搞个switch就行了，例如说我们想要过滤一些数据，用if去过滤这些数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">if</span> (!logres.equals(logsql) &amp;&amp; !logres.contains(<span class="string">&quot;/* mysql&quot;</span>) &amp;&amp; !logres.contains(<span class="string">&quot;SHOW WARNINGS&quot;</span>) &amp;&amp; !logres.contains(<span class="string">&quot;select event_time,argument from%%&quot;</span>))</span><br><span class="line">Database_listening.sql_date.appendText(time.format(Long.valueOf(System.currentTimeMillis()))+<span class="string">&quot;------&quot;</span>+logres+<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这样虽然方便，但是当你想要过滤的数据过多的时候，就需要列很长的条件，这样就太麻烦了，这时候就需要用其他的一些技能，比如说把黑名单存到文档然后根据文档里的内容去进行拦截等其他方式。</p>
<h3 id="3-2-3界面实现"><a href="#3-2-3界面实现" class="headerlink" title="3.2.3界面实现"></a>3.2.3界面实现</h3><p>这里说下几个面板，这个算是JAVAFX里面比较常见的面板了，其实界面没什么，就跟HTML差不多，一个套一个，套娃来的，你只要提前想好你自己的数据想要显示的位置，然后去布置按钮位置，数据显示位置就行了。</p>
<ul>
<li>StackPane（堆叠面板）：节点按照被添加的顺序从左到右、从上到下显示。</li>
<li>FlowPane（流式面板 ）：节点在5个区域显示－上、下、左、右、中</li>
<li>GridPane（栅格面板）：节点以灵活的行列栅格形式排列，这个可以根据自己的安排去排列那些元素的位置(0,0),(0,1),(1,0)(1,1)这样</li>
<li>BorderPane（边界面板）：将节点有序地排列在一个水平行中。当节点到达面板边界时，不会折行显示。</li>
<li>Hbox、Vbox（盒式面板）：Hbox将节点有序地排列在一个垂直列中。当节点到达面板边界时，不会折行显示，Vbox将节点有序地排列在一个中。当节点到达面板边界时，不会折行显示。</li>
</ul>
<p>其实这个是很简单的面板介绍，基本上都是按这些面板去堆叠出来的，我这里贴一个简单的面板加按钮的示例代码，运行这个看的话可能会更理解点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">label = <span class="keyword">new</span> Label(<span class="string">&quot;累加计数 &quot;</span>+count);</span><br><span class="line">Button btnPush = <span class="keyword">new</span> Button (<span class="string">&quot;+1&quot;</span>);	</span><br><span class="line"><span class="comment">//设置一个label和button</span></span><br><span class="line">btnPush.setOnAction(<span class="keyword">this</span>::btnPushHandler);</span><br><span class="line"><span class="comment">//设置按钮的事件，点击按钮之后会发生什么事情</span></span><br><span class="line">FlowPane pane = <span class="keyword">new</span> FlowPane (btnPush,label);</span><br><span class="line"><span class="comment">//然后把按钮和label放到面板里面，这个是流式的，直接横着排列</span></span><br><span class="line">pane.setHgap(<span class="number">20</span>);</span><br><span class="line">pane.setAlignment(Pos.CENTER);</span><br><span class="line">Scene scene = <span class="keyword">new</span> Scene(pane, <span class="number">300</span>,<span class="number">100</span>);</span><br><span class="line"><span class="comment">//设置面板大小</span></span><br><span class="line">stage.setScene(scene);</span><br><span class="line">stage.setTitle(<span class="string">&quot;面板示例&quot;</span>);</span><br><span class="line"><span class="comment">//面板title</span></span><br><span class="line">stage.show();</span><br><span class="line"><span class="comment">//显示出来</span></span><br></pre></td></tr></table></figure>

<p>这个面板也完成了，当你把面板设计好之后，把你完成的代码分模块放到每个按钮的事件里面去，上面的那句btnPush.setOnAction(this::btnPbushHandler)是把btnPbushHandler事件设置到btnPush这个按钮里面去，当点击到btnPush按钮的时候，执行该事件，例如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Connect_SQL = <span class="keyword">new</span> Button(<span class="string">&quot;连接数据库&quot;</span>);</span><br><span class="line"><span class="comment">//设置一个按钮叫Connect_SQL</span></span><br><span class="line">Connect_SQL.setOnAction(<span class="keyword">this</span>::ConnectSQL);</span><br><span class="line"><span class="comment">//点击该按钮之后执行ConnectSQL事件</span></span><br><span class="line">------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"><span class="comment">//编写ConnectSQL，当点击了该按钮之后执行ConnectSQL事件，去连接数据库</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConnectSQL</span><span class="params">(ActionEvent event)</span></span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	ConnectSQL.Connect(sql_addr.getText(), sql_port.getText(), sql_user.getText(), sql_password.getText());</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">	<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">	e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就把按钮和事件响应连接起来，设计相对应的按钮和事件，去达到自己想要实现的目标，基本上这个工具就完成了，当工具写完了之后，不可能每次都进编译器里面去运行吧，把它导出来成为一个.jar的文件，之后直接执行这个文件就行了。</p>
<p>右键项目，点击Export，选择jar file</p>
<p><img src="https://ax-x.github.io/2022/01/20/%E5%AE%89%E5%85%A8%E5%B0%8F%E7%99%BD%E6%80%8E%E4%B9%88%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%8B%A5%E6%9C%89%E8%87%AA%E5%B7%B1%E7%9A%84%E6%AD%A6%E5%99%A8%E5%BA%93/image-20211220112323902.png" alt="image-20211220112323902"></p>
<p>然后把自己的项目勾选上，直接finish，就完成了。</p>
<p><img src="https://ax-x.github.io/2022/01/20/%E5%AE%89%E5%85%A8%E5%B0%8F%E7%99%BD%E6%80%8E%E4%B9%88%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%8B%A5%E6%9C%89%E8%87%AA%E5%B7%B1%E7%9A%84%E6%AD%A6%E5%99%A8%E5%BA%93/image-20211220112454283.png" alt="image-20211220112454283"></p>
<p>至此，整个工具的编写就完成了</p>
<h1 id="四、实战"><a href="#四、实战" class="headerlink" title="四、实战"></a>四、实战</h1><h2 id="4-1工具说明"><a href="#4-1工具说明" class="headerlink" title="4.1工具说明"></a>4.1工具说明</h2><p>一个Mysql监控工具的思路以及实现方式，实现了指定数据库名监控跟它有关的sql语句，单独显示特定的sql语句,刚开始自己用的那些网上的工具不是很理想，所以就打算自己写一个，目前只实现了这两个功能，后面会把它改成一个代审工具，实现从sql语句跳定位到代码啥的。</p>
<h2 id="4-2开发思路"><a href="#4-2开发思路" class="headerlink" title="4.2开发思路"></a>4.2开发思路</h2><p>工具的思路其实也很简单，主要就是这四块</p>
<ol>
<li>连接数据库</li>
<li>监听数据库日志</li>
<li>对数据库日志的数据进行过滤</li>
<li>显示数据</li>
</ol>
<p>而工具最终目标是：用户连接上数据库之后，在测试代码或者网站功能的时候，经过该工具过滤能够定位到执行的sql语句，方便进行代码审计</p>
<p><img src="https://ax-x.github.io/2022/01/20/%E5%AE%89%E5%85%A8%E5%B0%8F%E7%99%BD%E6%80%8E%E4%B9%88%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%8B%A5%E6%9C%89%E8%87%AA%E5%B7%B1%E7%9A%84%E6%AD%A6%E5%99%A8%E5%BA%93/20211115165221-5892b92c-45f1-1-16407678891502.png" alt="image.png"></p>
<h2 id="4-3前期准备"><a href="#4-3前期准备" class="headerlink" title="4.3前期准备"></a>4.3前期准备</h2><ul>
<li>连接数据库实现</li>
<li>兼容不同的Mysql版本</li>
<li>监听数据库的方式</li>
<li>过滤脏数据</li>
<li>准确过滤出自己想要的语句</li>
</ul>
<h2 id="4-4目标实现"><a href="#4-4目标实现" class="headerlink" title="4.4目标实现"></a>4.4目标实现</h2><h3 id="4-4-1连接数据库"><a href="#4-4-1连接数据库" class="headerlink" title="4.4.1连接数据库"></a>4.4.1连接数据库</h3><h4 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h4><p>连接数据库我用的是JDBC去连接MySQL数据库，连接 MySQL的话需要 需要驱动包，最新版下载地址为：**<a href="http://dev.mysql.com/downloads/connector/j/**%EF%BC%8C%E8%A7%A3%E5%8E%8B%E5%90%8E%E5%BE%97%E5%88%B0">http://dev.mysql.com/downloads/connector/j/**，解压后得到</a> jar 库文件，然后在对应的项目中导入该库文件。要兼容版本的话得下两个jar，一个兼容8以上的，一个兼容以下的。</p>
<p>MySQL 8.0 以上版本的数据库连接部分不同：</p>
<p>MySQL 8.0 以上版本驱动包版本<a href="https://static.runoob.com/download/mysql-connector-java-8.0.16.jar">mysql-connector-java-8.0.16.jar</a>。</p>
<p>com.mysql.jdbc.Driver 更换为com.mysql.cj.jdbc.Driver。</p>
<p>MySQL 8.0以上版本无需建立SSL连接，需要显示关闭。</p>
<p>allowPublicKeyRetrieval=true 允许客户端从服务器获取密钥，最后还需要设置 CST</p>
<p>加载驱动与连接数据库方式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class.forName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line">conn = DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://localhost:3306/test_demo?useSSL=false&amp;allowPublicKeyRetrieval=true&amp;serverTimezone=UTC&quot;</span>,<span class="string">&quot;root&quot;</span>,<span class="string">&quot;password&quot;</span>);</span><br><span class="line">MySQL <span class="number">8.0</span> 以下版本 - JDBC 驱动名及数据库 URL   </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> String JDBC_DRIVER = <span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>; </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> String DB_URL = <span class="string">&quot;jdbc:mysql://[localhost:3306/RUNOOB](http://localhost:3306/RUNOOB)&quot;</span>;</span><br><span class="line"><span class="comment">// MySQL 8.0 以上版本 - JDBC 驱动名及数据库 URL    </span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> String JDBC_DRIVER = <span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>; </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> String DB_URL = <span class="string">&quot;jdbc:mysql://[localhost:3306/RUNOOB?useSSL=false&amp;allowPublicKeyRetrieval=true&amp;serverTimezone=UTC](http://localhost:3306/RUNOOB?useSSL=false&amp;allowPublicKeyRetrieval=true&amp;serverTimezone=UTC)&quot;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="关键代码"><a href="#关键代码" class="headerlink" title="关键代码"></a>关键代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EventHandler&lt;ActionEvent&gt; <span class="title">Connect</span><span class="params">(String sql_addr, String sql_port, String sql_user,String sql_password)</span><span class="keyword">throws</span> ClassNotFoundException, SQLException  </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		USER = sql_user;</span><br><span class="line">		PASS = sql_password;</span><br><span class="line">		Connection conn = <span class="keyword">null</span>;</span><br><span class="line">        Statement stmt = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">        	JDBC_DRIVER = <span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>;</span><br><span class="line">        	DB_URL = <span class="string">&quot;jdbc:mysql://&quot;</span> + sql_addr + <span class="string">&quot;:&quot;</span> + sql_port + <span class="string">&quot;/mysql?useUnicode=true&amp;characterEncoding=utf8&amp;serverTimezone=GMT%2B8&amp;useSSL=false&quot;</span>;</span><br><span class="line">        	 <span class="comment">// 注册 JDBC 驱动</span></span><br><span class="line">            Class.forName(JDBC_DRIVER);</span><br><span class="line">            <span class="comment">// 打开链接</span></span><br><span class="line">            Database_listening.sql_date.appendText(time.format(Long.valueOf(System.currentTimeMillis()))+<span class="string">&quot;------正在连接数据库...&quot;</span>+<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="comment">//            System.out.println(&quot;正在连接数据库...&quot;);</span></span><br><span class="line">            conn = DriverManager.getConnection(DB_URL,USER,PASS);</span><br><span class="line">            conn.prepareStatement(<span class="string">&quot;SET global general_log=on&quot;</span>).executeUpdate();</span><br><span class="line">            conn.prepareStatement(<span class="string">&quot;SET GLOBAL log_output=&#x27;table&#x27;&quot;</span>).executeUpdate();</span><br><span class="line">            DatabaseMetaData metaData = (DatabaseMetaData) conn.getMetaData();</span><br><span class="line">            String version = metaData.getDatabaseProductVersion();<span class="comment">//得到数据库版本信息</span></span><br><span class="line"><span class="comment">//            System.out.println(time.format(Long.valueOf(System.currentTimeMillis()))+&quot;--当前数据库版本为：&quot;+version);</span></span><br><span class="line">            Database_listening.sql_date.appendText(time.format(Long.valueOf(System.currentTimeMillis()))+<span class="string">&quot;------当前数据库版本为：&quot;</span>+version+<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            </span><br><span class="line">        &#125;<span class="keyword">catch</span>(SQLException se)&#123;</span><br><span class="line">        </span><br><span class="line">            JDBC_DRIVER = <span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>;</span><br><span class="line">        	DB_URL = <span class="string">&quot;jdbc:mysql://&quot;</span>+sql_addr+<span class="string">&quot;:&quot;</span>+sql_port+<span class="string">&quot;/mysql?useUnicode=true&amp;characterEncoding=utf8&amp;serverTimezone=GMT%2B8&amp;useSSL=false&quot;</span>;</span><br><span class="line">        	 <span class="comment">// 注册 JDBC 驱动</span></span><br><span class="line">            Class.forName(JDBC_DRIVER);</span><br><span class="line">            <span class="comment">// 打开链接</span></span><br><span class="line"><span class="comment">//            System.out.println(&quot;正在连接数据库...&quot;);</span></span><br><span class="line">            Database_listening.sql_date.appendText(time.format(Long.valueOf(System.currentTimeMillis()))+<span class="string">&quot;------正在连接数据库...&quot;</span>+<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            conn = DriverManager.getConnection(DB_URL,USER,PASS);</span><br><span class="line">            DatabaseMetaData metaData = (DatabaseMetaData) conn.getMetaData();</span><br><span class="line">            conn.prepareStatement(<span class="string">&quot;SET global general_log=on&quot;</span>).executeUpdate();</span><br><span class="line">            conn.prepareStatement(<span class="string">&quot;SET GLOBAL log_output=&#x27;table&#x27;&quot;</span>).executeUpdate();</span><br><span class="line">            String version = metaData.getDatabaseProductVersion();<span class="comment">//得到数据库版本信息</span></span><br><span class="line"><span class="comment">//            System.out.println(time.format(Long.valueOf(System.currentTimeMillis()))+&quot;--当前数据库版本为：&quot;+version);</span></span><br><span class="line">            Database_listening.sql_date.appendText(time.format(Long.valueOf(System.currentTimeMillis()))+<span class="string">&quot;------当前数据库版本为：&quot;</span>+version+<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            <span class="comment">// 处理 Class.forName 错误</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-4-2监听数据库日志"><a href="#4-4-2监听数据库日志" class="headerlink" title="4.4.2监听数据库日志"></a>4.4.2监听数据库日志</h3><h4 id="监听思路"><a href="#监听思路" class="headerlink" title="监听思路"></a>监听思路</h4><p>刚开始想的是直接对某个数据库的日志进行监听，但是后面发现需要修改数据库的配置文件，不是很方便，毕竟不想每监听一个就去改一下这个数据库的配置文件(想偷懒),还有就是监听缓存文件以及监听mysql数据库里面的一个表，我想着之后有可能把它改成一个代码审计的工具，所以直接监听整mysql的日志，后面再对脏数据进行过滤就行了。</p>
<p>根据上面的思路，我直接对Mysql里的general_log表进行监听，但是后面发现有很多脏数据，而且因为这个是整个Mysql的所以那些数据库运行的数据也会显示出来，导致我后面过滤脏数据一度尴尬，为了验证可行性，直接用if去过滤那些无用的数据，后面改成黑名单，直接把那些脏数据加进去然后过滤了</p>
<h4 id="关键代码-1"><a href="#关键代码-1" class="headerlink" title="关键代码"></a>关键代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String logsql = <span class="string">&quot;select * from mysql.general_log where command_type =\&quot;Query\&quot; OR command_type =\&quot;Execute\&quot; order by event_time desc limit 1,15&quot;</span>;</span><br><span class="line">	Connection conn = DriverManager.getConnection(DB_URL, USER, PASS);</span><br><span class="line">	ResultSet rs = conn.prepareStatement(logsql).executeQuery();</span><br><span class="line"><span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">	String logres = rs.getString(<span class="string">&quot;argument&quot;</span>);</span><br><span class="line"><span class="comment">//System.out.println(time.format(Long.valueOf(System.currentTimeMillis()))+&quot;：&quot;+logres);</span></span><br><span class="line">	Database_listening.sql_date.appendText(time.format(Long.valueOf(System.currentTimeMillis()))+<span class="string">&quot;------&quot;</span>+logres+<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>连接数据库，然后通过查询表内的数据，再不断输出，但是太多无用数据显示了，基本上每次都会显示SET NAMES utf8，SELECT @@session.autocommit，SHOW WARNINGS这些数据出来，太干扰看那些正常的语句了，所以我刚开始只是用了一层if去过滤这些数据，后面发现不大灵活，所以整成一个黑名单，可以动态添加删除拦截那些数据的规则。</p>
<h3 id="4-4-3过滤数据"><a href="#4-4-3过滤数据" class="headerlink" title="4.4.3过滤数据"></a>4.4.3过滤数据</h3><h4 id="过滤思路"><a href="#过滤思路" class="headerlink" title="过滤思路"></a>过滤思路</h4><p>刚开始获取的时候看到很多其他的数据来干扰，例如SELECT QUERY_ID，SHOW STATUS，SHOW FULL TABLES WHERE Table_type != ‘VIEW’这些，上面说到我用了个if去过滤那些带这个特征的数据，其实挺好用的，只不过后面想要动态的去调整这些黑名单，所以用了个下拉列表来存储数据，然后把数据过来只后再把下拉列表里面的数据进行处理，再把获取到的数据库信息一个个过滤掉，从而达到过滤的效果，</p>
<h4 id="关键代码-2"><a href="#关键代码-2" class="headerlink" title="关键代码"></a>关键代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!logres.equals(logsql) &amp;&amp; !logres.contains(<span class="string">&quot;/* mysql&quot;</span>) &amp;&amp; !logres.contains(<span class="string">&quot;SHOW WARNINGS&quot;</span>) &amp;&amp; !logres.contains(<span class="string">&quot;select event_time,argument from%%&quot;</span>) &amp;&amp; !logres.contains(<span class="string">&quot;SELECT STATE&quot;</span>) &amp;&amp; !logres.contains(<span class="string">&quot;SHOW STATUS&quot;</span>) &amp;&amp; !logres.contains(<span class="string">&quot;SELECT QUERY_ID&quot;</span>))&#123;</span><br><span class="line">     Database_listening.sql_date.appendText(time.format(Long.valueOf(System.currentTimeMillis()))+<span class="string">&quot;------&quot;</span>+logres+<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这基本上工具就写完了，这个算是比较简单的工具，开发思路也比较简单，也没用到什么奇奇怪怪的操作，基本上都是基础语法，挺适合小白上手工具开发的，</p>
<p>排版完面板之后把功能加入到各个按钮事件里面导出称jar文件，运行就可以用了，当然在编译器了也可以直接使用，看个人选择吧。</p>
<p><img src="https://ax-x.github.io/2022/01/20/%E5%AE%89%E5%85%A8%E5%B0%8F%E7%99%BD%E6%80%8E%E4%B9%88%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%8B%A5%E6%9C%89%E8%87%AA%E5%B7%B1%E7%9A%84%E6%AD%A6%E5%99%A8%E5%BA%93/image-20220106231423032-16414820643301.png" alt="image-20220106231423032"></p>
<h1 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h1><p>总的来说，开发工具其实没什么难度，把每一块拆分成多个小点去完成，然后拼接起来就行了，第一次写这种关于工具开发的文，有些可能没表达到位，我尽量把需要注意的地方给写出来，这个是针对于小白的，所以有些简单的东西还是选择说得仔细点，大佬们可以选择性的跳一跳，这个是第一篇，后面的话会根据自己平时开发的一些插件，工具啥的写一些开发思路或者教程，后面可能就不会讲面板这些东西了，如果有那里写得不对的，希望大佬们带带我。</p>
]]></content>
      <categories>
        <category>安全开发</category>
      </categories>
      <tags>
        <tag>安全工具</tag>
      </tags>
  </entry>
</search>
